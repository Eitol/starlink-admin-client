// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: spacex/api/device/dish.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SpaceX_API_Device_UserMobilityClass: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case stationary // = 0
  case nomadic // = 1
  case mobile // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .stationary
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stationary
    case 1: self = .nomadic
    case 2: self = .mobile
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .stationary: return 0
    case .nomadic: return 1
    case .mobile: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_UserMobilityClass] = [
    .stationary,
    .nomadic,
    .mobile,
  ]

}

enum SpaceX_API_Device_SoftwareUpdateState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case idle // = 1
  case fetching // = 2
  case preCheck // = 3
  case writing // = 4
  case postCheck // = 5
  case rebootRequired // = 6
  case disabled // = 7
  case faulted // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .idle
    case 2: self = .fetching
    case 3: self = .preCheck
    case 4: self = .writing
    case 5: self = .postCheck
    case 6: self = .rebootRequired
    case 7: self = .disabled
    case 8: self = .faulted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .idle: return 1
    case .fetching: return 2
    case .preCheck: return 3
    case .writing: return 4
    case .postCheck: return 5
    case .rebootRequired: return 6
    case .disabled: return 7
    case .faulted: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_SoftwareUpdateState] = [
    .unknown,
    .idle,
    .fetching,
    .preCheck,
    .writing,
    .postCheck,
    .rebootRequired,
    .disabled,
    .faulted,
  ]

}

enum SpaceX_API_Device_UserClassOfService: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknownUserClassOfService // = 0
  case consumer // = 1
  case business // = 2
  case businessPlus // = 3
  case commercialAviation // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownUserClassOfService
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownUserClassOfService
    case 1: self = .consumer
    case 2: self = .business
    case 3: self = .businessPlus
    case 4: self = .commercialAviation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownUserClassOfService: return 0
    case .consumer: return 1
    case .business: return 2
    case .businessPlus: return 3
    case .commercialAviation: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_UserClassOfService] = [
    .unknownUserClassOfService,
    .consumer,
    .business,
    .businessPlus,
    .commercialAviation,
  ]

}

enum SpaceX_API_Device_HasActuators: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case yes // = 1
  case no // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .yes
    case 2: self = .no
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .yes: return 1
    case .no: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_HasActuators] = [
    .unknown,
    .yes,
    .no,
  ]

}

enum SpaceX_API_Device_ActuatorState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case idle // = 0
  case fullTilt // = 1
  case rotate // = 2
  case tilt // = 3
  case unwrapPositive // = 4
  case unwrapNegative // = 5
  case tiltToStowed // = 6
  case faulted // = 7
  case waitTilStatic // = 8
  case driveToMobilePosition // = 9
  case mobileWait // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .fullTilt
    case 2: self = .rotate
    case 3: self = .tilt
    case 4: self = .unwrapPositive
    case 5: self = .unwrapNegative
    case 6: self = .tiltToStowed
    case 7: self = .faulted
    case 8: self = .waitTilStatic
    case 9: self = .driveToMobilePosition
    case 10: self = .mobileWait
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .fullTilt: return 1
    case .rotate: return 2
    case .tilt: return 3
    case .unwrapPositive: return 4
    case .unwrapNegative: return 5
    case .tiltToStowed: return 6
    case .faulted: return 7
    case .waitTilStatic: return 8
    case .driveToMobilePosition: return 9
    case .mobileWait: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_ActuatorState] = [
    .idle,
    .fullTilt,
    .rotate,
    .tilt,
    .unwrapPositive,
    .unwrapNegative,
    .tiltToStowed,
    .faulted,
    .waitTilStatic,
    .driveToMobilePosition,
    .mobileWait,
  ]

}

enum SpaceX_API_Device_AttitudeEstimationState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case filterReset // = 0
  case filterUnconverged // = 1
  case filterConverged // = 2
  case filterFaulted // = 3
  case filterInvalid // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .filterReset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .filterReset
    case 1: self = .filterUnconverged
    case 2: self = .filterConverged
    case 3: self = .filterFaulted
    case 4: self = .filterInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .filterReset: return 0
    case .filterUnconverged: return 1
    case .filterConverged: return 2
    case .filterFaulted: return 3
    case .filterInvalid: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_AttitudeEstimationState] = [
    .filterReset,
    .filterUnconverged,
    .filterConverged,
    .filterFaulted,
    .filterInvalid,
  ]

}

enum SpaceX_API_Device_DishState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case connected // = 1
  case searching // = 2
  case booting // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .connected
    case 2: self = .searching
    case 3: self = .booting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .connected: return 1
    case .searching: return 2
    case .booting: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_DishState] = [
    .unknown,
    .connected,
    .searching,
    .booting,
  ]

}

struct SpaceX_API_Device_DishStowRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unstow: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishStowResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetContextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetContextResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceInfo: SpaceX_API_Device_DeviceInfo {
    get {return _storage._deviceInfo ?? SpaceX_API_Device_DeviceInfo()}
    set {_uniqueStorage()._deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  var hasDeviceInfo: Bool {return _storage._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  mutating func clearDeviceInfo() {_uniqueStorage()._deviceInfo = nil}

  var deviceState: SpaceX_API_Device_DeviceState {
    get {return _storage._deviceState ?? SpaceX_API_Device_DeviceState()}
    set {_uniqueStorage()._deviceState = newValue}
  }
  /// Returns true if `deviceState` has been explicitly set.
  var hasDeviceState: Bool {return _storage._deviceState != nil}
  /// Clears the value of `deviceState`. Subsequent reads from it will return its default value.
  mutating func clearDeviceState() {_uniqueStorage()._deviceState = nil}

  var obstructionFraction: Float {
    get {return _storage._obstructionFraction}
    set {_uniqueStorage()._obstructionFraction = newValue}
  }

  var obstructionTime: Float {
    get {return _storage._obstructionTime}
    set {_uniqueStorage()._obstructionTime = newValue}
  }

  var obstructionValidS: Float {
    get {return _storage._obstructionValidS}
    set {_uniqueStorage()._obstructionValidS = newValue}
  }

  var obstructionCurrent: Bool {
    get {return _storage._obstructionCurrent}
    set {_uniqueStorage()._obstructionCurrent = newValue}
  }

  var cellID: UInt32 {
    get {return _storage._cellID}
    set {_uniqueStorage()._cellID = newValue}
  }

  var popRackID: UInt32 {
    get {return _storage._popRackID}
    set {_uniqueStorage()._popRackID = newValue}
  }

  var initialSatelliteID: UInt32 {
    get {return _storage._initialSatelliteID}
    set {_uniqueStorage()._initialSatelliteID = newValue}
  }

  var initialGatewayID: UInt32 {
    get {return _storage._initialGatewayID}
    set {_uniqueStorage()._initialGatewayID = newValue}
  }

  var onBackupBeam: Bool {
    get {return _storage._onBackupBeam}
    set {_uniqueStorage()._onBackupBeam = newValue}
  }

  var secondsToSlotEnd: Float {
    get {return _storage._secondsToSlotEnd}
    set {_uniqueStorage()._secondsToSlotEnd = newValue}
  }

  var debugTelemetryEnabled: Bool {
    get {return _storage._debugTelemetryEnabled}
    set {_uniqueStorage()._debugTelemetryEnabled = newValue}
  }

  var popPingDropRate15SMean: Float {
    get {return _storage._popPingDropRate15SMean}
    set {_uniqueStorage()._popPingDropRate15SMean = newValue}
  }

  var popPingLatencyMs15SMean: Float {
    get {return _storage._popPingLatencyMs15SMean}
    set {_uniqueStorage()._popPingLatencyMs15SMean = newValue}
  }

  var secondsSinceLast1SOutage: Float {
    get {return _storage._secondsSinceLast1SOutage}
    set {_uniqueStorage()._secondsSinceLast1SOutage = newValue}
  }

  var secondsSinceLast2SOutage: Float {
    get {return _storage._secondsSinceLast2SOutage}
    set {_uniqueStorage()._secondsSinceLast2SOutage = newValue}
  }

  var secondsSinceLast5SOutage: Float {
    get {return _storage._secondsSinceLast5SOutage}
    set {_uniqueStorage()._secondsSinceLast5SOutage = newValue}
  }

  var secondsSinceLast15SOutage: Float {
    get {return _storage._secondsSinceLast15SOutage}
    set {_uniqueStorage()._secondsSinceLast15SOutage = newValue}
  }

  var secondsSinceLast60SOutage: Float {
    get {return _storage._secondsSinceLast60SOutage}
    set {_uniqueStorage()._secondsSinceLast60SOutage = newValue}
  }

  var disablementCode: SpaceX_API_Satellites_Network_UtDisablementCode {
    get {return _storage._disablementCode}
    set {_uniqueStorage()._disablementCode = newValue}
  }

  var kuMacActiveRatio: Float {
    get {return _storage._kuMacActiveRatio}
    set {_uniqueStorage()._kuMacActiveRatio = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_DishOutage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cause: SpaceX_API_Device_DishOutage.Cause = .unknown

  var startTimestampNs: Int64 = 0

  var durationNs: UInt64 = 0

  var didSwitch: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Cause: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case booting // = 1
    case stowed // = 2
    case thermalShutdown // = 3
    case noSchedule // = 4
    case noSats // = 5
    case obstructed // = 6
    case noDownlink // = 7
    case noPings // = 8
    case actuatorActivity // = 9
    case cableTest // = 10
    case sleeping // = 11
    case movingWhileNotAllowed // = 12
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .booting
      case 2: self = .stowed
      case 3: self = .thermalShutdown
      case 4: self = .noSchedule
      case 5: self = .noSats
      case 6: self = .obstructed
      case 7: self = .noDownlink
      case 8: self = .noPings
      case 9: self = .actuatorActivity
      case 10: self = .cableTest
      case 11: self = .sleeping
      case 12: self = .movingWhileNotAllowed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .booting: return 1
      case .stowed: return 2
      case .thermalShutdown: return 3
      case .noSchedule: return 4
      case .noSats: return 5
      case .obstructed: return 6
      case .noDownlink: return 7
      case .noPings: return 8
      case .actuatorActivity: return 9
      case .cableTest: return 10
      case .sleeping: return 11
      case .movingWhileNotAllowed: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_DishOutage.Cause] = [
      .unknown,
      .booting,
      .stowed,
      .thermalShutdown,
      .noSchedule,
      .noSats,
      .obstructed,
      .noDownlink,
      .noPings,
      .actuatorActivity,
      .cableTest,
      .sleeping,
      .movingWhileNotAllowed,
    ]

  }

  init() {}
}

struct SpaceX_API_Device_DishGetHistoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var current: UInt64 = 0

  var popPingDropRate: [Float] = []

  var popPingLatencyMs: [Float] = []

  var downlinkThroughputBps: [Float] = []

  var uplinkThroughputBps: [Float] = []

  var outages: [SpaceX_API_Device_DishOutage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetStatusResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceInfo: SpaceX_API_Device_DeviceInfo {
    get {return _storage._deviceInfo ?? SpaceX_API_Device_DeviceInfo()}
    set {_uniqueStorage()._deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  var hasDeviceInfo: Bool {return _storage._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  mutating func clearDeviceInfo() {_uniqueStorage()._deviceInfo = nil}

  var deviceState: SpaceX_API_Device_DeviceState {
    get {return _storage._deviceState ?? SpaceX_API_Device_DeviceState()}
    set {_uniqueStorage()._deviceState = newValue}
  }
  /// Returns true if `deviceState` has been explicitly set.
  var hasDeviceState: Bool {return _storage._deviceState != nil}
  /// Clears the value of `deviceState`. Subsequent reads from it will return its default value.
  mutating func clearDeviceState() {_uniqueStorage()._deviceState = nil}

  var alerts: SpaceX_API_Device_DishAlerts {
    get {return _storage._alerts ?? SpaceX_API_Device_DishAlerts()}
    set {_uniqueStorage()._alerts = newValue}
  }
  /// Returns true if `alerts` has been explicitly set.
  var hasAlerts: Bool {return _storage._alerts != nil}
  /// Clears the value of `alerts`. Subsequent reads from it will return its default value.
  mutating func clearAlerts() {_uniqueStorage()._alerts = nil}

  var outage: SpaceX_API_Device_DishOutage {
    get {return _storage._outage ?? SpaceX_API_Device_DishOutage()}
    set {_uniqueStorage()._outage = newValue}
  }
  /// Returns true if `outage` has been explicitly set.
  var hasOutage: Bool {return _storage._outage != nil}
  /// Clears the value of `outage`. Subsequent reads from it will return its default value.
  mutating func clearOutage() {_uniqueStorage()._outage = nil}

  var gpsStats: SpaceX_API_Device_DishGpsStats {
    get {return _storage._gpsStats ?? SpaceX_API_Device_DishGpsStats()}
    set {_uniqueStorage()._gpsStats = newValue}
  }
  /// Returns true if `gpsStats` has been explicitly set.
  var hasGpsStats: Bool {return _storage._gpsStats != nil}
  /// Clears the value of `gpsStats`. Subsequent reads from it will return its default value.
  mutating func clearGpsStats() {_uniqueStorage()._gpsStats = nil}

  var secondsToFirstNonemptySlot: Float {
    get {return _storage._secondsToFirstNonemptySlot}
    set {_uniqueStorage()._secondsToFirstNonemptySlot = newValue}
  }

  var popPingDropRate: Float {
    get {return _storage._popPingDropRate}
    set {_uniqueStorage()._popPingDropRate = newValue}
  }

  var downlinkThroughputBps: Float {
    get {return _storage._downlinkThroughputBps}
    set {_uniqueStorage()._downlinkThroughputBps = newValue}
  }

  var uplinkThroughputBps: Float {
    get {return _storage._uplinkThroughputBps}
    set {_uniqueStorage()._uplinkThroughputBps = newValue}
  }

  var popPingLatencyMs: Float {
    get {return _storage._popPingLatencyMs}
    set {_uniqueStorage()._popPingLatencyMs = newValue}
  }

  var obstructionStats: SpaceX_API_Device_DishObstructionStats {
    get {return _storage._obstructionStats ?? SpaceX_API_Device_DishObstructionStats()}
    set {_uniqueStorage()._obstructionStats = newValue}
  }
  /// Returns true if `obstructionStats` has been explicitly set.
  var hasObstructionStats: Bool {return _storage._obstructionStats != nil}
  /// Clears the value of `obstructionStats`. Subsequent reads from it will return its default value.
  mutating func clearObstructionStats() {_uniqueStorage()._obstructionStats = nil}

  var stowRequested: Bool {
    get {return _storage._stowRequested}
    set {_uniqueStorage()._stowRequested = newValue}
  }

  var boresightAzimuthDeg: Float {
    get {return _storage._boresightAzimuthDeg}
    set {_uniqueStorage()._boresightAzimuthDeg = newValue}
  }

  var boresightElevationDeg: Float {
    get {return _storage._boresightElevationDeg}
    set {_uniqueStorage()._boresightElevationDeg = newValue}
  }

  var ethSpeedMbps: Int32 {
    get {return _storage._ethSpeedMbps}
    set {_uniqueStorage()._ethSpeedMbps = newValue}
  }

  var mobilityClass: SpaceX_API_Device_UserMobilityClass {
    get {return _storage._mobilityClass}
    set {_uniqueStorage()._mobilityClass = newValue}
  }

  var isSnrAboveNoiseFloor: Bool {
    get {return _storage._isSnrAboveNoiseFloor}
    set {_uniqueStorage()._isSnrAboveNoiseFloor = newValue}
  }

  var readyStates: SpaceX_API_Device_DishReadyStates {
    get {return _storage._readyStates ?? SpaceX_API_Device_DishReadyStates()}
    set {_uniqueStorage()._readyStates = newValue}
  }
  /// Returns true if `readyStates` has been explicitly set.
  var hasReadyStates: Bool {return _storage._readyStates != nil}
  /// Clears the value of `readyStates`. Subsequent reads from it will return its default value.
  mutating func clearReadyStates() {_uniqueStorage()._readyStates = nil}

  var classOfService: SpaceX_API_Device_UserClassOfService {
    get {return _storage._classOfService}
    set {_uniqueStorage()._classOfService = newValue}
  }

  var softwareUpdateState: SpaceX_API_Device_SoftwareUpdateState {
    get {return _storage._softwareUpdateState}
    set {_uniqueStorage()._softwareUpdateState = newValue}
  }

  var swupdateRebootReady: Bool {
    get {return _storage._swupdateRebootReady}
    set {_uniqueStorage()._swupdateRebootReady = newValue}
  }

  var softwareUpdateStats: SpaceX_API_Device_SoftwareUpdateStats {
    get {return _storage._softwareUpdateStats ?? SpaceX_API_Device_SoftwareUpdateStats()}
    set {_uniqueStorage()._softwareUpdateStats = newValue}
  }
  /// Returns true if `softwareUpdateStats` has been explicitly set.
  var hasSoftwareUpdateStats: Bool {return _storage._softwareUpdateStats != nil}
  /// Clears the value of `softwareUpdateStats`. Subsequent reads from it will return its default value.
  mutating func clearSoftwareUpdateStats() {_uniqueStorage()._softwareUpdateStats = nil}

  var alignmentStats: SpaceX_API_Device_AlignmentStats {
    get {return _storage._alignmentStats ?? SpaceX_API_Device_AlignmentStats()}
    set {_uniqueStorage()._alignmentStats = newValue}
  }
  /// Returns true if `alignmentStats` has been explicitly set.
  var hasAlignmentStats: Bool {return _storage._alignmentStats != nil}
  /// Clears the value of `alignmentStats`. Subsequent reads from it will return its default value.
  mutating func clearAlignmentStats() {_uniqueStorage()._alignmentStats = nil}

  var isSnrPersistentlyLow: Bool {
    get {return _storage._isSnrPersistentlyLow}
    set {_uniqueStorage()._isSnrPersistentlyLow = newValue}
  }

  var hasActuators_p: SpaceX_API_Device_HasActuators {
    get {return _storage._hasActuators_p}
    set {_uniqueStorage()._hasActuators_p = newValue}
  }

  var disablementCode: SpaceX_API_Satellites_Network_UtDisablementCode {
    get {return _storage._disablementCode}
    set {_uniqueStorage()._disablementCode = newValue}
  }

  var hasSignedCals_p: Bool {
    get {return _storage._hasSignedCals_p}
    set {_uniqueStorage()._hasSignedCals_p = newValue}
  }

  var config: SpaceX_API_Device_DishConfig {
    get {return _storage._config ?? SpaceX_API_Device_DishConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var initializationDurationSeconds: SpaceX_API_Device_InitializationDurationSeconds {
    get {return _storage._initializationDurationSeconds ?? SpaceX_API_Device_InitializationDurationSeconds()}
    set {_uniqueStorage()._initializationDurationSeconds = newValue}
  }
  /// Returns true if `initializationDurationSeconds` has been explicitly set.
  var hasInitializationDurationSeconds: Bool {return _storage._initializationDurationSeconds != nil}
  /// Clears the value of `initializationDurationSeconds`. Subsequent reads from it will return its default value.
  mutating func clearInitializationDurationSeconds() {_uniqueStorage()._initializationDurationSeconds = nil}

  var isCellDisabled: Bool {
    get {return _storage._isCellDisabled}
    set {_uniqueStorage()._isCellDisabled = newValue}
  }

  var secondsUntilSwupdateRebootPossible: Int32 {
    get {return _storage._secondsUntilSwupdateRebootPossible}
    set {_uniqueStorage()._secondsUntilSwupdateRebootPossible = newValue}
  }

  var connectedRouters: [String] {
    get {return _storage._connectedRouters}
    set {_uniqueStorage()._connectedRouters = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_DishGetObstructionMapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetObstructionMapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numRows: UInt32 = 0

  var numCols: UInt32 = 0

  var snr: [Float] = []

  /// NOTE: This field was marked as deprecated in the .proto file.
  var minElevationDeg: Float = 0

  var maxThetaDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishAlerts: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var motorsStuck: Bool {
    get {return _storage._motorsStuck}
    set {_uniqueStorage()._motorsStuck = newValue}
  }

  var thermalThrottle: Bool {
    get {return _storage._thermalThrottle}
    set {_uniqueStorage()._thermalThrottle = newValue}
  }

  var thermalShutdown: Bool {
    get {return _storage._thermalShutdown}
    set {_uniqueStorage()._thermalShutdown = newValue}
  }

  var mastNotNearVertical: Bool {
    get {return _storage._mastNotNearVertical}
    set {_uniqueStorage()._mastNotNearVertical = newValue}
  }

  var unexpectedLocation: Bool {
    get {return _storage._unexpectedLocation}
    set {_uniqueStorage()._unexpectedLocation = newValue}
  }

  var slowEthernetSpeeds: Bool {
    get {return _storage._slowEthernetSpeeds}
    set {_uniqueStorage()._slowEthernetSpeeds = newValue}
  }

  var slowEthernetSpeeds100: Bool {
    get {return _storage._slowEthernetSpeeds100}
    set {_uniqueStorage()._slowEthernetSpeeds100 = newValue}
  }

  var roaming: Bool {
    get {return _storage._roaming}
    set {_uniqueStorage()._roaming = newValue}
  }

  var installPending: Bool {
    get {return _storage._installPending}
    set {_uniqueStorage()._installPending = newValue}
  }

  var isHeating: Bool {
    get {return _storage._isHeating}
    set {_uniqueStorage()._isHeating = newValue}
  }

  var powerSupplyThermalThrottle: Bool {
    get {return _storage._powerSupplyThermalThrottle}
    set {_uniqueStorage()._powerSupplyThermalThrottle = newValue}
  }

  var isPowerSaveIdle: Bool {
    get {return _storage._isPowerSaveIdle}
    set {_uniqueStorage()._isPowerSaveIdle = newValue}
  }

  var movingWhileNotMobile: Bool {
    get {return _storage._movingWhileNotMobile}
    set {_uniqueStorage()._movingWhileNotMobile = newValue}
  }

  var movingTooFastForPolicy: Bool {
    get {return _storage._movingTooFastForPolicy}
    set {_uniqueStorage()._movingTooFastForPolicy = newValue}
  }

  var dbfTelemStale: Bool {
    get {return _storage._dbfTelemStale}
    set {_uniqueStorage()._dbfTelemStale = newValue}
  }

  var lowMotorCurrent: Bool {
    get {return _storage._lowMotorCurrent}
    set {_uniqueStorage()._lowMotorCurrent = newValue}
  }

  var lowerSignalThanPredicted: Bool {
    get {return _storage._lowerSignalThanPredicted}
    set {_uniqueStorage()._lowerSignalThanPredicted = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_DishReadyStates: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cady: Bool = false

  var scp: Bool = false

  var l1L2: Bool = false

  var xphy: Bool = false

  var aap: Bool = false

  var rf: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGpsStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gpsValid: Bool = false

  var gpsSats: UInt32 = 0

  var noSatsAfterTtff: Bool = false

  var inhibitGps: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SoftwareUpdateStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var softwareUpdateState: SpaceX_API_Device_SoftwareUpdateState = .unknown

  var softwareUpdateProgress: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_AlignmentStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hasActuators_p: SpaceX_API_Device_HasActuators = .unknown

  var actuatorState: SpaceX_API_Device_ActuatorState = .idle

  var tiltAngleDeg: Float = 0

  var boresightAzimuthDeg: Float = 0

  var boresightElevationDeg: Float = 0

  var desiredBoresightAzimuthDeg: Float = 0

  var desiredBoresightElevationDeg: Float = 0

  var attitudeEstimationState: SpaceX_API_Device_AttitudeEstimationState = .filterReset

  var attitudeUncertaintyDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishObstructionStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentlyObstructed: Bool = false

  var fractionObstructed: Float = 0

  var timeObstructed: Float = 0

  var validS: Float = 0

  var patchesValid: UInt32 = 0

  var avgProlongedObstructionDurationS: Float = 0

  var avgProlongedObstructionIntervalS: Float = 0

  var avgProlongedObstructionValid: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_InitializationDurationSeconds: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attitudeInitialization: Int32 = 0

  var burstDetected: Int32 = 0

  var ekfConverged: Int32 = 0

  var firstCplane: Int32 = 0

  var firstPopPing: Int32 = 0

  var gpsValid: Int32 = 0

  var initialNetworkEntry: Int32 = 0

  var networkSchedule: Int32 = 0

  var rfReady: Int32 = 0

  var stableConnection: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishAuthenticateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dish: SpaceX_API_Device_ChallengeResponse {
    get {return _dish ?? SpaceX_API_Device_ChallengeResponse()}
    set {_dish = newValue}
  }
  /// Returns true if `dish` has been explicitly set.
  var hasDish: Bool {return self._dish != nil}
  /// Clears the value of `dish`. Subsequent reads from it will return its default value.
  mutating func clearDish() {self._dish = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dish: SpaceX_API_Device_ChallengeResponse? = nil
}

struct SpaceX_API_Device_SelfTestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var detailed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SelfTestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var passed: Bool = false

  var report: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_StartDishSelfTestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_StartDishSelfTestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SetTestModeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rfMode: SpaceX_API_Device_SetTestModeRequest.RfMode = .rx

  var disableLossOfCommFdir: Bool = false

  var enableRulesOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RfMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case rx // = 0
    case idle // = 1
    case tx // = 2
    case cal // = 3
    case user // = 4
    case normal // = 420
    case UNRECOGNIZED(Int)

    init() {
      self = .rx
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .rx
      case 1: self = .idle
      case 2: self = .tx
      case 3: self = .cal
      case 4: self = .user
      case 420: self = .normal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .rx: return 0
      case .idle: return 1
      case .tx: return 2
      case .cal: return 3
      case .user: return 4
      case .normal: return 420
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_SetTestModeRequest.RfMode] = [
      .rx,
      .idle,
      .tx,
      .cal,
      .user,
      .normal,
    ]

  }

  init() {}
}

struct SpaceX_API_Device_SetTestModeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishSetConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dishConfig: SpaceX_API_Device_DishConfig {
    get {return _dishConfig ?? SpaceX_API_Device_DishConfig()}
    set {_dishConfig = newValue}
  }
  /// Returns true if `dishConfig` has been explicitly set.
  var hasDishConfig: Bool {return self._dishConfig != nil}
  /// Clears the value of `dishConfig`. Subsequent reads from it will return its default value.
  mutating func clearDishConfig() {self._dishConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dishConfig: SpaceX_API_Device_DishConfig? = nil
}

struct SpaceX_API_Device_DishSetConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updatedDishConfig: SpaceX_API_Device_DishConfig {
    get {return _updatedDishConfig ?? SpaceX_API_Device_DishConfig()}
    set {_updatedDishConfig = newValue}
  }
  /// Returns true if `updatedDishConfig` has been explicitly set.
  var hasUpdatedDishConfig: Bool {return self._updatedDishConfig != nil}
  /// Clears the value of `updatedDishConfig`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedDishConfig() {self._updatedDishConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updatedDishConfig: SpaceX_API_Device_DishConfig? = nil
}

struct SpaceX_API_Device_DishGetConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dishConfig: SpaceX_API_Device_DishConfig {
    get {return _dishConfig ?? SpaceX_API_Device_DishConfig()}
    set {_dishConfig = newValue}
  }
  /// Returns true if `dishConfig` has been explicitly set.
  var hasDishConfig: Bool {return self._dishConfig != nil}
  /// Clears the value of `dishConfig`. Subsequent reads from it will return its default value.
  mutating func clearDishConfig() {self._dishConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dishConfig: SpaceX_API_Device_DishConfig? = nil
}

struct SpaceX_API_Device_DishInhibitGpsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inhibitGps: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishInhibitGpsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inhibitGps: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetDataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishClearObstructionMapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishClearObstructionMapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishActivateRssiScanRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scanQuery: SpaceX_API_Device_DishActivateRssiScan {
    get {return _scanQuery ?? SpaceX_API_Device_DishActivateRssiScan()}
    set {_scanQuery = newValue}
  }
  /// Returns true if `scanQuery` has been explicitly set.
  var hasScanQuery: Bool {return self._scanQuery != nil}
  /// Clears the value of `scanQuery`. Subsequent reads from it will return its default value.
  mutating func clearScanQuery() {self._scanQuery = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scanQuery: SpaceX_API_Device_DishActivateRssiScan? = nil
}

struct SpaceX_API_Device_DishActivateRssiScanResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetRssiScanResultRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetRssiScanResultResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: SpaceX_API_Device_DishGetRssiScanResult {
    get {return _result ?? SpaceX_API_Device_DishGetRssiScanResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: SpaceX_API_Device_DishGetRssiScanResult? = nil
}

struct SpaceX_API_Device_DishFactoryResetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishFactoryResetResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_ResetButtonRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_ResetButtonResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SpaceX.API.Device"

extension SpaceX_API_Device_UserMobilityClass: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATIONARY"),
    1: .same(proto: "NOMADIC"),
    2: .same(proto: "MOBILE"),
  ]
}

extension SpaceX_API_Device_SoftwareUpdateState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOFTWARE_UPDATE_STATE_UNKNOWN"),
    1: .same(proto: "IDLE"),
    2: .same(proto: "FETCHING"),
    3: .same(proto: "PRE_CHECK"),
    4: .same(proto: "WRITING"),
    5: .same(proto: "POST_CHECK"),
    6: .same(proto: "REBOOT_REQUIRED"),
    7: .same(proto: "DISABLED"),
    8: .same(proto: "FAULTED"),
  ]
}

extension SpaceX_API_Device_UserClassOfService: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_USER_CLASS_OF_SERVICE"),
    1: .same(proto: "CONSUMER"),
    2: .same(proto: "BUSINESS"),
    3: .same(proto: "BUSINESS_PLUS"),
    4: .same(proto: "COMMERCIAL_AVIATION"),
  ]
}

extension SpaceX_API_Device_HasActuators: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HAS_ACTUATORS_UNKNOWN"),
    1: .same(proto: "HAS_ACTUATORS_YES"),
    2: .same(proto: "HAS_ACTUATORS_NO"),
  ]
}

extension SpaceX_API_Device_ActuatorState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTUATOR_STATE_IDLE"),
    1: .same(proto: "ACTUATOR_STATE_FULL_TILT"),
    2: .same(proto: "ACTUATOR_STATE_ROTATE"),
    3: .same(proto: "ACTUATOR_STATE_TILT"),
    4: .same(proto: "ACTUATOR_STATE_UNWRAP_POSITIVE"),
    5: .same(proto: "ACTUATOR_STATE_UNWRAP_NEGATIVE"),
    6: .same(proto: "ACTUATOR_STATE_TILT_TO_STOWED"),
    7: .same(proto: "ACTUATOR_STATE_FAULTED"),
    8: .same(proto: "ACTUATOR_STATE_WAIT_TIL_STATIC"),
    9: .same(proto: "ACTUATOR_STATE_DRIVE_TO_MOBILE_POSITION"),
    10: .same(proto: "ACTUATOR_STATE_MOBILE_WAIT"),
  ]
}

extension SpaceX_API_Device_AttitudeEstimationState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILTER_RESET"),
    1: .same(proto: "FILTER_UNCONVERGED"),
    2: .same(proto: "FILTER_CONVERGED"),
    3: .same(proto: "FILTER_FAULTED"),
    4: .same(proto: "FILTER_INVALID"),
  ]
}

extension SpaceX_API_Device_DishState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONNECTED"),
    2: .same(proto: "SEARCHING"),
    3: .same(proto: "BOOTING"),
  ]
}

extension SpaceX_API_Device_DishStowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishStowRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unstow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.unstow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unstow != false {
      try visitor.visitSingularBoolField(value: self.unstow, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishStowRequest, rhs: SpaceX_API_Device_DishStowRequest) -> Bool {
    if lhs.unstow != rhs.unstow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishStowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishStowResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishStowResponse, rhs: SpaceX_API_Device_DishStowResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetContextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetContextRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetContextRequest, rhs: SpaceX_API_Device_DishGetContextRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetContextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetContextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_info"),
    7: .standard(proto: "device_state"),
    2: .standard(proto: "obstruction_fraction"),
    20: .standard(proto: "obstruction_time"),
    3: .standard(proto: "obstruction_valid_s"),
    12: .standard(proto: "obstruction_current"),
    4: .standard(proto: "cell_id"),
    5: .standard(proto: "pop_rack_id"),
    8: .standard(proto: "initial_satellite_id"),
    9: .standard(proto: "initial_gateway_id"),
    10: .standard(proto: "on_backup_beam"),
    6: .standard(proto: "seconds_to_slot_end"),
    11: .standard(proto: "debug_telemetry_enabled"),
    13: .standard(proto: "pop_ping_drop_rate_15s_mean"),
    14: .standard(proto: "pop_ping_latency_ms_15s_mean"),
    15: .standard(proto: "seconds_since_last_1s_outage"),
    16: .standard(proto: "seconds_since_last_2s_outage"),
    17: .standard(proto: "seconds_since_last_5s_outage"),
    18: .standard(proto: "seconds_since_last_15s_outage"),
    19: .standard(proto: "seconds_since_last_60s_outage"),
    21: .standard(proto: "disablement_code"),
    22: .standard(proto: "ku_mac_active_ratio"),
  ]

  fileprivate class _StorageClass {
    var _deviceInfo: SpaceX_API_Device_DeviceInfo? = nil
    var _deviceState: SpaceX_API_Device_DeviceState? = nil
    var _obstructionFraction: Float = 0
    var _obstructionTime: Float = 0
    var _obstructionValidS: Float = 0
    var _obstructionCurrent: Bool = false
    var _cellID: UInt32 = 0
    var _popRackID: UInt32 = 0
    var _initialSatelliteID: UInt32 = 0
    var _initialGatewayID: UInt32 = 0
    var _onBackupBeam: Bool = false
    var _secondsToSlotEnd: Float = 0
    var _debugTelemetryEnabled: Bool = false
    var _popPingDropRate15SMean: Float = 0
    var _popPingLatencyMs15SMean: Float = 0
    var _secondsSinceLast1SOutage: Float = 0
    var _secondsSinceLast2SOutage: Float = 0
    var _secondsSinceLast5SOutage: Float = 0
    var _secondsSinceLast15SOutage: Float = 0
    var _secondsSinceLast60SOutage: Float = 0
    var _disablementCode: SpaceX_API_Satellites_Network_UtDisablementCode = .unknownState
    var _kuMacActiveRatio: Float = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _deviceInfo = source._deviceInfo
      _deviceState = source._deviceState
      _obstructionFraction = source._obstructionFraction
      _obstructionTime = source._obstructionTime
      _obstructionValidS = source._obstructionValidS
      _obstructionCurrent = source._obstructionCurrent
      _cellID = source._cellID
      _popRackID = source._popRackID
      _initialSatelliteID = source._initialSatelliteID
      _initialGatewayID = source._initialGatewayID
      _onBackupBeam = source._onBackupBeam
      _secondsToSlotEnd = source._secondsToSlotEnd
      _debugTelemetryEnabled = source._debugTelemetryEnabled
      _popPingDropRate15SMean = source._popPingDropRate15SMean
      _popPingLatencyMs15SMean = source._popPingLatencyMs15SMean
      _secondsSinceLast1SOutage = source._secondsSinceLast1SOutage
      _secondsSinceLast2SOutage = source._secondsSinceLast2SOutage
      _secondsSinceLast5SOutage = source._secondsSinceLast5SOutage
      _secondsSinceLast15SOutage = source._secondsSinceLast15SOutage
      _secondsSinceLast60SOutage = source._secondsSinceLast60SOutage
      _disablementCode = source._disablementCode
      _kuMacActiveRatio = source._kuMacActiveRatio
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._deviceInfo) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._obstructionFraction) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._obstructionValidS) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._cellID) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._popRackID) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._secondsToSlotEnd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deviceState) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._initialSatelliteID) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._initialGatewayID) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._onBackupBeam) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._debugTelemetryEnabled) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._obstructionCurrent) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._popPingDropRate15SMean) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._popPingLatencyMs15SMean) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._secondsSinceLast1SOutage) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._secondsSinceLast2SOutage) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._secondsSinceLast5SOutage) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._secondsSinceLast15SOutage) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._secondsSinceLast60SOutage) }()
        case 20: try { try decoder.decodeSingularFloatField(value: &_storage._obstructionTime) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._disablementCode) }()
        case 22: try { try decoder.decodeSingularFloatField(value: &_storage._kuMacActiveRatio) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._deviceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._obstructionFraction.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._obstructionFraction, fieldNumber: 2)
      }
      if _storage._obstructionValidS.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._obstructionValidS, fieldNumber: 3)
      }
      if _storage._cellID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._cellID, fieldNumber: 4)
      }
      if _storage._popRackID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._popRackID, fieldNumber: 5)
      }
      if _storage._secondsToSlotEnd.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsToSlotEnd, fieldNumber: 6)
      }
      try { if let v = _storage._deviceState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._initialSatelliteID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._initialSatelliteID, fieldNumber: 8)
      }
      if _storage._initialGatewayID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._initialGatewayID, fieldNumber: 9)
      }
      if _storage._onBackupBeam != false {
        try visitor.visitSingularBoolField(value: _storage._onBackupBeam, fieldNumber: 10)
      }
      if _storage._debugTelemetryEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._debugTelemetryEnabled, fieldNumber: 11)
      }
      if _storage._obstructionCurrent != false {
        try visitor.visitSingularBoolField(value: _storage._obstructionCurrent, fieldNumber: 12)
      }
      if _storage._popPingDropRate15SMean.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._popPingDropRate15SMean, fieldNumber: 13)
      }
      if _storage._popPingLatencyMs15SMean.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._popPingLatencyMs15SMean, fieldNumber: 14)
      }
      if _storage._secondsSinceLast1SOutage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsSinceLast1SOutage, fieldNumber: 15)
      }
      if _storage._secondsSinceLast2SOutage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsSinceLast2SOutage, fieldNumber: 16)
      }
      if _storage._secondsSinceLast5SOutage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsSinceLast5SOutage, fieldNumber: 17)
      }
      if _storage._secondsSinceLast15SOutage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsSinceLast15SOutage, fieldNumber: 18)
      }
      if _storage._secondsSinceLast60SOutage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsSinceLast60SOutage, fieldNumber: 19)
      }
      if _storage._obstructionTime.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._obstructionTime, fieldNumber: 20)
      }
      if _storage._disablementCode != .unknownState {
        try visitor.visitSingularEnumField(value: _storage._disablementCode, fieldNumber: 21)
      }
      if _storage._kuMacActiveRatio.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._kuMacActiveRatio, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetContextResponse, rhs: SpaceX_API_Device_DishGetContextResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceInfo != rhs_storage._deviceInfo {return false}
        if _storage._deviceState != rhs_storage._deviceState {return false}
        if _storage._obstructionFraction != rhs_storage._obstructionFraction {return false}
        if _storage._obstructionTime != rhs_storage._obstructionTime {return false}
        if _storage._obstructionValidS != rhs_storage._obstructionValidS {return false}
        if _storage._obstructionCurrent != rhs_storage._obstructionCurrent {return false}
        if _storage._cellID != rhs_storage._cellID {return false}
        if _storage._popRackID != rhs_storage._popRackID {return false}
        if _storage._initialSatelliteID != rhs_storage._initialSatelliteID {return false}
        if _storage._initialGatewayID != rhs_storage._initialGatewayID {return false}
        if _storage._onBackupBeam != rhs_storage._onBackupBeam {return false}
        if _storage._secondsToSlotEnd != rhs_storage._secondsToSlotEnd {return false}
        if _storage._debugTelemetryEnabled != rhs_storage._debugTelemetryEnabled {return false}
        if _storage._popPingDropRate15SMean != rhs_storage._popPingDropRate15SMean {return false}
        if _storage._popPingLatencyMs15SMean != rhs_storage._popPingLatencyMs15SMean {return false}
        if _storage._secondsSinceLast1SOutage != rhs_storage._secondsSinceLast1SOutage {return false}
        if _storage._secondsSinceLast2SOutage != rhs_storage._secondsSinceLast2SOutage {return false}
        if _storage._secondsSinceLast5SOutage != rhs_storage._secondsSinceLast5SOutage {return false}
        if _storage._secondsSinceLast15SOutage != rhs_storage._secondsSinceLast15SOutage {return false}
        if _storage._secondsSinceLast60SOutage != rhs_storage._secondsSinceLast60SOutage {return false}
        if _storage._disablementCode != rhs_storage._disablementCode {return false}
        if _storage._kuMacActiveRatio != rhs_storage._kuMacActiveRatio {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishOutage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishOutage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cause"),
    2: .standard(proto: "start_timestamp_ns"),
    3: .standard(proto: "duration_ns"),
    4: .standard(proto: "did_switch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTimestampNs) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.durationNs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.didSwitch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cause != .unknown {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 1)
    }
    if self.startTimestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestampNs, fieldNumber: 2)
    }
    if self.durationNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationNs, fieldNumber: 3)
    }
    if self.didSwitch != false {
      try visitor.visitSingularBoolField(value: self.didSwitch, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishOutage, rhs: SpaceX_API_Device_DishOutage) -> Bool {
    if lhs.cause != rhs.cause {return false}
    if lhs.startTimestampNs != rhs.startTimestampNs {return false}
    if lhs.durationNs != rhs.durationNs {return false}
    if lhs.didSwitch != rhs.didSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishOutage.Cause: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BOOTING"),
    2: .same(proto: "STOWED"),
    3: .same(proto: "THERMAL_SHUTDOWN"),
    4: .same(proto: "NO_SCHEDULE"),
    5: .same(proto: "NO_SATS"),
    6: .same(proto: "OBSTRUCTED"),
    7: .same(proto: "NO_DOWNLINK"),
    8: .same(proto: "NO_PINGS"),
    9: .same(proto: "ACTUATOR_ACTIVITY"),
    10: .same(proto: "CABLE_TEST"),
    11: .same(proto: "SLEEPING"),
    12: .same(proto: "MOVING_WHILE_NOT_ALLOWED"),
  ]
}

extension SpaceX_API_Device_DishGetHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetHistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    1001: .standard(proto: "pop_ping_drop_rate"),
    1002: .standard(proto: "pop_ping_latency_ms"),
    1003: .standard(proto: "downlink_throughput_bps"),
    1004: .standard(proto: "uplink_throughput_bps"),
    1009: .same(proto: "outages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.current) }()
      case 1001: try { try decoder.decodeRepeatedFloatField(value: &self.popPingDropRate) }()
      case 1002: try { try decoder.decodeRepeatedFloatField(value: &self.popPingLatencyMs) }()
      case 1003: try { try decoder.decodeRepeatedFloatField(value: &self.downlinkThroughputBps) }()
      case 1004: try { try decoder.decodeRepeatedFloatField(value: &self.uplinkThroughputBps) }()
      case 1009: try { try decoder.decodeRepeatedMessageField(value: &self.outages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularUInt64Field(value: self.current, fieldNumber: 1)
    }
    if !self.popPingDropRate.isEmpty {
      try visitor.visitPackedFloatField(value: self.popPingDropRate, fieldNumber: 1001)
    }
    if !self.popPingLatencyMs.isEmpty {
      try visitor.visitPackedFloatField(value: self.popPingLatencyMs, fieldNumber: 1002)
    }
    if !self.downlinkThroughputBps.isEmpty {
      try visitor.visitPackedFloatField(value: self.downlinkThroughputBps, fieldNumber: 1003)
    }
    if !self.uplinkThroughputBps.isEmpty {
      try visitor.visitPackedFloatField(value: self.uplinkThroughputBps, fieldNumber: 1004)
    }
    if !self.outages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outages, fieldNumber: 1009)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetHistoryResponse, rhs: SpaceX_API_Device_DishGetHistoryResponse) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.popPingDropRate != rhs.popPingDropRate {return false}
    if lhs.popPingLatencyMs != rhs.popPingLatencyMs {return false}
    if lhs.downlinkThroughputBps != rhs.downlinkThroughputBps {return false}
    if lhs.uplinkThroughputBps != rhs.uplinkThroughputBps {return false}
    if lhs.outages != rhs.outages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_info"),
    2: .standard(proto: "device_state"),
    1005: .same(proto: "alerts"),
    1014: .same(proto: "outage"),
    1015: .standard(proto: "gps_stats"),
    1002: .standard(proto: "seconds_to_first_nonempty_slot"),
    1003: .standard(proto: "pop_ping_drop_rate"),
    1007: .standard(proto: "downlink_throughput_bps"),
    1008: .standard(proto: "uplink_throughput_bps"),
    1009: .standard(proto: "pop_ping_latency_ms"),
    1004: .standard(proto: "obstruction_stats"),
    1010: .standard(proto: "stow_requested"),
    1011: .standard(proto: "boresight_azimuth_deg"),
    1012: .standard(proto: "boresight_elevation_deg"),
    1016: .standard(proto: "eth_speed_mbps"),
    1017: .standard(proto: "mobility_class"),
    1018: .standard(proto: "is_snr_above_noise_floor"),
    1019: .standard(proto: "ready_states"),
    1020: .standard(proto: "class_of_service"),
    1021: .standard(proto: "software_update_state"),
    1030: .standard(proto: "swupdate_reboot_ready"),
    1026: .standard(proto: "software_update_stats"),
    1027: .standard(proto: "alignment_stats"),
    1022: .standard(proto: "is_snr_persistently_low"),
    1023: .standard(proto: "has_actuators"),
    1024: .standard(proto: "disablement_code"),
    1025: .standard(proto: "has_signed_cals"),
    2000: .same(proto: "config"),
    1028: .standard(proto: "initialization_duration_seconds"),
    1029: .standard(proto: "is_cell_disabled"),
    1031: .standard(proto: "seconds_until_swupdate_reboot_possible"),
    1040: .standard(proto: "connected_routers"),
  ]

  fileprivate class _StorageClass {
    var _deviceInfo: SpaceX_API_Device_DeviceInfo? = nil
    var _deviceState: SpaceX_API_Device_DeviceState? = nil
    var _alerts: SpaceX_API_Device_DishAlerts? = nil
    var _outage: SpaceX_API_Device_DishOutage? = nil
    var _gpsStats: SpaceX_API_Device_DishGpsStats? = nil
    var _secondsToFirstNonemptySlot: Float = 0
    var _popPingDropRate: Float = 0
    var _downlinkThroughputBps: Float = 0
    var _uplinkThroughputBps: Float = 0
    var _popPingLatencyMs: Float = 0
    var _obstructionStats: SpaceX_API_Device_DishObstructionStats? = nil
    var _stowRequested: Bool = false
    var _boresightAzimuthDeg: Float = 0
    var _boresightElevationDeg: Float = 0
    var _ethSpeedMbps: Int32 = 0
    var _mobilityClass: SpaceX_API_Device_UserMobilityClass = .stationary
    var _isSnrAboveNoiseFloor: Bool = false
    var _readyStates: SpaceX_API_Device_DishReadyStates? = nil
    var _classOfService: SpaceX_API_Device_UserClassOfService = .unknownUserClassOfService
    var _softwareUpdateState: SpaceX_API_Device_SoftwareUpdateState = .unknown
    var _swupdateRebootReady: Bool = false
    var _softwareUpdateStats: SpaceX_API_Device_SoftwareUpdateStats? = nil
    var _alignmentStats: SpaceX_API_Device_AlignmentStats? = nil
    var _isSnrPersistentlyLow: Bool = false
    var _hasActuators_p: SpaceX_API_Device_HasActuators = .unknown
    var _disablementCode: SpaceX_API_Satellites_Network_UtDisablementCode = .unknownState
    var _hasSignedCals_p: Bool = false
    var _config: SpaceX_API_Device_DishConfig? = nil
    var _initializationDurationSeconds: SpaceX_API_Device_InitializationDurationSeconds? = nil
    var _isCellDisabled: Bool = false
    var _secondsUntilSwupdateRebootPossible: Int32 = 0
    var _connectedRouters: [String] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _deviceInfo = source._deviceInfo
      _deviceState = source._deviceState
      _alerts = source._alerts
      _outage = source._outage
      _gpsStats = source._gpsStats
      _secondsToFirstNonemptySlot = source._secondsToFirstNonemptySlot
      _popPingDropRate = source._popPingDropRate
      _downlinkThroughputBps = source._downlinkThroughputBps
      _uplinkThroughputBps = source._uplinkThroughputBps
      _popPingLatencyMs = source._popPingLatencyMs
      _obstructionStats = source._obstructionStats
      _stowRequested = source._stowRequested
      _boresightAzimuthDeg = source._boresightAzimuthDeg
      _boresightElevationDeg = source._boresightElevationDeg
      _ethSpeedMbps = source._ethSpeedMbps
      _mobilityClass = source._mobilityClass
      _isSnrAboveNoiseFloor = source._isSnrAboveNoiseFloor
      _readyStates = source._readyStates
      _classOfService = source._classOfService
      _softwareUpdateState = source._softwareUpdateState
      _swupdateRebootReady = source._swupdateRebootReady
      _softwareUpdateStats = source._softwareUpdateStats
      _alignmentStats = source._alignmentStats
      _isSnrPersistentlyLow = source._isSnrPersistentlyLow
      _hasActuators_p = source._hasActuators_p
      _disablementCode = source._disablementCode
      _hasSignedCals_p = source._hasSignedCals_p
      _config = source._config
      _initializationDurationSeconds = source._initializationDurationSeconds
      _isCellDisabled = source._isCellDisabled
      _secondsUntilSwupdateRebootPossible = source._secondsUntilSwupdateRebootPossible
      _connectedRouters = source._connectedRouters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._deviceInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._deviceState) }()
        case 1002: try { try decoder.decodeSingularFloatField(value: &_storage._secondsToFirstNonemptySlot) }()
        case 1003: try { try decoder.decodeSingularFloatField(value: &_storage._popPingDropRate) }()
        case 1004: try { try decoder.decodeSingularMessageField(value: &_storage._obstructionStats) }()
        case 1005: try { try decoder.decodeSingularMessageField(value: &_storage._alerts) }()
        case 1007: try { try decoder.decodeSingularFloatField(value: &_storage._downlinkThroughputBps) }()
        case 1008: try { try decoder.decodeSingularFloatField(value: &_storage._uplinkThroughputBps) }()
        case 1009: try { try decoder.decodeSingularFloatField(value: &_storage._popPingLatencyMs) }()
        case 1010: try { try decoder.decodeSingularBoolField(value: &_storage._stowRequested) }()
        case 1011: try { try decoder.decodeSingularFloatField(value: &_storage._boresightAzimuthDeg) }()
        case 1012: try { try decoder.decodeSingularFloatField(value: &_storage._boresightElevationDeg) }()
        case 1014: try { try decoder.decodeSingularMessageField(value: &_storage._outage) }()
        case 1015: try { try decoder.decodeSingularMessageField(value: &_storage._gpsStats) }()
        case 1016: try { try decoder.decodeSingularInt32Field(value: &_storage._ethSpeedMbps) }()
        case 1017: try { try decoder.decodeSingularEnumField(value: &_storage._mobilityClass) }()
        case 1018: try { try decoder.decodeSingularBoolField(value: &_storage._isSnrAboveNoiseFloor) }()
        case 1019: try { try decoder.decodeSingularMessageField(value: &_storage._readyStates) }()
        case 1020: try { try decoder.decodeSingularEnumField(value: &_storage._classOfService) }()
        case 1021: try { try decoder.decodeSingularEnumField(value: &_storage._softwareUpdateState) }()
        case 1022: try { try decoder.decodeSingularBoolField(value: &_storage._isSnrPersistentlyLow) }()
        case 1023: try { try decoder.decodeSingularEnumField(value: &_storage._hasActuators_p) }()
        case 1024: try { try decoder.decodeSingularEnumField(value: &_storage._disablementCode) }()
        case 1025: try { try decoder.decodeSingularBoolField(value: &_storage._hasSignedCals_p) }()
        case 1026: try { try decoder.decodeSingularMessageField(value: &_storage._softwareUpdateStats) }()
        case 1027: try { try decoder.decodeSingularMessageField(value: &_storage._alignmentStats) }()
        case 1028: try { try decoder.decodeSingularMessageField(value: &_storage._initializationDurationSeconds) }()
        case 1029: try { try decoder.decodeSingularBoolField(value: &_storage._isCellDisabled) }()
        case 1030: try { try decoder.decodeSingularBoolField(value: &_storage._swupdateRebootReady) }()
        case 1031: try { try decoder.decodeSingularInt32Field(value: &_storage._secondsUntilSwupdateRebootPossible) }()
        case 1040: try { try decoder.decodeRepeatedStringField(value: &_storage._connectedRouters) }()
        case 2000: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._deviceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._deviceState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._secondsToFirstNonemptySlot.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._secondsToFirstNonemptySlot, fieldNumber: 1002)
      }
      if _storage._popPingDropRate.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._popPingDropRate, fieldNumber: 1003)
      }
      try { if let v = _storage._obstructionStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1004)
      } }()
      try { if let v = _storage._alerts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1005)
      } }()
      if _storage._downlinkThroughputBps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downlinkThroughputBps, fieldNumber: 1007)
      }
      if _storage._uplinkThroughputBps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uplinkThroughputBps, fieldNumber: 1008)
      }
      if _storage._popPingLatencyMs.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._popPingLatencyMs, fieldNumber: 1009)
      }
      if _storage._stowRequested != false {
        try visitor.visitSingularBoolField(value: _storage._stowRequested, fieldNumber: 1010)
      }
      if _storage._boresightAzimuthDeg.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._boresightAzimuthDeg, fieldNumber: 1011)
      }
      if _storage._boresightElevationDeg.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._boresightElevationDeg, fieldNumber: 1012)
      }
      try { if let v = _storage._outage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1014)
      } }()
      try { if let v = _storage._gpsStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1015)
      } }()
      if _storage._ethSpeedMbps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ethSpeedMbps, fieldNumber: 1016)
      }
      if _storage._mobilityClass != .stationary {
        try visitor.visitSingularEnumField(value: _storage._mobilityClass, fieldNumber: 1017)
      }
      if _storage._isSnrAboveNoiseFloor != false {
        try visitor.visitSingularBoolField(value: _storage._isSnrAboveNoiseFloor, fieldNumber: 1018)
      }
      try { if let v = _storage._readyStates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1019)
      } }()
      if _storage._classOfService != .unknownUserClassOfService {
        try visitor.visitSingularEnumField(value: _storage._classOfService, fieldNumber: 1020)
      }
      if _storage._softwareUpdateState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._softwareUpdateState, fieldNumber: 1021)
      }
      if _storage._isSnrPersistentlyLow != false {
        try visitor.visitSingularBoolField(value: _storage._isSnrPersistentlyLow, fieldNumber: 1022)
      }
      if _storage._hasActuators_p != .unknown {
        try visitor.visitSingularEnumField(value: _storage._hasActuators_p, fieldNumber: 1023)
      }
      if _storage._disablementCode != .unknownState {
        try visitor.visitSingularEnumField(value: _storage._disablementCode, fieldNumber: 1024)
      }
      if _storage._hasSignedCals_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSignedCals_p, fieldNumber: 1025)
      }
      try { if let v = _storage._softwareUpdateStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1026)
      } }()
      try { if let v = _storage._alignmentStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1027)
      } }()
      try { if let v = _storage._initializationDurationSeconds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1028)
      } }()
      if _storage._isCellDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._isCellDisabled, fieldNumber: 1029)
      }
      if _storage._swupdateRebootReady != false {
        try visitor.visitSingularBoolField(value: _storage._swupdateRebootReady, fieldNumber: 1030)
      }
      if _storage._secondsUntilSwupdateRebootPossible != 0 {
        try visitor.visitSingularInt32Field(value: _storage._secondsUntilSwupdateRebootPossible, fieldNumber: 1031)
      }
      if !_storage._connectedRouters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._connectedRouters, fieldNumber: 1040)
      }
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2000)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetStatusResponse, rhs: SpaceX_API_Device_DishGetStatusResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceInfo != rhs_storage._deviceInfo {return false}
        if _storage._deviceState != rhs_storage._deviceState {return false}
        if _storage._alerts != rhs_storage._alerts {return false}
        if _storage._outage != rhs_storage._outage {return false}
        if _storage._gpsStats != rhs_storage._gpsStats {return false}
        if _storage._secondsToFirstNonemptySlot != rhs_storage._secondsToFirstNonemptySlot {return false}
        if _storage._popPingDropRate != rhs_storage._popPingDropRate {return false}
        if _storage._downlinkThroughputBps != rhs_storage._downlinkThroughputBps {return false}
        if _storage._uplinkThroughputBps != rhs_storage._uplinkThroughputBps {return false}
        if _storage._popPingLatencyMs != rhs_storage._popPingLatencyMs {return false}
        if _storage._obstructionStats != rhs_storage._obstructionStats {return false}
        if _storage._stowRequested != rhs_storage._stowRequested {return false}
        if _storage._boresightAzimuthDeg != rhs_storage._boresightAzimuthDeg {return false}
        if _storage._boresightElevationDeg != rhs_storage._boresightElevationDeg {return false}
        if _storage._ethSpeedMbps != rhs_storage._ethSpeedMbps {return false}
        if _storage._mobilityClass != rhs_storage._mobilityClass {return false}
        if _storage._isSnrAboveNoiseFloor != rhs_storage._isSnrAboveNoiseFloor {return false}
        if _storage._readyStates != rhs_storage._readyStates {return false}
        if _storage._classOfService != rhs_storage._classOfService {return false}
        if _storage._softwareUpdateState != rhs_storage._softwareUpdateState {return false}
        if _storage._swupdateRebootReady != rhs_storage._swupdateRebootReady {return false}
        if _storage._softwareUpdateStats != rhs_storage._softwareUpdateStats {return false}
        if _storage._alignmentStats != rhs_storage._alignmentStats {return false}
        if _storage._isSnrPersistentlyLow != rhs_storage._isSnrPersistentlyLow {return false}
        if _storage._hasActuators_p != rhs_storage._hasActuators_p {return false}
        if _storage._disablementCode != rhs_storage._disablementCode {return false}
        if _storage._hasSignedCals_p != rhs_storage._hasSignedCals_p {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._initializationDurationSeconds != rhs_storage._initializationDurationSeconds {return false}
        if _storage._isCellDisabled != rhs_storage._isCellDisabled {return false}
        if _storage._secondsUntilSwupdateRebootPossible != rhs_storage._secondsUntilSwupdateRebootPossible {return false}
        if _storage._connectedRouters != rhs_storage._connectedRouters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetObstructionMapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetObstructionMapRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetObstructionMapRequest, rhs: SpaceX_API_Device_DishGetObstructionMapRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetObstructionMapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetObstructionMapResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_rows"),
    2: .standard(proto: "num_cols"),
    3: .same(proto: "snr"),
    4: .standard(proto: "min_elevation_deg"),
    5: .standard(proto: "max_theta_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numRows) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numCols) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.snr) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.minElevationDeg) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.maxThetaDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numRows != 0 {
      try visitor.visitSingularUInt32Field(value: self.numRows, fieldNumber: 1)
    }
    if self.numCols != 0 {
      try visitor.visitSingularUInt32Field(value: self.numCols, fieldNumber: 2)
    }
    if !self.snr.isEmpty {
      try visitor.visitPackedFloatField(value: self.snr, fieldNumber: 3)
    }
    if self.minElevationDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.minElevationDeg, fieldNumber: 4)
    }
    if self.maxThetaDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxThetaDeg, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetObstructionMapResponse, rhs: SpaceX_API_Device_DishGetObstructionMapResponse) -> Bool {
    if lhs.numRows != rhs.numRows {return false}
    if lhs.numCols != rhs.numCols {return false}
    if lhs.snr != rhs.snr {return false}
    if lhs.minElevationDeg != rhs.minElevationDeg {return false}
    if lhs.maxThetaDeg != rhs.maxThetaDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishAlerts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishAlerts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "motors_stuck"),
    3: .standard(proto: "thermal_throttle"),
    2: .standard(proto: "thermal_shutdown"),
    5: .standard(proto: "mast_not_near_vertical"),
    4: .standard(proto: "unexpected_location"),
    6: .standard(proto: "slow_ethernet_speeds"),
    18: .standard(proto: "slow_ethernet_speeds_100"),
    7: .same(proto: "roaming"),
    8: .standard(proto: "install_pending"),
    9: .standard(proto: "is_heating"),
    10: .standard(proto: "power_supply_thermal_throttle"),
    11: .standard(proto: "is_power_save_idle"),
    12: .standard(proto: "moving_while_not_mobile"),
    15: .standard(proto: "moving_too_fast_for_policy"),
    14: .standard(proto: "dbf_telem_stale"),
    16: .standard(proto: "low_motor_current"),
    17: .standard(proto: "lower_signal_than_predicted"),
  ]

  fileprivate class _StorageClass {
    var _motorsStuck: Bool = false
    var _thermalThrottle: Bool = false
    var _thermalShutdown: Bool = false
    var _mastNotNearVertical: Bool = false
    var _unexpectedLocation: Bool = false
    var _slowEthernetSpeeds: Bool = false
    var _slowEthernetSpeeds100: Bool = false
    var _roaming: Bool = false
    var _installPending: Bool = false
    var _isHeating: Bool = false
    var _powerSupplyThermalThrottle: Bool = false
    var _isPowerSaveIdle: Bool = false
    var _movingWhileNotMobile: Bool = false
    var _movingTooFastForPolicy: Bool = false
    var _dbfTelemStale: Bool = false
    var _lowMotorCurrent: Bool = false
    var _lowerSignalThanPredicted: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _motorsStuck = source._motorsStuck
      _thermalThrottle = source._thermalThrottle
      _thermalShutdown = source._thermalShutdown
      _mastNotNearVertical = source._mastNotNearVertical
      _unexpectedLocation = source._unexpectedLocation
      _slowEthernetSpeeds = source._slowEthernetSpeeds
      _slowEthernetSpeeds100 = source._slowEthernetSpeeds100
      _roaming = source._roaming
      _installPending = source._installPending
      _isHeating = source._isHeating
      _powerSupplyThermalThrottle = source._powerSupplyThermalThrottle
      _isPowerSaveIdle = source._isPowerSaveIdle
      _movingWhileNotMobile = source._movingWhileNotMobile
      _movingTooFastForPolicy = source._movingTooFastForPolicy
      _dbfTelemStale = source._dbfTelemStale
      _lowMotorCurrent = source._lowMotorCurrent
      _lowerSignalThanPredicted = source._lowerSignalThanPredicted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._motorsStuck) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._thermalShutdown) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._thermalThrottle) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._unexpectedLocation) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._mastNotNearVertical) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._slowEthernetSpeeds) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._roaming) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._installPending) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isHeating) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._powerSupplyThermalThrottle) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._isPowerSaveIdle) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._movingWhileNotMobile) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._dbfTelemStale) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._movingTooFastForPolicy) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._lowMotorCurrent) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._lowerSignalThanPredicted) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._slowEthernetSpeeds100) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._motorsStuck != false {
        try visitor.visitSingularBoolField(value: _storage._motorsStuck, fieldNumber: 1)
      }
      if _storage._thermalShutdown != false {
        try visitor.visitSingularBoolField(value: _storage._thermalShutdown, fieldNumber: 2)
      }
      if _storage._thermalThrottle != false {
        try visitor.visitSingularBoolField(value: _storage._thermalThrottle, fieldNumber: 3)
      }
      if _storage._unexpectedLocation != false {
        try visitor.visitSingularBoolField(value: _storage._unexpectedLocation, fieldNumber: 4)
      }
      if _storage._mastNotNearVertical != false {
        try visitor.visitSingularBoolField(value: _storage._mastNotNearVertical, fieldNumber: 5)
      }
      if _storage._slowEthernetSpeeds != false {
        try visitor.visitSingularBoolField(value: _storage._slowEthernetSpeeds, fieldNumber: 6)
      }
      if _storage._roaming != false {
        try visitor.visitSingularBoolField(value: _storage._roaming, fieldNumber: 7)
      }
      if _storage._installPending != false {
        try visitor.visitSingularBoolField(value: _storage._installPending, fieldNumber: 8)
      }
      if _storage._isHeating != false {
        try visitor.visitSingularBoolField(value: _storage._isHeating, fieldNumber: 9)
      }
      if _storage._powerSupplyThermalThrottle != false {
        try visitor.visitSingularBoolField(value: _storage._powerSupplyThermalThrottle, fieldNumber: 10)
      }
      if _storage._isPowerSaveIdle != false {
        try visitor.visitSingularBoolField(value: _storage._isPowerSaveIdle, fieldNumber: 11)
      }
      if _storage._movingWhileNotMobile != false {
        try visitor.visitSingularBoolField(value: _storage._movingWhileNotMobile, fieldNumber: 12)
      }
      if _storage._dbfTelemStale != false {
        try visitor.visitSingularBoolField(value: _storage._dbfTelemStale, fieldNumber: 14)
      }
      if _storage._movingTooFastForPolicy != false {
        try visitor.visitSingularBoolField(value: _storage._movingTooFastForPolicy, fieldNumber: 15)
      }
      if _storage._lowMotorCurrent != false {
        try visitor.visitSingularBoolField(value: _storage._lowMotorCurrent, fieldNumber: 16)
      }
      if _storage._lowerSignalThanPredicted != false {
        try visitor.visitSingularBoolField(value: _storage._lowerSignalThanPredicted, fieldNumber: 17)
      }
      if _storage._slowEthernetSpeeds100 != false {
        try visitor.visitSingularBoolField(value: _storage._slowEthernetSpeeds100, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishAlerts, rhs: SpaceX_API_Device_DishAlerts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._motorsStuck != rhs_storage._motorsStuck {return false}
        if _storage._thermalThrottle != rhs_storage._thermalThrottle {return false}
        if _storage._thermalShutdown != rhs_storage._thermalShutdown {return false}
        if _storage._mastNotNearVertical != rhs_storage._mastNotNearVertical {return false}
        if _storage._unexpectedLocation != rhs_storage._unexpectedLocation {return false}
        if _storage._slowEthernetSpeeds != rhs_storage._slowEthernetSpeeds {return false}
        if _storage._slowEthernetSpeeds100 != rhs_storage._slowEthernetSpeeds100 {return false}
        if _storage._roaming != rhs_storage._roaming {return false}
        if _storage._installPending != rhs_storage._installPending {return false}
        if _storage._isHeating != rhs_storage._isHeating {return false}
        if _storage._powerSupplyThermalThrottle != rhs_storage._powerSupplyThermalThrottle {return false}
        if _storage._isPowerSaveIdle != rhs_storage._isPowerSaveIdle {return false}
        if _storage._movingWhileNotMobile != rhs_storage._movingWhileNotMobile {return false}
        if _storage._movingTooFastForPolicy != rhs_storage._movingTooFastForPolicy {return false}
        if _storage._dbfTelemStale != rhs_storage._dbfTelemStale {return false}
        if _storage._lowMotorCurrent != rhs_storage._lowMotorCurrent {return false}
        if _storage._lowerSignalThanPredicted != rhs_storage._lowerSignalThanPredicted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishReadyStates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishReadyStates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cady"),
    2: .same(proto: "scp"),
    3: .same(proto: "l1l2"),
    4: .same(proto: "xphy"),
    5: .same(proto: "aap"),
    6: .same(proto: "rf"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cady) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.scp) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.l1L2) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.xphy) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.aap) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.rf) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cady != false {
      try visitor.visitSingularBoolField(value: self.cady, fieldNumber: 1)
    }
    if self.scp != false {
      try visitor.visitSingularBoolField(value: self.scp, fieldNumber: 2)
    }
    if self.l1L2 != false {
      try visitor.visitSingularBoolField(value: self.l1L2, fieldNumber: 3)
    }
    if self.xphy != false {
      try visitor.visitSingularBoolField(value: self.xphy, fieldNumber: 4)
    }
    if self.aap != false {
      try visitor.visitSingularBoolField(value: self.aap, fieldNumber: 5)
    }
    if self.rf != false {
      try visitor.visitSingularBoolField(value: self.rf, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishReadyStates, rhs: SpaceX_API_Device_DishReadyStates) -> Bool {
    if lhs.cady != rhs.cady {return false}
    if lhs.scp != rhs.scp {return false}
    if lhs.l1L2 != rhs.l1L2 {return false}
    if lhs.xphy != rhs.xphy {return false}
    if lhs.aap != rhs.aap {return false}
    if lhs.rf != rhs.rf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGpsStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGpsStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gps_valid"),
    2: .standard(proto: "gps_sats"),
    3: .standard(proto: "no_sats_after_ttff"),
    4: .standard(proto: "inhibit_gps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.gpsValid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.gpsSats) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.noSatsAfterTtff) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.inhibitGps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gpsValid != false {
      try visitor.visitSingularBoolField(value: self.gpsValid, fieldNumber: 1)
    }
    if self.gpsSats != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsSats, fieldNumber: 2)
    }
    if self.noSatsAfterTtff != false {
      try visitor.visitSingularBoolField(value: self.noSatsAfterTtff, fieldNumber: 3)
    }
    if self.inhibitGps != false {
      try visitor.visitSingularBoolField(value: self.inhibitGps, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGpsStats, rhs: SpaceX_API_Device_DishGpsStats) -> Bool {
    if lhs.gpsValid != rhs.gpsValid {return false}
    if lhs.gpsSats != rhs.gpsSats {return false}
    if lhs.noSatsAfterTtff != rhs.noSatsAfterTtff {return false}
    if lhs.inhibitGps != rhs.inhibitGps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SoftwareUpdateStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SoftwareUpdateStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "software_update_state"),
    2: .standard(proto: "software_update_progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.softwareUpdateState) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.softwareUpdateProgress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.softwareUpdateState != .unknown {
      try visitor.visitSingularEnumField(value: self.softwareUpdateState, fieldNumber: 1)
    }
    if self.softwareUpdateProgress.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.softwareUpdateProgress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SoftwareUpdateStats, rhs: SpaceX_API_Device_SoftwareUpdateStats) -> Bool {
    if lhs.softwareUpdateState != rhs.softwareUpdateState {return false}
    if lhs.softwareUpdateProgress != rhs.softwareUpdateProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_AlignmentStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlignmentStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_actuators"),
    2: .standard(proto: "actuator_state"),
    3: .standard(proto: "tilt_angle_deg"),
    4: .standard(proto: "boresight_azimuth_deg"),
    5: .standard(proto: "boresight_elevation_deg"),
    8: .standard(proto: "desired_boresight_azimuth_deg"),
    9: .standard(proto: "desired_boresight_elevation_deg"),
    6: .standard(proto: "attitude_estimation_state"),
    7: .standard(proto: "attitude_uncertainty_deg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hasActuators_p) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.actuatorState) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.tiltAngleDeg) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.boresightAzimuthDeg) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.boresightElevationDeg) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.attitudeEstimationState) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.attitudeUncertaintyDeg) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.desiredBoresightAzimuthDeg) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.desiredBoresightElevationDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasActuators_p != .unknown {
      try visitor.visitSingularEnumField(value: self.hasActuators_p, fieldNumber: 1)
    }
    if self.actuatorState != .idle {
      try visitor.visitSingularEnumField(value: self.actuatorState, fieldNumber: 2)
    }
    if self.tiltAngleDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tiltAngleDeg, fieldNumber: 3)
    }
    if self.boresightAzimuthDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.boresightAzimuthDeg, fieldNumber: 4)
    }
    if self.boresightElevationDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.boresightElevationDeg, fieldNumber: 5)
    }
    if self.attitudeEstimationState != .filterReset {
      try visitor.visitSingularEnumField(value: self.attitudeEstimationState, fieldNumber: 6)
    }
    if self.attitudeUncertaintyDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.attitudeUncertaintyDeg, fieldNumber: 7)
    }
    if self.desiredBoresightAzimuthDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.desiredBoresightAzimuthDeg, fieldNumber: 8)
    }
    if self.desiredBoresightElevationDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.desiredBoresightElevationDeg, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_AlignmentStats, rhs: SpaceX_API_Device_AlignmentStats) -> Bool {
    if lhs.hasActuators_p != rhs.hasActuators_p {return false}
    if lhs.actuatorState != rhs.actuatorState {return false}
    if lhs.tiltAngleDeg != rhs.tiltAngleDeg {return false}
    if lhs.boresightAzimuthDeg != rhs.boresightAzimuthDeg {return false}
    if lhs.boresightElevationDeg != rhs.boresightElevationDeg {return false}
    if lhs.desiredBoresightAzimuthDeg != rhs.desiredBoresightAzimuthDeg {return false}
    if lhs.desiredBoresightElevationDeg != rhs.desiredBoresightElevationDeg {return false}
    if lhs.attitudeEstimationState != rhs.attitudeEstimationState {return false}
    if lhs.attitudeUncertaintyDeg != rhs.attitudeUncertaintyDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishObstructionStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishObstructionStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "currently_obstructed"),
    1: .standard(proto: "fraction_obstructed"),
    9: .standard(proto: "time_obstructed"),
    4: .standard(proto: "valid_s"),
    10: .standard(proto: "patches_valid"),
    6: .standard(proto: "avg_prolonged_obstruction_duration_s"),
    7: .standard(proto: "avg_prolonged_obstruction_interval_s"),
    8: .standard(proto: "avg_prolonged_obstruction_valid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.fractionObstructed) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.validS) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.currentlyObstructed) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.avgProlongedObstructionDurationS) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.avgProlongedObstructionIntervalS) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.avgProlongedObstructionValid) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.timeObstructed) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.patchesValid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fractionObstructed.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.fractionObstructed, fieldNumber: 1)
    }
    if self.validS.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.validS, fieldNumber: 4)
    }
    if self.currentlyObstructed != false {
      try visitor.visitSingularBoolField(value: self.currentlyObstructed, fieldNumber: 5)
    }
    if self.avgProlongedObstructionDurationS.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.avgProlongedObstructionDurationS, fieldNumber: 6)
    }
    if self.avgProlongedObstructionIntervalS.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.avgProlongedObstructionIntervalS, fieldNumber: 7)
    }
    if self.avgProlongedObstructionValid != false {
      try visitor.visitSingularBoolField(value: self.avgProlongedObstructionValid, fieldNumber: 8)
    }
    if self.timeObstructed.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.timeObstructed, fieldNumber: 9)
    }
    if self.patchesValid != 0 {
      try visitor.visitSingularUInt32Field(value: self.patchesValid, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishObstructionStats, rhs: SpaceX_API_Device_DishObstructionStats) -> Bool {
    if lhs.currentlyObstructed != rhs.currentlyObstructed {return false}
    if lhs.fractionObstructed != rhs.fractionObstructed {return false}
    if lhs.timeObstructed != rhs.timeObstructed {return false}
    if lhs.validS != rhs.validS {return false}
    if lhs.patchesValid != rhs.patchesValid {return false}
    if lhs.avgProlongedObstructionDurationS != rhs.avgProlongedObstructionDurationS {return false}
    if lhs.avgProlongedObstructionIntervalS != rhs.avgProlongedObstructionIntervalS {return false}
    if lhs.avgProlongedObstructionValid != rhs.avgProlongedObstructionValid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_InitializationDurationSeconds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitializationDurationSeconds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attitude_initialization"),
    2: .standard(proto: "burst_detected"),
    3: .standard(proto: "ekf_converged"),
    4: .standard(proto: "first_cplane"),
    5: .standard(proto: "first_pop_ping"),
    6: .standard(proto: "gps_valid"),
    7: .standard(proto: "initial_network_entry"),
    8: .standard(proto: "network_schedule"),
    9: .standard(proto: "rf_ready"),
    10: .standard(proto: "stable_connection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.attitudeInitialization) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.burstDetected) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ekfConverged) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.firstCplane) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.firstPopPing) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.gpsValid) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.initialNetworkEntry) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.networkSchedule) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.rfReady) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.stableConnection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attitudeInitialization != 0 {
      try visitor.visitSingularInt32Field(value: self.attitudeInitialization, fieldNumber: 1)
    }
    if self.burstDetected != 0 {
      try visitor.visitSingularInt32Field(value: self.burstDetected, fieldNumber: 2)
    }
    if self.ekfConverged != 0 {
      try visitor.visitSingularInt32Field(value: self.ekfConverged, fieldNumber: 3)
    }
    if self.firstCplane != 0 {
      try visitor.visitSingularInt32Field(value: self.firstCplane, fieldNumber: 4)
    }
    if self.firstPopPing != 0 {
      try visitor.visitSingularInt32Field(value: self.firstPopPing, fieldNumber: 5)
    }
    if self.gpsValid != 0 {
      try visitor.visitSingularInt32Field(value: self.gpsValid, fieldNumber: 6)
    }
    if self.initialNetworkEntry != 0 {
      try visitor.visitSingularInt32Field(value: self.initialNetworkEntry, fieldNumber: 7)
    }
    if self.networkSchedule != 0 {
      try visitor.visitSingularInt32Field(value: self.networkSchedule, fieldNumber: 8)
    }
    if self.rfReady != 0 {
      try visitor.visitSingularInt32Field(value: self.rfReady, fieldNumber: 9)
    }
    if self.stableConnection != 0 {
      try visitor.visitSingularInt32Field(value: self.stableConnection, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_InitializationDurationSeconds, rhs: SpaceX_API_Device_InitializationDurationSeconds) -> Bool {
    if lhs.attitudeInitialization != rhs.attitudeInitialization {return false}
    if lhs.burstDetected != rhs.burstDetected {return false}
    if lhs.ekfConverged != rhs.ekfConverged {return false}
    if lhs.firstCplane != rhs.firstCplane {return false}
    if lhs.firstPopPing != rhs.firstPopPing {return false}
    if lhs.gpsValid != rhs.gpsValid {return false}
    if lhs.initialNetworkEntry != rhs.initialNetworkEntry {return false}
    if lhs.networkSchedule != rhs.networkSchedule {return false}
    if lhs.rfReady != rhs.rfReady {return false}
    if lhs.stableConnection != rhs.stableConnection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishAuthenticateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishAuthenticateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "dish"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dish) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dish {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishAuthenticateResponse, rhs: SpaceX_API_Device_DishAuthenticateResponse) -> Bool {
    if lhs._dish != rhs._dish {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SelfTestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfTestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "detailed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.detailed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.detailed != false {
      try visitor.visitSingularBoolField(value: self.detailed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SelfTestRequest, rhs: SpaceX_API_Device_SelfTestRequest) -> Bool {
    if lhs.detailed != rhs.detailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SelfTestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfTestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passed"),
    2: .same(proto: "report"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.passed) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.report) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.passed != false {
      try visitor.visitSingularBoolField(value: self.passed, fieldNumber: 1)
    }
    if !self.report.isEmpty {
      try visitor.visitSingularStringField(value: self.report, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SelfTestResponse, rhs: SpaceX_API_Device_SelfTestResponse) -> Bool {
    if lhs.passed != rhs.passed {return false}
    if lhs.report != rhs.report {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_StartDishSelfTestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartDishSelfTestRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_StartDishSelfTestRequest, rhs: SpaceX_API_Device_StartDishSelfTestRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_StartDishSelfTestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartDishSelfTestResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_StartDishSelfTestResponse, rhs: SpaceX_API_Device_StartDishSelfTestResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SetTestModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTestModeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rf_mode"),
    1001: .standard(proto: "disable_loss_of_comm_fdir"),
    1002: .standard(proto: "enable_rules_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.rfMode) }()
      case 1001: try { try decoder.decodeSingularBoolField(value: &self.disableLossOfCommFdir) }()
      case 1002: try { try decoder.decodeSingularBoolField(value: &self.enableRulesOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rfMode != .rx {
      try visitor.visitSingularEnumField(value: self.rfMode, fieldNumber: 1)
    }
    if self.disableLossOfCommFdir != false {
      try visitor.visitSingularBoolField(value: self.disableLossOfCommFdir, fieldNumber: 1001)
    }
    if self.enableRulesOverride != false {
      try visitor.visitSingularBoolField(value: self.enableRulesOverride, fieldNumber: 1002)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SetTestModeRequest, rhs: SpaceX_API_Device_SetTestModeRequest) -> Bool {
    if lhs.rfMode != rhs.rfMode {return false}
    if lhs.disableLossOfCommFdir != rhs.disableLossOfCommFdir {return false}
    if lhs.enableRulesOverride != rhs.enableRulesOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SetTestModeRequest.RfMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RX"),
    1: .same(proto: "IDLE"),
    2: .same(proto: "TX"),
    3: .same(proto: "CAL"),
    4: .same(proto: "USER"),
    420: .same(proto: "NORMAL"),
  ]
}

extension SpaceX_API_Device_SetTestModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTestModeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SetTestModeResponse, rhs: SpaceX_API_Device_SetTestModeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishSetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishSetConfigRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dish_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dishConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dishConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishSetConfigRequest, rhs: SpaceX_API_Device_DishSetConfigRequest) -> Bool {
    if lhs._dishConfig != rhs._dishConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishSetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishSetConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_dish_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updatedDishConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updatedDishConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishSetConfigResponse, rhs: SpaceX_API_Device_DishSetConfigResponse) -> Bool {
    if lhs._updatedDishConfig != rhs._updatedDishConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetConfigRequest, rhs: SpaceX_API_Device_DishGetConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dish_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dishConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dishConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetConfigResponse, rhs: SpaceX_API_Device_DishGetConfigResponse) -> Bool {
    if lhs._dishConfig != rhs._dishConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishInhibitGpsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishInhibitGpsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inhibit_gps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.inhibitGps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inhibitGps != false {
      try visitor.visitSingularBoolField(value: self.inhibitGps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishInhibitGpsRequest, rhs: SpaceX_API_Device_DishInhibitGpsRequest) -> Bool {
    if lhs.inhibitGps != rhs.inhibitGps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishInhibitGpsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishInhibitGpsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inhibit_gps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.inhibitGps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inhibitGps != false {
      try visitor.visitSingularBoolField(value: self.inhibitGps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishInhibitGpsResponse, rhs: SpaceX_API_Device_DishInhibitGpsResponse) -> Bool {
    if lhs.inhibitGps != rhs.inhibitGps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetDataRequest, rhs: SpaceX_API_Device_DishGetDataRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishClearObstructionMapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishClearObstructionMapRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishClearObstructionMapRequest, rhs: SpaceX_API_Device_DishClearObstructionMapRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishClearObstructionMapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishClearObstructionMapResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishClearObstructionMapResponse, rhs: SpaceX_API_Device_DishClearObstructionMapResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishActivateRssiScanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishActivateRssiScanRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scan_query"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scanQuery) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scanQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishActivateRssiScanRequest, rhs: SpaceX_API_Device_DishActivateRssiScanRequest) -> Bool {
    if lhs._scanQuery != rhs._scanQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishActivateRssiScanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishActivateRssiScanResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishActivateRssiScanResponse, rhs: SpaceX_API_Device_DishActivateRssiScanResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetRssiScanResultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetRssiScanResultRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetRssiScanResultRequest, rhs: SpaceX_API_Device_DishGetRssiScanResultRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetRssiScanResultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetRssiScanResultResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetRssiScanResultResponse, rhs: SpaceX_API_Device_DishGetRssiScanResultResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishFactoryResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishFactoryResetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishFactoryResetRequest, rhs: SpaceX_API_Device_DishFactoryResetRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishFactoryResetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishFactoryResetResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishFactoryResetResponse, rhs: SpaceX_API_Device_DishFactoryResetResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ResetButtonRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetButtonRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.pressed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressed != false {
      try visitor.visitSingularBoolField(value: self.pressed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ResetButtonRequest, rhs: SpaceX_API_Device_ResetButtonRequest) -> Bool {
    if lhs.pressed != rhs.pressed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ResetButtonResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetButtonResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ResetButtonResponse, rhs: SpaceX_API_Device_ResetButtonResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
