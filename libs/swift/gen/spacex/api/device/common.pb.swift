// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: spacex/api/device/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SpaceX_API_Device_BootReason: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case forgotten // = 1
  case powerCycle // = 2
  case command // = 3
  case softwareUpdate // = 4
  case configUpdate // = 5
  case uptimeFdir // = 6
  case repeaterFdir // = 7
  case aviationEthWanFdir // = 8
  case kernelPanic // = 9
  case intentionalKernelPanic // = 14
  case mcuBringupFailedFdir // = 11
  case aviationOutageFdir // = 12
  case softwareWatchdog // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .forgotten
    case 2: self = .powerCycle
    case 3: self = .command
    case 4: self = .softwareUpdate
    case 5: self = .configUpdate
    case 6: self = .uptimeFdir
    case 7: self = .repeaterFdir
    case 8: self = .aviationEthWanFdir
    case 9: self = .kernelPanic
    case 11: self = .mcuBringupFailedFdir
    case 12: self = .aviationOutageFdir
    case 13: self = .softwareWatchdog
    case 14: self = .intentionalKernelPanic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .forgotten: return 1
    case .powerCycle: return 2
    case .command: return 3
    case .softwareUpdate: return 4
    case .configUpdate: return 5
    case .uptimeFdir: return 6
    case .repeaterFdir: return 7
    case .aviationEthWanFdir: return 8
    case .kernelPanic: return 9
    case .mcuBringupFailedFdir: return 11
    case .aviationOutageFdir: return 12
    case .softwareWatchdog: return 13
    case .intentionalKernelPanic: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_BootReason] = [
    .unknown,
    .forgotten,
    .powerCycle,
    .command,
    .softwareUpdate,
    .configUpdate,
    .uptimeFdir,
    .repeaterFdir,
    .aviationEthWanFdir,
    .kernelPanic,
    .intentionalKernelPanic,
    .mcuBringupFailedFdir,
    .aviationOutageFdir,
    .softwareWatchdog,
  ]

}

struct SpaceX_API_Device_DeviceInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var hardwareVersion: String {
    get {return _storage._hardwareVersion}
    set {_uniqueStorage()._hardwareVersion = newValue}
  }

  var boardRev: Int32 {
    get {return _storage._boardRev}
    set {_uniqueStorage()._boardRev = newValue}
  }

  var softwareVersion: String {
    get {return _storage._softwareVersion}
    set {_uniqueStorage()._softwareVersion = newValue}
  }

  var manufacturedVersion: String {
    get {return _storage._manufacturedVersion}
    set {_uniqueStorage()._manufacturedVersion = newValue}
  }

  var generationNumber: Int64 {
    get {return _storage._generationNumber}
    set {_uniqueStorage()._generationNumber = newValue}
  }

  var countryCode: String {
    get {return _storage._countryCode}
    set {_uniqueStorage()._countryCode = newValue}
  }

  var utcOffsetS: Int32 {
    get {return _storage._utcOffsetS}
    set {_uniqueStorage()._utcOffsetS = newValue}
  }

  var softwarePartitionsEqual: Bool {
    get {return _storage._softwarePartitionsEqual}
    set {_uniqueStorage()._softwarePartitionsEqual = newValue}
  }

  var isDev: Bool {
    get {return _storage._isDev}
    set {_uniqueStorage()._isDev = newValue}
  }

  var bootcount: Int32 {
    get {return _storage._bootcount}
    set {_uniqueStorage()._bootcount = newValue}
  }

  var antiRollbackVersion: Int32 {
    get {return _storage._antiRollbackVersion}
    set {_uniqueStorage()._antiRollbackVersion = newValue}
  }

  var isHitl: Bool {
    get {return _storage._isHitl}
    set {_uniqueStorage()._isHitl = newValue}
  }

  var boot: SpaceX_API_Device_BootInfo {
    get {return _storage._boot ?? SpaceX_API_Device_BootInfo()}
    set {_uniqueStorage()._boot = newValue}
  }
  /// Returns true if `boot` has been explicitly set.
  var hasBoot: Bool {return _storage._boot != nil}
  /// Clears the value of `boot`. Subsequent reads from it will return its default value.
  mutating func clearBoot() {_uniqueStorage()._boot = nil}

  var dishCohoused: Bool {
    get {return _storage._dishCohoused}
    set {_uniqueStorage()._dishCohoused = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_DeviceState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uptimeS: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SignedData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetNextIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetNextIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var epochID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_BootInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countByReason: Dictionary<Int32,Int32> = [:]

  var countByReasonDelta: Dictionary<Int32,Int32> = [:]

  var lastReason: SpaceX_API_Device_BootReason = .unknown

  var lastCount: Int32 = 0

  var crashBoot: Bool = false

  var crashBootCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_PingTarget: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var service: String = String()

  var location: String = String()

  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_PingResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: SpaceX_API_Device_PingTarget {
    get {return _target ?? SpaceX_API_Device_PingTarget()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  var dropRate: Float = 0

  var latencyMs: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _target: SpaceX_API_Device_PingTarget? = nil
}

struct SpaceX_API_Device_BondingChallenge: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dishID: String = String()

  var wifiID: String = String()

  var nonce: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_AuthenticateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var challenge: SpaceX_API_Device_SignedData {
    get {return _challenge ?? SpaceX_API_Device_SignedData()}
    set {_challenge = newValue}
  }
  /// Returns true if `challenge` has been explicitly set.
  var hasChallenge: Bool {return self._challenge != nil}
  /// Clears the value of `challenge`. Subsequent reads from it will return its default value.
  mutating func clearChallenge() {self._challenge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _challenge: SpaceX_API_Device_SignedData? = nil
}

struct SpaceX_API_Device_ChallengeResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: Data = Data()

  var certificateChain: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_NetworkInterface: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var up: Bool {
    get {return _storage._up}
    set {_uniqueStorage()._up = newValue}
  }

  var macAddress: String {
    get {return _storage._macAddress}
    set {_uniqueStorage()._macAddress = newValue}
  }

  var ipv4Addresses: [String] {
    get {return _storage._ipv4Addresses}
    set {_uniqueStorage()._ipv4Addresses = newValue}
  }

  var ipv6Addresses: [String] {
    get {return _storage._ipv6Addresses}
    set {_uniqueStorage()._ipv6Addresses = newValue}
  }

  var rxStats: SpaceX_API_Device_NetworkInterface.RxStats {
    get {return _storage._rxStats ?? SpaceX_API_Device_NetworkInterface.RxStats()}
    set {_uniqueStorage()._rxStats = newValue}
  }
  /// Returns true if `rxStats` has been explicitly set.
  var hasRxStats: Bool {return _storage._rxStats != nil}
  /// Clears the value of `rxStats`. Subsequent reads from it will return its default value.
  mutating func clearRxStats() {_uniqueStorage()._rxStats = nil}

  var txStats: SpaceX_API_Device_NetworkInterface.TxStats {
    get {return _storage._txStats ?? SpaceX_API_Device_NetworkInterface.TxStats()}
    set {_uniqueStorage()._txStats = newValue}
  }
  /// Returns true if `txStats` has been explicitly set.
  var hasTxStats: Bool {return _storage._txStats != nil}
  /// Clears the value of `txStats`. Subsequent reads from it will return its default value.
  mutating func clearTxStats() {_uniqueStorage()._txStats = nil}

  var interface: OneOf_Interface? {
    get {return _storage._interface}
    set {_uniqueStorage()._interface = newValue}
  }

  var ethernet: SpaceX_API_Device_EthernetNetworkInterface {
    get {
      if case .ethernet(let v)? = _storage._interface {return v}
      return SpaceX_API_Device_EthernetNetworkInterface()
    }
    set {_uniqueStorage()._interface = .ethernet(newValue)}
  }

  var wifi: SpaceX_API_Device_WifiNetworkInterface {
    get {
      if case .wifi(let v)? = _storage._interface {return v}
      return SpaceX_API_Device_WifiNetworkInterface()
    }
    set {_uniqueStorage()._interface = .wifi(newValue)}
  }

  var bridge: SpaceX_API_Device_BridgeNetworkInterface {
    get {
      if case .bridge(let v)? = _storage._interface {return v}
      return SpaceX_API_Device_BridgeNetworkInterface()
    }
    set {_uniqueStorage()._interface = .bridge(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Interface: Equatable, Sendable {
    case ethernet(SpaceX_API_Device_EthernetNetworkInterface)
    case wifi(SpaceX_API_Device_WifiNetworkInterface)
    case bridge(SpaceX_API_Device_BridgeNetworkInterface)

  }

  struct RxStats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytes: UInt64 = 0

    var packets: UInt64 = 0

    var frameErrors: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TxStats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bytes: UInt64 = 0

    var packets: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_EthernetNetworkInterface: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var linkDetected: Bool = false

  var speedMbps: UInt32 = 0

  var autonegotiationOn: Bool = false

  var duplex: SpaceX_API_Device_EthernetNetworkInterface.Duplex = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Duplex: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case half // = 1
    case full // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .half
      case 2: self = .full
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .half: return 1
      case .full: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_EthernetNetworkInterface.Duplex] = [
      .unknown,
      .half,
      .full,
    ]

  }

  init() {}
}

struct SpaceX_API_Device_WifiNetworkInterface: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invalidPacketCounts: SpaceX_API_Device_WifiNetworkInterface.InvalidPacketCounts {
    get {return _invalidPacketCounts ?? SpaceX_API_Device_WifiNetworkInterface.InvalidPacketCounts()}
    set {_invalidPacketCounts = newValue}
  }
  /// Returns true if `invalidPacketCounts` has been explicitly set.
  var hasInvalidPacketCounts: Bool {return self._invalidPacketCounts != nil}
  /// Clears the value of `invalidPacketCounts`. Subsequent reads from it will return its default value.
  mutating func clearInvalidPacketCounts() {self._invalidPacketCounts = nil}

  var channel: UInt32 = 0

  var missedBeacons: UInt32 = 0

  var linkQuality: Double = 0

  var signalLevel: Double = 0

  var noiseLevel: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct InvalidPacketCounts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rxInvalidNwid: UInt32 = 0

    var rxInvalidCrypt: UInt32 = 0

    var rxInvalidFrag: UInt32 = 0

    var txExcessiveRetries: UInt32 = 0

    var invalidMisc: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _invalidPacketCounts: SpaceX_API_Device_WifiNetworkInterface.InvalidPacketCounts? = nil
}

struct SpaceX_API_Device_BridgeNetworkInterface: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var memberNames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_LLAPosition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lon: Double = 0

  var alt: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_ECEFPosition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var z: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_InitiateRemoteSshRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_InitiateRemoteSshResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var port: UInt32 = 0

  var address: String = String()

  var stsafe: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SoftwareUpdateRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamID: UInt64 = 0

  var data: Data = Data()

  var `open`: Bool = false

  var close: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SoftwareUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SpaceX.API.Device"

extension SpaceX_API_Device_BootReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOOT_REASON_UNKNOWN"),
    1: .same(proto: "FORGOTTEN"),
    2: .same(proto: "POWER_CYCLE"),
    3: .same(proto: "COMMAND"),
    4: .same(proto: "SOFTWARE_UPDATE"),
    5: .same(proto: "CONFIG_UPDATE"),
    6: .same(proto: "UPTIME_FDIR"),
    7: .same(proto: "REPEATER_FDIR"),
    8: .same(proto: "AVIATION_ETH_WAN_FDIR"),
    9: .same(proto: "KERNEL_PANIC"),
    11: .same(proto: "MCU_BRINGUP_FAILED_FDIR"),
    12: .same(proto: "AVIATION_OUTAGE_FDIR"),
    13: .same(proto: "SOFTWARE_WATCHDOG"),
    14: .same(proto: "INTENTIONAL_KERNEL_PANIC"),
  ]
}

extension SpaceX_API_Device_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "hardware_version"),
    14: .standard(proto: "board_rev"),
    3: .standard(proto: "software_version"),
    11: .standard(proto: "manufactured_version"),
    12: .standard(proto: "generation_number"),
    4: .standard(proto: "country_code"),
    5: .standard(proto: "utc_offset_s"),
    6: .standard(proto: "software_partitions_equal"),
    7: .standard(proto: "is_dev"),
    8: .same(proto: "bootcount"),
    9: .standard(proto: "anti_rollback_version"),
    10: .standard(proto: "is_hitl"),
    1001: .same(proto: "boot"),
    13: .standard(proto: "dish_cohoused"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _hardwareVersion: String = String()
    var _boardRev: Int32 = 0
    var _softwareVersion: String = String()
    var _manufacturedVersion: String = String()
    var _generationNumber: Int64 = 0
    var _countryCode: String = String()
    var _utcOffsetS: Int32 = 0
    var _softwarePartitionsEqual: Bool = false
    var _isDev: Bool = false
    var _bootcount: Int32 = 0
    var _antiRollbackVersion: Int32 = 0
    var _isHitl: Bool = false
    var _boot: SpaceX_API_Device_BootInfo? = nil
    var _dishCohoused: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _hardwareVersion = source._hardwareVersion
      _boardRev = source._boardRev
      _softwareVersion = source._softwareVersion
      _manufacturedVersion = source._manufacturedVersion
      _generationNumber = source._generationNumber
      _countryCode = source._countryCode
      _utcOffsetS = source._utcOffsetS
      _softwarePartitionsEqual = source._softwarePartitionsEqual
      _isDev = source._isDev
      _bootcount = source._bootcount
      _antiRollbackVersion = source._antiRollbackVersion
      _isHitl = source._isHitl
      _boot = source._boot
      _dishCohoused = source._dishCohoused
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._hardwareVersion) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._softwareVersion) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._countryCode) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._utcOffsetS) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._softwarePartitionsEqual) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isDev) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._bootcount) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._antiRollbackVersion) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isHitl) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._manufacturedVersion) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._generationNumber) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._dishCohoused) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._boardRev) }()
        case 1001: try { try decoder.decodeSingularMessageField(value: &_storage._boot) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._hardwareVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hardwareVersion, fieldNumber: 2)
      }
      if !_storage._softwareVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._softwareVersion, fieldNumber: 3)
      }
      if !_storage._countryCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._countryCode, fieldNumber: 4)
      }
      if _storage._utcOffsetS != 0 {
        try visitor.visitSingularInt32Field(value: _storage._utcOffsetS, fieldNumber: 5)
      }
      if _storage._softwarePartitionsEqual != false {
        try visitor.visitSingularBoolField(value: _storage._softwarePartitionsEqual, fieldNumber: 6)
      }
      if _storage._isDev != false {
        try visitor.visitSingularBoolField(value: _storage._isDev, fieldNumber: 7)
      }
      if _storage._bootcount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bootcount, fieldNumber: 8)
      }
      if _storage._antiRollbackVersion != 0 {
        try visitor.visitSingularInt32Field(value: _storage._antiRollbackVersion, fieldNumber: 9)
      }
      if _storage._isHitl != false {
        try visitor.visitSingularBoolField(value: _storage._isHitl, fieldNumber: 10)
      }
      if !_storage._manufacturedVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._manufacturedVersion, fieldNumber: 11)
      }
      if _storage._generationNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._generationNumber, fieldNumber: 12)
      }
      if _storage._dishCohoused != false {
        try visitor.visitSingularBoolField(value: _storage._dishCohoused, fieldNumber: 13)
      }
      if _storage._boardRev != 0 {
        try visitor.visitSingularInt32Field(value: _storage._boardRev, fieldNumber: 14)
      }
      try { if let v = _storage._boot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DeviceInfo, rhs: SpaceX_API_Device_DeviceInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._hardwareVersion != rhs_storage._hardwareVersion {return false}
        if _storage._boardRev != rhs_storage._boardRev {return false}
        if _storage._softwareVersion != rhs_storage._softwareVersion {return false}
        if _storage._manufacturedVersion != rhs_storage._manufacturedVersion {return false}
        if _storage._generationNumber != rhs_storage._generationNumber {return false}
        if _storage._countryCode != rhs_storage._countryCode {return false}
        if _storage._utcOffsetS != rhs_storage._utcOffsetS {return false}
        if _storage._softwarePartitionsEqual != rhs_storage._softwarePartitionsEqual {return false}
        if _storage._isDev != rhs_storage._isDev {return false}
        if _storage._bootcount != rhs_storage._bootcount {return false}
        if _storage._antiRollbackVersion != rhs_storage._antiRollbackVersion {return false}
        if _storage._isHitl != rhs_storage._isHitl {return false}
        if _storage._boot != rhs_storage._boot {return false}
        if _storage._dishCohoused != rhs_storage._dishCohoused {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DeviceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "uptime_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.uptimeS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uptimeS != 0 {
      try visitor.visitSingularUInt64Field(value: self.uptimeS, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DeviceState, rhs: SpaceX_API_Device_DeviceState) -> Bool {
    if lhs.uptimeS != rhs.uptimeS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SignedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SignedData, rhs: SpaceX_API_Device_SignedData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetNextIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNextIdRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetNextIdRequest, rhs: SpaceX_API_Device_GetNextIdRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetNextIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNextIdResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "epoch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.epochID != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetNextIdResponse, rhs: SpaceX_API_Device_GetNextIdResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.epochID != rhs.epochID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_BootInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BootInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "count_by_reason"),
    4: .standard(proto: "count_by_reason_delta"),
    2: .standard(proto: "last_reason"),
    3: .standard(proto: "last_count"),
    5: .standard(proto: "crash_boot"),
    6: .standard(proto: "crash_boot_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.countByReason) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.lastReason) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lastCount) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.countByReasonDelta) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.crashBoot) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.crashBootCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countByReason.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.countByReason, fieldNumber: 1)
    }
    if self.lastReason != .unknown {
      try visitor.visitSingularEnumField(value: self.lastReason, fieldNumber: 2)
    }
    if self.lastCount != 0 {
      try visitor.visitSingularInt32Field(value: self.lastCount, fieldNumber: 3)
    }
    if !self.countByReasonDelta.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.countByReasonDelta, fieldNumber: 4)
    }
    if self.crashBoot != false {
      try visitor.visitSingularBoolField(value: self.crashBoot, fieldNumber: 5)
    }
    if self.crashBootCount != 0 {
      try visitor.visitSingularInt32Field(value: self.crashBootCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_BootInfo, rhs: SpaceX_API_Device_BootInfo) -> Bool {
    if lhs.countByReason != rhs.countByReason {return false}
    if lhs.countByReasonDelta != rhs.countByReasonDelta {return false}
    if lhs.lastReason != rhs.lastReason {return false}
    if lhs.lastCount != rhs.lastCount {return false}
    if lhs.crashBoot != rhs.crashBoot {return false}
    if lhs.crashBootCount != rhs.crashBootCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_PingTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .same(proto: "location"),
    3: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_PingTarget, rhs: SpaceX_API_Device_PingTarget) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.location != rhs.location {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_PingResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "target"),
    1: .same(proto: "dropRate"),
    2: .same(proto: "latencyMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.dropRate) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.latencyMs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dropRate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.dropRate, fieldNumber: 1)
    }
    if self.latencyMs.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.latencyMs, fieldNumber: 2)
    }
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_PingResult, rhs: SpaceX_API_Device_PingResult) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs.dropRate != rhs.dropRate {return false}
    if lhs.latencyMs != rhs.latencyMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_BondingChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondingChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dish_id"),
    2: .standard(proto: "wifi_id"),
    3: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dishID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wifiID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dishID.isEmpty {
      try visitor.visitSingularStringField(value: self.dishID, fieldNumber: 1)
    }
    if !self.wifiID.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiID, fieldNumber: 2)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_BondingChallenge, rhs: SpaceX_API_Device_BondingChallenge) -> Bool {
    if lhs.dishID != rhs.dishID {return false}
    if lhs.wifiID != rhs.wifiID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_AuthenticateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._challenge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._challenge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_AuthenticateRequest, rhs: SpaceX_API_Device_AuthenticateRequest) -> Bool {
    if lhs._challenge != rhs._challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ChallengeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChallengeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "certificate_chain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.certificateChain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if !self.certificateChain.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificateChain, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ChallengeResponse, rhs: SpaceX_API_Device_ChallengeResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.certificateChain != rhs.certificateChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_NetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInterface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .same(proto: "up"),
    5: .standard(proto: "mac_address"),
    6: .standard(proto: "ipv4_addresses"),
    7: .standard(proto: "ipv6_addresses"),
    2: .standard(proto: "rx_stats"),
    3: .standard(proto: "tx_stats"),
    1000: .same(proto: "ethernet"),
    1001: .same(proto: "wifi"),
    1002: .same(proto: "bridge"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _up: Bool = false
    var _macAddress: String = String()
    var _ipv4Addresses: [String] = []
    var _ipv6Addresses: [String] = []
    var _rxStats: SpaceX_API_Device_NetworkInterface.RxStats? = nil
    var _txStats: SpaceX_API_Device_NetworkInterface.TxStats? = nil
    var _interface: SpaceX_API_Device_NetworkInterface.OneOf_Interface?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _up = source._up
      _macAddress = source._macAddress
      _ipv4Addresses = source._ipv4Addresses
      _ipv6Addresses = source._ipv6Addresses
      _rxStats = source._rxStats
      _txStats = source._txStats
      _interface = source._interface
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rxStats) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._txStats) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._up) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._macAddress) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._ipv4Addresses) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._ipv6Addresses) }()
        case 1000: try {
          var v: SpaceX_API_Device_EthernetNetworkInterface?
          var hadOneofValue = false
          if let current = _storage._interface {
            hadOneofValue = true
            if case .ethernet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._interface = .ethernet(v)
          }
        }()
        case 1001: try {
          var v: SpaceX_API_Device_WifiNetworkInterface?
          var hadOneofValue = false
          if let current = _storage._interface {
            hadOneofValue = true
            if case .wifi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._interface = .wifi(v)
          }
        }()
        case 1002: try {
          var v: SpaceX_API_Device_BridgeNetworkInterface?
          var hadOneofValue = false
          if let current = _storage._interface {
            hadOneofValue = true
            if case .bridge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._interface = .bridge(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._rxStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._txStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._up != false {
        try visitor.visitSingularBoolField(value: _storage._up, fieldNumber: 4)
      }
      if !_storage._macAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._macAddress, fieldNumber: 5)
      }
      if !_storage._ipv4Addresses.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ipv4Addresses, fieldNumber: 6)
      }
      if !_storage._ipv6Addresses.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ipv6Addresses, fieldNumber: 7)
      }
      switch _storage._interface {
      case .ethernet?: try {
        guard case .ethernet(let v)? = _storage._interface else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
      }()
      case .wifi?: try {
        guard case .wifi(let v)? = _storage._interface else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }()
      case .bridge?: try {
        guard case .bridge(let v)? = _storage._interface else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1002)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_NetworkInterface, rhs: SpaceX_API_Device_NetworkInterface) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._up != rhs_storage._up {return false}
        if _storage._macAddress != rhs_storage._macAddress {return false}
        if _storage._ipv4Addresses != rhs_storage._ipv4Addresses {return false}
        if _storage._ipv6Addresses != rhs_storage._ipv6Addresses {return false}
        if _storage._rxStats != rhs_storage._rxStats {return false}
        if _storage._txStats != rhs_storage._txStats {return false}
        if _storage._interface != rhs_storage._interface {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_NetworkInterface.RxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_NetworkInterface.protoMessageName + ".RxStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
    2: .same(proto: "packets"),
    3: .standard(proto: "frame_errors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bytes) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.packets) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.frameErrors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytes, fieldNumber: 1)
    }
    if self.packets != 0 {
      try visitor.visitSingularUInt64Field(value: self.packets, fieldNumber: 2)
    }
    if self.frameErrors != 0 {
      try visitor.visitSingularUInt64Field(value: self.frameErrors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_NetworkInterface.RxStats, rhs: SpaceX_API_Device_NetworkInterface.RxStats) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.packets != rhs.packets {return false}
    if lhs.frameErrors != rhs.frameErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_NetworkInterface.TxStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_NetworkInterface.protoMessageName + ".TxStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
    2: .same(proto: "packets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bytes) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.packets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytes, fieldNumber: 1)
    }
    if self.packets != 0 {
      try visitor.visitSingularUInt64Field(value: self.packets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_NetworkInterface.TxStats, rhs: SpaceX_API_Device_NetworkInterface.TxStats) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.packets != rhs.packets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_EthernetNetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EthernetNetworkInterface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "link_detected"),
    2: .standard(proto: "speed_mbps"),
    3: .standard(proto: "autonegotiation_on"),
    4: .same(proto: "duplex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.linkDetected) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.speedMbps) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.autonegotiationOn) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.duplex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.linkDetected != false {
      try visitor.visitSingularBoolField(value: self.linkDetected, fieldNumber: 1)
    }
    if self.speedMbps != 0 {
      try visitor.visitSingularUInt32Field(value: self.speedMbps, fieldNumber: 2)
    }
    if self.autonegotiationOn != false {
      try visitor.visitSingularBoolField(value: self.autonegotiationOn, fieldNumber: 3)
    }
    if self.duplex != .unknown {
      try visitor.visitSingularEnumField(value: self.duplex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_EthernetNetworkInterface, rhs: SpaceX_API_Device_EthernetNetworkInterface) -> Bool {
    if lhs.linkDetected != rhs.linkDetected {return false}
    if lhs.speedMbps != rhs.speedMbps {return false}
    if lhs.autonegotiationOn != rhs.autonegotiationOn {return false}
    if lhs.duplex != rhs.duplex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_EthernetNetworkInterface.Duplex: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HALF"),
    2: .same(proto: "FULL"),
  ]
}

extension SpaceX_API_Device_WifiNetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiNetworkInterface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "invalid_packet_counts"),
    3: .same(proto: "channel"),
    8: .standard(proto: "missed_beacons"),
    4: .standard(proto: "link_quality"),
    5: .standard(proto: "signal_level"),
    6: .standard(proto: "noise_level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._invalidPacketCounts) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.channel) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.linkQuality) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.signalLevel) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.noiseLevel) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.missedBeacons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._invalidPacketCounts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.channel != 0 {
      try visitor.visitSingularUInt32Field(value: self.channel, fieldNumber: 3)
    }
    if self.linkQuality.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.linkQuality, fieldNumber: 4)
    }
    if self.signalLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.signalLevel, fieldNumber: 5)
    }
    if self.noiseLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.noiseLevel, fieldNumber: 6)
    }
    if self.missedBeacons != 0 {
      try visitor.visitSingularUInt32Field(value: self.missedBeacons, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_WifiNetworkInterface, rhs: SpaceX_API_Device_WifiNetworkInterface) -> Bool {
    if lhs._invalidPacketCounts != rhs._invalidPacketCounts {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.missedBeacons != rhs.missedBeacons {return false}
    if lhs.linkQuality != rhs.linkQuality {return false}
    if lhs.signalLevel != rhs.signalLevel {return false}
    if lhs.noiseLevel != rhs.noiseLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_WifiNetworkInterface.InvalidPacketCounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_WifiNetworkInterface.protoMessageName + ".InvalidPacketCounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rx_invalid_nwid"),
    2: .standard(proto: "rx_invalid_crypt"),
    3: .standard(proto: "rx_invalid_frag"),
    4: .standard(proto: "tx_excessive_retries"),
    5: .standard(proto: "invalid_misc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rxInvalidNwid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.rxInvalidCrypt) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rxInvalidFrag) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.txExcessiveRetries) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.invalidMisc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rxInvalidNwid != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxInvalidNwid, fieldNumber: 1)
    }
    if self.rxInvalidCrypt != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxInvalidCrypt, fieldNumber: 2)
    }
    if self.rxInvalidFrag != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxInvalidFrag, fieldNumber: 3)
    }
    if self.txExcessiveRetries != 0 {
      try visitor.visitSingularUInt32Field(value: self.txExcessiveRetries, fieldNumber: 4)
    }
    if self.invalidMisc != 0 {
      try visitor.visitSingularUInt32Field(value: self.invalidMisc, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_WifiNetworkInterface.InvalidPacketCounts, rhs: SpaceX_API_Device_WifiNetworkInterface.InvalidPacketCounts) -> Bool {
    if lhs.rxInvalidNwid != rhs.rxInvalidNwid {return false}
    if lhs.rxInvalidCrypt != rhs.rxInvalidCrypt {return false}
    if lhs.rxInvalidFrag != rhs.rxInvalidFrag {return false}
    if lhs.txExcessiveRetries != rhs.txExcessiveRetries {return false}
    if lhs.invalidMisc != rhs.invalidMisc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_BridgeNetworkInterface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BridgeNetworkInterface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.memberNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.memberNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberNames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_BridgeNetworkInterface, rhs: SpaceX_API_Device_BridgeNetworkInterface) -> Bool {
    if lhs.memberNames != rhs.memberNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_LLAPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LLAPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lon"),
    3: .same(proto: "alt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.alt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    if self.alt.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.alt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_LLAPosition, rhs: SpaceX_API_Device_LLAPosition) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.alt != rhs.alt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ECEFPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ECEFPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.z.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ECEFPosition, rhs: SpaceX_API_Device_ECEFPosition) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_InitiateRemoteSshRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateRemoteSshRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_InitiateRemoteSshRequest, rhs: SpaceX_API_Device_InitiateRemoteSshRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_InitiateRemoteSshResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateRemoteSshResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "address"),
    3: .same(proto: "stsafe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.stsafe) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.stsafe.isEmpty {
      try visitor.visitSingularBytesField(value: self.stsafe, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_InitiateRemoteSshResponse, rhs: SpaceX_API_Device_InitiateRemoteSshResponse) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.address != rhs.address {return false}
    if lhs.stsafe != rhs.stsafe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SoftwareUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SoftwareUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .same(proto: "data"),
    3: .same(proto: "open"),
    4: .same(proto: "close"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.`open`) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.close) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.streamID != 0 {
      try visitor.visitSingularUInt64Field(value: self.streamID, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if self.`open` != false {
      try visitor.visitSingularBoolField(value: self.`open`, fieldNumber: 3)
    }
    if self.close != false {
      try visitor.visitSingularBoolField(value: self.close, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SoftwareUpdateRequest, rhs: SpaceX_API_Device_SoftwareUpdateRequest) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.`open` != rhs.`open` {return false}
    if lhs.close != rhs.close {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SoftwareUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SoftwareUpdateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SoftwareUpdateResponse, rhs: SpaceX_API_Device_SoftwareUpdateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
