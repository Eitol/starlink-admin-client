// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: spacex/api/device/wifi_util.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SpaceX_API_Device_IfaceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case eth // = 1
  case rf2Ghz // = 2
  case rf5Ghz // = 5
  case rf5GhzHigh // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .eth
    case 2: self = .rf2Ghz
    case 5: self = .rf5Ghz
    case 6: self = .rf5GhzHigh
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .eth: return 1
    case .rf2Ghz: return 2
    case .rf5Ghz: return 5
    case .rf5GhzHigh: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_IfaceType] = [
    .unknown,
    .eth,
    .rf2Ghz,
    .rf5Ghz,
    .rf5GhzHigh,
  ]

}

enum SpaceX_API_Device_TxPowerLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case txPowerLevel100 // = 0
  case txPowerLevel80 // = 1
  case txPowerLevel50 // = 2
  case txPowerLevel25 // = 3
  case txPowerLevel12 // = 4
  case txPowerLevel6 // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .txPowerLevel100
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .txPowerLevel100
    case 1: self = .txPowerLevel80
    case 2: self = .txPowerLevel50
    case 3: self = .txPowerLevel25
    case 4: self = .txPowerLevel12
    case 5: self = .txPowerLevel6
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .txPowerLevel100: return 0
    case .txPowerLevel80: return 1
    case .txPowerLevel50: return 2
    case .txPowerLevel25: return 3
    case .txPowerLevel12: return 4
    case .txPowerLevel6: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_TxPowerLevel] = [
    .txPowerLevel100,
    .txPowerLevel80,
    .txPowerLevel50,
    .txPowerLevel25,
    .txPowerLevel12,
    .txPowerLevel6,
  ]

}

enum SpaceX_API_Device_PoeState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case disabled // = 0
  case negotiating // = 1
  case onRampup // = 2
  case on // = 3
  case waterDetectRampup // = 4
  case waterDetect // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .disabled
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disabled
    case 1: self = .negotiating
    case 2: self = .onRampup
    case 3: self = .on
    case 4: self = .waterDetectRampup
    case 5: self = .waterDetect
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .disabled: return 0
    case .negotiating: return 1
    case .onRampup: return 2
    case .on: return 3
    case .waterDetectRampup: return 4
    case .waterDetect: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_PoeState] = [
    .disabled,
    .negotiating,
    .onRampup,
    .on,
    .waterDetectRampup,
    .waterDetect,
  ]

}

enum SpaceX_API_Device_PoeFault: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case fastOvercurrent // = 0
  case slowOvercurrent // = 1
  case undercurrent // = 2
  case overvoltage // = 3
  case undervoltage // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .fastOvercurrent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fastOvercurrent
    case 1: self = .slowOvercurrent
    case 2: self = .undercurrent
    case 3: self = .overvoltage
    case 4: self = .undervoltage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .fastOvercurrent: return 0
    case .slowOvercurrent: return 1
    case .undercurrent: return 2
    case .overvoltage: return 3
    case .undervoltage: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_PoeFault] = [
    .fastOvercurrent,
    .slowOvercurrent,
    .undercurrent,
    .overvoltage,
    .undervoltage,
  ]

}

enum SpaceX_API_Device_WifiMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case `default` // = 0
  case aOnly // = 1
  case bOnly // = 2
  case gOnly // = 3
  case nOnly // = 4
  case bGMixed // = 5
  case aNMixed // = 6
  case gNMixed // = 7
  case bGNMixed // = 8
  case aAnAcMixed // = 9
  case anAcMixed // = 10
  case bGNAxMixed // = 11
  case aAnAcAxMixed // = 12
  case aNAcMixed // = 13
  case aNAcAxMixed // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .aOnly
    case 2: self = .bOnly
    case 3: self = .gOnly
    case 4: self = .nOnly
    case 5: self = .bGMixed
    case 6: self = .aNMixed
    case 7: self = .gNMixed
    case 8: self = .bGNMixed
    case 9: self = .aAnAcMixed
    case 10: self = .anAcMixed
    case 11: self = .bGNAxMixed
    case 12: self = .aAnAcAxMixed
    case 13: self = .aNAcMixed
    case 14: self = .aNAcAxMixed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .aOnly: return 1
    case .bOnly: return 2
    case .gOnly: return 3
    case .nOnly: return 4
    case .bGMixed: return 5
    case .aNMixed: return 6
    case .gNMixed: return 7
    case .bGNMixed: return 8
    case .aAnAcMixed: return 9
    case .anAcMixed: return 10
    case .bGNAxMixed: return 11
    case .aAnAcAxMixed: return 12
    case .aNAcMixed: return 13
    case .aNAcAxMixed: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_WifiMode] = [
    .default,
    .aOnly,
    .bOnly,
    .gOnly,
    .nOnly,
    .bGMixed,
    .aNMixed,
    .gNMixed,
    .bGNMixed,
    .aAnAcMixed,
    .anAcMixed,
    .bGNAxMixed,
    .aAnAcAxMixed,
    .aNAcMixed,
    .aNAcAxMixed,
  ]

}

enum SpaceX_API_Device_WifiSecurity: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case `open` // = 1
  case wpa2 // = 2
  case wpa3 // = 3
  case wpa2Wpa3 // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .open
    case 2: self = .wpa2
    case 3: self = .wpa3
    case 4: self = .wpa2Wpa3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .open: return 1
    case .wpa2: return 2
    case .wpa3: return 3
    case .wpa2Wpa3: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_WifiSecurity] = [
    .unknown,
    .open,
    .wpa2,
    .wpa3,
    .wpa2Wpa3,
  ]

}

enum SpaceX_API_Device_Protocol: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case tcp // = 0
  case udp // = 1
  case tls // = 2
  case dtls // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .tcp
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tcp
    case 1: self = .udp
    case 2: self = .tls
    case 3: self = .dtls
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tcp: return 0
    case .udp: return 1
    case .tls: return 2
    case .dtls: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_Protocol] = [
    .tcp,
    .udp,
    .tls,
    .dtls,
  ]

}

enum SpaceX_API_Device_WifiSoftwareUpdateState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case notRun // = 0
  case gettingTargetVersion // = 1
  case downloadingUpdateImage // = 2
  case flashing // = 3
  case noUpdateRequired // = 4
  case rebootPending // = 5
  case gettingTargetVersionFailed // = 6
  case gettingTargetVersionExhausted // = 7
  case noValidArtifact // = 8
  case illegalArtifact // = 9
  case downloadingUpdateImageFailed // = 10
  case downloadingUpdateImageExhausted // = 11
  case flashingFailed // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .notRun
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notRun
    case 1: self = .gettingTargetVersion
    case 2: self = .downloadingUpdateImage
    case 3: self = .flashing
    case 4: self = .noUpdateRequired
    case 5: self = .rebootPending
    case 6: self = .gettingTargetVersionFailed
    case 7: self = .gettingTargetVersionExhausted
    case 8: self = .noValidArtifact
    case 9: self = .illegalArtifact
    case 10: self = .downloadingUpdateImageFailed
    case 11: self = .downloadingUpdateImageExhausted
    case 12: self = .flashingFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notRun: return 0
    case .gettingTargetVersion: return 1
    case .downloadingUpdateImage: return 2
    case .flashing: return 3
    case .noUpdateRequired: return 4
    case .rebootPending: return 5
    case .gettingTargetVersionFailed: return 6
    case .gettingTargetVersionExhausted: return 7
    case .noValidArtifact: return 8
    case .illegalArtifact: return 9
    case .downloadingUpdateImageFailed: return 10
    case .downloadingUpdateImageExhausted: return 11
    case .flashingFailed: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_WifiSoftwareUpdateState] = [
    .notRun,
    .gettingTargetVersion,
    .downloadingUpdateImage,
    .flashing,
    .noUpdateRequired,
    .rebootPending,
    .gettingTargetVersionFailed,
    .gettingTargetVersionExhausted,
    .noValidArtifact,
    .illegalArtifact,
    .downloadingUpdateImageFailed,
    .downloadingUpdateImageExhausted,
    .flashingFailed,
  ]

}

struct SpaceX_API_Device_InflatedBasicServiceSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bssid: String = String()

  var ssid: String = String()

  var macLan: String = String()

  var ifaceName: String = String()

  var ifaceType: SpaceX_API_Device_IfaceType = .unknown

  var channel: UInt32 = 0

  var preference: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DhcpLease: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ipAddress: String = String()

  var macAddress: String = String()

  var hostname: String = String()

  var expiresTime: String = String()

  var active: Bool = false

  var clientID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DhcpServer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var domain: String = String()

  var subnet: String = String()

  var leases: [SpaceX_API_Device_DhcpLease] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_RadiusStatsMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var radiusStats: Dictionary<String,SpaceX_API_Device_RadiusStatsMap.RadiusStats> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RadiusStats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ifaceName: String = String()

    var timeoutCount: UInt32 = 0

    var accessRequestCount: UInt32 = 0

    var accessAcceptCount: UInt32 = 0

    var accessRejectCount: UInt32 = 0

    var accessChallengeCount: UInt32 = 0

    var accountingRequestCount: UInt32 = 0

    var accountingResponseCount: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct SpaceX_API_Device_PoeStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var poeState: SpaceX_API_Device_PoeState = .disabled

  var poePower: Float = 0

  var poeFaultsFastOvercurrent: UInt32 = 0

  var poeFaultsSlowOvercurrent: UInt32 = 0

  var poeFaultsOvervoltage: UInt32 = 0

  var poeFaultsUndervoltage: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_WifiSoftwareUpdateStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: SpaceX_API_Device_WifiSoftwareUpdateState = .notRun

  var softwareDownloadProgress: Float = 0

  var secondsSinceGetTargetVersions: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SpaceX.API.Device"

extension SpaceX_API_Device_IfaceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IFACE_TYPE_UNKNOWN"),
    1: .same(proto: "IFACE_TYPE_ETH"),
    2: .same(proto: "IFACE_TYPE_RF_2GHZ"),
    5: .same(proto: "IFACE_TYPE_RF_5GHZ"),
    6: .same(proto: "IFACE_TYPE_RF_5GHZ_HIGH"),
  ]
}

extension SpaceX_API_Device_TxPowerLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TX_POWER_LEVEL_100"),
    1: .same(proto: "TX_POWER_LEVEL_80"),
    2: .same(proto: "TX_POWER_LEVEL_50"),
    3: .same(proto: "TX_POWER_LEVEL_25"),
    4: .same(proto: "TX_POWER_LEVEL_12"),
    5: .same(proto: "TX_POWER_LEVEL_6"),
  ]
}

extension SpaceX_API_Device_PoeState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POE_STATE_DISABLED"),
    1: .same(proto: "POE_STATE_NEGOTIATING"),
    2: .same(proto: "POE_STATE_ON_RAMPUP"),
    3: .same(proto: "POE_STATE_ON"),
    4: .same(proto: "POE_STATE_WATER_DETECT_RAMPUP"),
    5: .same(proto: "POE_STATE_WATER_DETECT"),
  ]
}

extension SpaceX_API_Device_PoeFault: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POE_FAULT_FAST_OVERCURRENT"),
    1: .same(proto: "POE_FAULT_SLOW_OVERCURRENT"),
    2: .same(proto: "POE_FAULT_UNDERCURRENT"),
    3: .same(proto: "POE_FAULT_OVERVOLTAGE"),
    4: .same(proto: "POE_FAULT_UNDERVOLTAGE"),
  ]
}

extension SpaceX_API_Device_WifiMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WIFI_MODE_DEFAULT"),
    1: .same(proto: "A_ONLY"),
    2: .same(proto: "B_ONLY"),
    3: .same(proto: "G_ONLY"),
    4: .same(proto: "N_ONLY"),
    5: .same(proto: "B_G_MIXED"),
    6: .same(proto: "A_N_MIXED"),
    7: .same(proto: "G_N_MIXED"),
    8: .same(proto: "B_G_N_MIXED"),
    9: .same(proto: "A_AN_AC_MIXED"),
    10: .same(proto: "AN_AC_MIXED"),
    11: .same(proto: "B_G_N_AX_MIXED"),
    12: .same(proto: "A_AN_AC_AX_MIXED"),
    13: .same(proto: "A_N_AC_MIXED"),
    14: .same(proto: "A_N_AC_AX_MIXED"),
  ]
}

extension SpaceX_API_Device_WifiSecurity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WIFI_SECURITY_UNKNOWN"),
    1: .same(proto: "OPEN"),
    2: .same(proto: "WPA2"),
    3: .same(proto: "WPA3"),
    4: .same(proto: "WPA2WPA3"),
  ]
}

extension SpaceX_API_Device_Protocol: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TCP"),
    1: .same(proto: "UDP"),
    2: .same(proto: "TLS"),
    3: .same(proto: "DTLS"),
  ]
}

extension SpaceX_API_Device_WifiSoftwareUpdateState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_RUN"),
    1: .same(proto: "GETTING_TARGET_VERSION"),
    2: .same(proto: "DOWNLOADING_UPDATE_IMAGE"),
    3: .same(proto: "FLASHING"),
    4: .same(proto: "NO_UPDATE_REQUIRED"),
    5: .same(proto: "REBOOT_PENDING"),
    6: .same(proto: "GETTING_TARGET_VERSION_FAILED"),
    7: .same(proto: "GETTING_TARGET_VERSION_EXHAUSTED"),
    8: .same(proto: "NO_VALID_ARTIFACT"),
    9: .same(proto: "ILLEGAL_ARTIFACT"),
    10: .same(proto: "DOWNLOADING_UPDATE_IMAGE_FAILED"),
    11: .same(proto: "DOWNLOADING_UPDATE_IMAGE_EXHAUSTED"),
    12: .same(proto: "FLASHING_FAILED"),
  ]
}

extension SpaceX_API_Device_InflatedBasicServiceSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InflatedBasicServiceSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bssid"),
    2: .same(proto: "ssid"),
    3: .standard(proto: "mac_lan"),
    4: .standard(proto: "iface_name"),
    5: .standard(proto: "iface_type"),
    6: .same(proto: "channel"),
    7: .same(proto: "preference"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bssid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ssid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.macLan) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ifaceName) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.ifaceType) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.channel) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.preference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bssid.isEmpty {
      try visitor.visitSingularStringField(value: self.bssid, fieldNumber: 1)
    }
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 2)
    }
    if !self.macLan.isEmpty {
      try visitor.visitSingularStringField(value: self.macLan, fieldNumber: 3)
    }
    if !self.ifaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.ifaceName, fieldNumber: 4)
    }
    if self.ifaceType != .unknown {
      try visitor.visitSingularEnumField(value: self.ifaceType, fieldNumber: 5)
    }
    if self.channel != 0 {
      try visitor.visitSingularUInt32Field(value: self.channel, fieldNumber: 6)
    }
    if self.preference != 0 {
      try visitor.visitSingularUInt32Field(value: self.preference, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_InflatedBasicServiceSet, rhs: SpaceX_API_Device_InflatedBasicServiceSet) -> Bool {
    if lhs.bssid != rhs.bssid {return false}
    if lhs.ssid != rhs.ssid {return false}
    if lhs.macLan != rhs.macLan {return false}
    if lhs.ifaceName != rhs.ifaceName {return false}
    if lhs.ifaceType != rhs.ifaceType {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.preference != rhs.preference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DhcpLease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DhcpLease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ip_address"),
    2: .standard(proto: "mac_address"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "expires_time"),
    5: .same(proto: "active"),
    6: .standard(proto: "client_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.expiresTime) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.clientID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 1)
    }
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 2)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    if !self.expiresTime.isEmpty {
      try visitor.visitSingularStringField(value: self.expiresTime, fieldNumber: 4)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 5)
    }
    if self.clientID != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DhcpLease, rhs: SpaceX_API_Device_DhcpLease) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.expiresTime != rhs.expiresTime {return false}
    if lhs.active != rhs.active {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DhcpServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DhcpServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "subnet"),
    3: .same(proto: "leases"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subnet) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.leases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.subnet.isEmpty {
      try visitor.visitSingularStringField(value: self.subnet, fieldNumber: 2)
    }
    if !self.leases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leases, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DhcpServer, rhs: SpaceX_API_Device_DhcpServer) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.subnet != rhs.subnet {return false}
    if lhs.leases != rhs.leases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RadiusStatsMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RadiusStatsMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radius_stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SpaceX_API_Device_RadiusStatsMap.RadiusStats>.self, value: &self.radiusStats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.radiusStats.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SpaceX_API_Device_RadiusStatsMap.RadiusStats>.self, value: self.radiusStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RadiusStatsMap, rhs: SpaceX_API_Device_RadiusStatsMap) -> Bool {
    if lhs.radiusStats != rhs.radiusStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RadiusStatsMap.RadiusStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_RadiusStatsMap.protoMessageName + ".RadiusStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "iface_name"),
    2: .standard(proto: "timeout_count"),
    3: .standard(proto: "access_request_count"),
    4: .standard(proto: "access_accept_count"),
    5: .standard(proto: "access_reject_count"),
    6: .standard(proto: "access_challenge_count"),
    7: .standard(proto: "accounting_request_count"),
    8: .standard(proto: "accounting_response_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ifaceName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timeoutCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.accessRequestCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.accessAcceptCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.accessRejectCount) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.accessChallengeCount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.accountingRequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.accountingResponseCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ifaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.ifaceName, fieldNumber: 1)
    }
    if self.timeoutCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeoutCount, fieldNumber: 2)
    }
    if self.accessRequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.accessRequestCount, fieldNumber: 3)
    }
    if self.accessAcceptCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.accessAcceptCount, fieldNumber: 4)
    }
    if self.accessRejectCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.accessRejectCount, fieldNumber: 5)
    }
    if self.accessChallengeCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.accessChallengeCount, fieldNumber: 6)
    }
    if self.accountingRequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.accountingRequestCount, fieldNumber: 7)
    }
    if self.accountingResponseCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.accountingResponseCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RadiusStatsMap.RadiusStats, rhs: SpaceX_API_Device_RadiusStatsMap.RadiusStats) -> Bool {
    if lhs.ifaceName != rhs.ifaceName {return false}
    if lhs.timeoutCount != rhs.timeoutCount {return false}
    if lhs.accessRequestCount != rhs.accessRequestCount {return false}
    if lhs.accessAcceptCount != rhs.accessAcceptCount {return false}
    if lhs.accessRejectCount != rhs.accessRejectCount {return false}
    if lhs.accessChallengeCount != rhs.accessChallengeCount {return false}
    if lhs.accountingRequestCount != rhs.accountingRequestCount {return false}
    if lhs.accountingResponseCount != rhs.accountingResponseCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_PoeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoeStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "poe_state"),
    2: .standard(proto: "poe_power"),
    3: .standard(proto: "poe_faults_fast_overcurrent"),
    4: .standard(proto: "poe_faults_slow_overcurrent"),
    5: .standard(proto: "poe_faults_overvoltage"),
    6: .standard(proto: "poe_faults_undervoltage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.poeState) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.poePower) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.poeFaultsFastOvercurrent) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.poeFaultsSlowOvercurrent) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.poeFaultsOvervoltage) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.poeFaultsUndervoltage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poeState != .disabled {
      try visitor.visitSingularEnumField(value: self.poeState, fieldNumber: 1)
    }
    if self.poePower.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.poePower, fieldNumber: 2)
    }
    if self.poeFaultsFastOvercurrent != 0 {
      try visitor.visitSingularUInt32Field(value: self.poeFaultsFastOvercurrent, fieldNumber: 3)
    }
    if self.poeFaultsSlowOvercurrent != 0 {
      try visitor.visitSingularUInt32Field(value: self.poeFaultsSlowOvercurrent, fieldNumber: 4)
    }
    if self.poeFaultsOvervoltage != 0 {
      try visitor.visitSingularUInt32Field(value: self.poeFaultsOvervoltage, fieldNumber: 5)
    }
    if self.poeFaultsUndervoltage != 0 {
      try visitor.visitSingularUInt32Field(value: self.poeFaultsUndervoltage, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_PoeStats, rhs: SpaceX_API_Device_PoeStats) -> Bool {
    if lhs.poeState != rhs.poeState {return false}
    if lhs.poePower != rhs.poePower {return false}
    if lhs.poeFaultsFastOvercurrent != rhs.poeFaultsFastOvercurrent {return false}
    if lhs.poeFaultsSlowOvercurrent != rhs.poeFaultsSlowOvercurrent {return false}
    if lhs.poeFaultsOvervoltage != rhs.poeFaultsOvervoltage {return false}
    if lhs.poeFaultsUndervoltage != rhs.poeFaultsUndervoltage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_WifiSoftwareUpdateStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiSoftwareUpdateStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "software_download_progress"),
    3: .standard(proto: "seconds_since_get_target_versions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.softwareDownloadProgress) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.secondsSinceGetTargetVersions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .notRun {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.softwareDownloadProgress.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.softwareDownloadProgress, fieldNumber: 2)
    }
    if self.secondsSinceGetTargetVersions.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.secondsSinceGetTargetVersions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_WifiSoftwareUpdateStats, rhs: SpaceX_API_Device_WifiSoftwareUpdateStats) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.softwareDownloadProgress != rhs.softwareDownloadProgress {return false}
    if lhs.secondsSinceGetTargetVersions != rhs.secondsSinceGetTargetVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
