// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: spacex/api/device/device.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SpaceX_API_Device_PositionSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case auto // = 0
  case none // = 1
  case utInfo // = 2
  case external // = 3
  case gps // = 4
  case starlink // = 5
  case gncGps // = 6
  case gncPnt // = 7
  case gncFused // = 8
  case gncRaw // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .auto
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .auto
    case 1: self = .none
    case 2: self = .utInfo
    case 3: self = .external
    case 4: self = .gps
    case 5: self = .starlink
    case 6: self = .gncGps
    case 7: self = .gncPnt
    case 8: self = .gncFused
    case 9: self = .gncRaw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .auto: return 0
    case .none: return 1
    case .utInfo: return 2
    case .external: return 3
    case .gps: return 4
    case .starlink: return 5
    case .gncGps: return 6
    case .gncPnt: return 7
    case .gncFused: return 8
    case .gncRaw: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_PositionSource] = [
    .auto,
    .none,
    .utInfo,
    .external,
    .gps,
    .starlink,
    .gncGps,
    .gncPnt,
    .gncFused,
    .gncRaw,
  ]

}

enum SpaceX_API_Device_SpeedtestError: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case unknown // = 1
  case token // = 2
  case api // = 3
  case noResult // = 4
  case offline // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .unknown
    case 2: self = .token
    case 3: self = .api
    case 4: self = .noResult
    case 5: self = .offline
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .unknown: return 1
    case .token: return 2
    case .api: return 3
    case .noResult: return 4
    case .offline: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SpaceX_API_Device_SpeedtestError] = [
    .none,
    .unknown,
    .token,
    .api,
    .noResult,
    .offline,
  ]

}

struct SpaceX_API_Device_ToDevice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: SpaceX_API_Device_ToDevice.OneOf_Message? = nil

  var request: SpaceX_API_Device_Request {
    get {
      if case .request(let v)? = message {return v}
      return SpaceX_API_Device_Request()
    }
    set {message = .request(newValue)}
  }

  var healthCheck: SpaceX_API_Device_HealthCheck {
    get {
      if case .healthCheck(let v)? = message {return v}
      return SpaceX_API_Device_HealthCheck()
    }
    set {message = .healthCheck(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable, Sendable {
    case request(SpaceX_API_Device_Request)
    case healthCheck(SpaceX_API_Device_HealthCheck)

  }

  init() {}
}

struct SpaceX_API_Device_FromDevice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: SpaceX_API_Device_FromDevice.OneOf_Message? = nil

  var response: SpaceX_API_Device_Response {
    get {
      if case .response(let v)? = message {return v}
      return SpaceX_API_Device_Response()
    }
    set {message = .response(newValue)}
  }

  var event: SpaceX_API_Device_Event {
    get {
      if case .event(let v)? = message {return v}
      return SpaceX_API_Device_Event()
    }
    set {message = .event(newValue)}
  }

  var healthCheck: SpaceX_API_Device_HealthCheck {
    get {
      if case .healthCheck(let v)? = message {return v}
      return SpaceX_API_Device_HealthCheck()
    }
    set {message = .healthCheck(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable, Sendable {
    case response(SpaceX_API_Device_Response)
    case event(SpaceX_API_Device_Event)
    case healthCheck(SpaceX_API_Device_HealthCheck)

  }

  init() {}
}

struct SpaceX_API_Device_SensitiveCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var targetID: String = String()

  var request: SpaceX_API_Device_SensitiveCommand.OneOf_Request? = nil

  var getLocation: SpaceX_API_Device_GetLocationRequest {
    get {
      if case .getLocation(let v)? = request {return v}
      return SpaceX_API_Device_GetLocationRequest()
    }
    set {request = .getLocation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case getLocation(SpaceX_API_Device_GetLocationRequest)

  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct SpaceX_API_Device_HealthCheck: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_Request: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var epochID: UInt64 {
    get {return _storage._epochID}
    set {_uniqueStorage()._epochID = newValue}
  }

  var targetID: String {
    get {return _storage._targetID}
    set {_uniqueStorage()._targetID = newValue}
  }

  var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  var signedRequest: SpaceX_API_Device_SignedData {
    get {
      if case .signedRequest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SignedData()
    }
    set {_uniqueStorage()._request = .signedRequest(newValue)}
  }

  var getNextID: SpaceX_API_Device_GetNextIdRequest {
    get {
      if case .getNextID(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetNextIdRequest()
    }
    set {_uniqueStorage()._request = .getNextID(newValue)}
  }

  var sensitiveRequest: SpaceX_API_Device_SignedData {
    get {
      if case .sensitiveRequest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SignedData()
    }
    set {_uniqueStorage()._request = .sensitiveRequest(newValue)}
  }

  var authenticate: SpaceX_API_Device_AuthenticateRequest {
    get {
      if case .authenticate(let v)? = _storage._request {return v}
      return SpaceX_API_Device_AuthenticateRequest()
    }
    set {_uniqueStorage()._request = .authenticate(newValue)}
  }

  var enableDebugTelem: SpaceX_API_Device_EnableDebugTelemRequest {
    get {
      if case .enableDebugTelem(let v)? = _storage._request {return v}
      return SpaceX_API_Device_EnableDebugTelemRequest()
    }
    set {_uniqueStorage()._request = .enableDebugTelem(newValue)}
  }

  var factoryReset: SpaceX_API_Device_FactoryResetRequest {
    get {
      if case .factoryReset(let v)? = _storage._request {return v}
      return SpaceX_API_Device_FactoryResetRequest()
    }
    set {_uniqueStorage()._request = .factoryReset(newValue)}
  }

  var getDeviceInfo: SpaceX_API_Device_GetDeviceInfoRequest {
    get {
      if case .getDeviceInfo(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetDeviceInfoRequest()
    }
    set {_uniqueStorage()._request = .getDeviceInfo(newValue)}
  }

  var getHistory: SpaceX_API_Device_GetHistoryRequest {
    get {
      if case .getHistory(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetHistoryRequest()
    }
    set {_uniqueStorage()._request = .getHistory(newValue)}
  }

  var getLog: SpaceX_API_Device_GetLogRequest {
    get {
      if case .getLog(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetLogRequest()
    }
    set {_uniqueStorage()._request = .getLog(newValue)}
  }

  var getNetworkInterfaces: SpaceX_API_Device_GetNetworkInterfacesRequest {
    get {
      if case .getNetworkInterfaces(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetNetworkInterfacesRequest()
    }
    set {_uniqueStorage()._request = .getNetworkInterfaces(newValue)}
  }

  var getPing: SpaceX_API_Device_GetPingRequest {
    get {
      if case .getPing(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetPingRequest()
    }
    set {_uniqueStorage()._request = .getPing(newValue)}
  }

  var pingHost: SpaceX_API_Device_PingHostRequest {
    get {
      if case .pingHost(let v)? = _storage._request {return v}
      return SpaceX_API_Device_PingHostRequest()
    }
    set {_uniqueStorage()._request = .pingHost(newValue)}
  }

  var getStatus: SpaceX_API_Device_GetStatusRequest {
    get {
      if case .getStatus(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetStatusRequest()
    }
    set {_uniqueStorage()._request = .getStatus(newValue)}
  }

  var reboot: SpaceX_API_Device_RebootRequest {
    get {
      if case .reboot(let v)? = _storage._request {return v}
      return SpaceX_API_Device_RebootRequest()
    }
    set {_uniqueStorage()._request = .reboot(newValue)}
  }

  var setSku: SpaceX_API_Device_SetSkuRequest {
    get {
      if case .setSku(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SetSkuRequest()
    }
    set {_uniqueStorage()._request = .setSku(newValue)}
  }

  var setTrustedKeys: SpaceX_API_Device_SetTrustedKeysRequest {
    get {
      if case .setTrustedKeys(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SetTrustedKeysRequest()
    }
    set {_uniqueStorage()._request = .setTrustedKeys(newValue)}
  }

  var speedTest: SpaceX_API_Device_SpeedTestRequest {
    get {
      if case .speedTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SpeedTestRequest()
    }
    set {_uniqueStorage()._request = .speedTest(newValue)}
  }

  var update: SpaceX_API_Device_UpdateRequest {
    get {
      if case .update(let v)? = _storage._request {return v}
      return SpaceX_API_Device_UpdateRequest()
    }
    set {_uniqueStorage()._request = .update(newValue)}
  }

  var getLocation: SpaceX_API_Device_GetLocationRequest {
    get {
      if case .getLocation(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetLocationRequest()
    }
    set {_uniqueStorage()._request = .getLocation(newValue)}
  }

  var getHeapDump: SpaceX_API_Device_GetHeapDumpRequest {
    get {
      if case .getHeapDump(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetHeapDumpRequest()
    }
    set {_uniqueStorage()._request = .getHeapDump(newValue)}
  }

  var restartControl: SpaceX_API_Device_RestartControlRequest {
    get {
      if case .restartControl(let v)? = _storage._request {return v}
      return SpaceX_API_Device_RestartControlRequest()
    }
    set {_uniqueStorage()._request = .restartControl(newValue)}
  }

  var fuse: SpaceX_API_Device_FuseRequest {
    get {
      if case .fuse(let v)? = _storage._request {return v}
      return SpaceX_API_Device_FuseRequest()
    }
    set {_uniqueStorage()._request = .fuse(newValue)}
  }

  var getPersistentStats: SpaceX_API_Device_GetPersistentStatsRequest {
    get {
      if case .getPersistentStats(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetPersistentStatsRequest()
    }
    set {_uniqueStorage()._request = .getPersistentStats(newValue)}
  }

  var getConnections: SpaceX_API_Device_GetConnectionsRequest {
    get {
      if case .getConnections(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetConnectionsRequest()
    }
    set {_uniqueStorage()._request = .getConnections(newValue)}
  }

  var startSpeedtest: SpaceX_API_Device_StartSpeedtestRequest {
    get {
      if case .startSpeedtest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_StartSpeedtestRequest()
    }
    set {_uniqueStorage()._request = .startSpeedtest(newValue)}
  }

  var getSpeedtestStatus: SpaceX_API_Device_GetSpeedtestStatusRequest {
    get {
      if case .getSpeedtestStatus(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetSpeedtestStatusRequest()
    }
    set {_uniqueStorage()._request = .getSpeedtestStatus(newValue)}
  }

  var reportClientSpeedtest: SpaceX_API_Device_ReportClientSpeedtestRequest {
    get {
      if case .reportClientSpeedtest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_ReportClientSpeedtestRequest()
    }
    set {_uniqueStorage()._request = .reportClientSpeedtest(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var initiateRemoteSsh: SpaceX_API_Device_InitiateRemoteSshRequest {
    get {
      if case .initiateRemoteSsh(let v)? = _storage._request {return v}
      return SpaceX_API_Device_InitiateRemoteSshRequest()
    }
    set {_uniqueStorage()._request = .initiateRemoteSsh(newValue)}
  }

  var selfTest: SpaceX_API_Device_SelfTestRequest {
    get {
      if case .selfTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SelfTestRequest()
    }
    set {_uniqueStorage()._request = .selfTest(newValue)}
  }

  var setTestMode: SpaceX_API_Device_SetTestModeRequest {
    get {
      if case .setTestMode(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SetTestModeRequest()
    }
    set {_uniqueStorage()._request = .setTestMode(newValue)}
  }

  var softwareUpdate: SpaceX_API_Device_SoftwareUpdateRequest {
    get {
      if case .softwareUpdate(let v)? = _storage._request {return v}
      return SpaceX_API_Device_SoftwareUpdateRequest()
    }
    set {_uniqueStorage()._request = .softwareUpdate(newValue)}
  }

  var iqCapture: SpaceX_API_Device_IQCaptureRequest {
    get {
      if case .iqCapture(let v)? = _storage._request {return v}
      return SpaceX_API_Device_IQCaptureRequest()
    }
    set {_uniqueStorage()._request = .iqCapture(newValue)}
  }

  var getRadioStats: SpaceX_API_Device_GetRadioStatsRequest {
    get {
      if case .getRadioStats(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetRadioStatsRequest()
    }
    set {_uniqueStorage()._request = .getRadioStats(newValue)}
  }

  var time: SpaceX_API_Device_GetTimeRequest {
    get {
      if case .time(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetTimeRequest()
    }
    set {_uniqueStorage()._request = .time(newValue)}
  }

  var runIperfServer: SpaceX_API_Device_RunIperfServerRequest {
    get {
      if case .runIperfServer(let v)? = _storage._request {return v}
      return SpaceX_API_Device_RunIperfServerRequest()
    }
    set {_uniqueStorage()._request = .runIperfServer(newValue)}
  }

  var tcpConnectivityTest: SpaceX_API_Device_TcpConnectivityTestRequest {
    get {
      if case .tcpConnectivityTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_TcpConnectivityTestRequest()
    }
    set {_uniqueStorage()._request = .tcpConnectivityTest(newValue)}
  }

  var udpConnectivityTest: SpaceX_API_Device_UdpConnectivityTestRequest {
    get {
      if case .udpConnectivityTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_UdpConnectivityTestRequest()
    }
    set {_uniqueStorage()._request = .udpConnectivityTest(newValue)}
  }

  var dishStow: SpaceX_API_Device_DishStowRequest {
    get {
      if case .dishStow(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishStowRequest()
    }
    set {_uniqueStorage()._request = .dishStow(newValue)}
  }

  var startDishSelfTest: SpaceX_API_Device_StartDishSelfTestRequest {
    get {
      if case .startDishSelfTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_StartDishSelfTestRequest()
    }
    set {_uniqueStorage()._request = .startDishSelfTest(newValue)}
  }

  var dishGetContext: SpaceX_API_Device_DishGetContextRequest {
    get {
      if case .dishGetContext(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishGetContextRequest()
    }
    set {_uniqueStorage()._request = .dishGetContext(newValue)}
  }

  var dishGetObstructionMap: SpaceX_API_Device_DishGetObstructionMapRequest {
    get {
      if case .dishGetObstructionMap(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishGetObstructionMapRequest()
    }
    set {_uniqueStorage()._request = .dishGetObstructionMap(newValue)}
  }

  var dishSetEmc: SpaceX_API_Device_DishSetEmcRequest {
    get {
      if case .dishSetEmc(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishSetEmcRequest()
    }
    set {_uniqueStorage()._request = .dishSetEmc(newValue)}
  }

  var dishGetEmc: SpaceX_API_Device_DishGetEmcRequest {
    get {
      if case .dishGetEmc(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishGetEmcRequest()
    }
    set {_uniqueStorage()._request = .dishGetEmc(newValue)}
  }

  var dishSetConfig: SpaceX_API_Device_DishSetConfigRequest {
    get {
      if case .dishSetConfig(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishSetConfigRequest()
    }
    set {_uniqueStorage()._request = .dishSetConfig(newValue)}
  }

  var dishGetConfig: SpaceX_API_Device_DishGetConfigRequest {
    get {
      if case .dishGetConfig(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishGetConfigRequest()
    }
    set {_uniqueStorage()._request = .dishGetConfig(newValue)}
  }

  var dishPowerSave: SpaceX_API_Device_DishPowerSaveRequest {
    get {
      if case .dishPowerSave(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishPowerSaveRequest()
    }
    set {_uniqueStorage()._request = .dishPowerSave(newValue)}
  }

  var dishInhibitGps: SpaceX_API_Device_DishInhibitGpsRequest {
    get {
      if case .dishInhibitGps(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishInhibitGpsRequest()
    }
    set {_uniqueStorage()._request = .dishInhibitGps(newValue)}
  }

  var dishGetData: SpaceX_API_Device_DishGetDataRequest {
    get {
      if case .dishGetData(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishGetDataRequest()
    }
    set {_uniqueStorage()._request = .dishGetData(newValue)}
  }

  var dishClearObstructionMap: SpaceX_API_Device_DishClearObstructionMapRequest {
    get {
      if case .dishClearObstructionMap(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishClearObstructionMapRequest()
    }
    set {_uniqueStorage()._request = .dishClearObstructionMap(newValue)}
  }

  var dishSetMaxPowerTestMode: SpaceX_API_Device_DishSetMaxPowerTestModeRequest {
    get {
      if case .dishSetMaxPowerTestMode(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishSetMaxPowerTestModeRequest()
    }
    set {_uniqueStorage()._request = .dishSetMaxPowerTestMode(newValue)}
  }

  var dishActivateRssiScan: SpaceX_API_Device_DishActivateRssiScanRequest {
    get {
      if case .dishActivateRssiScan(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishActivateRssiScanRequest()
    }
    set {_uniqueStorage()._request = .dishActivateRssiScan(newValue)}
  }

  var dishGetRssiScanResult: SpaceX_API_Device_DishGetRssiScanResultRequest {
    get {
      if case .dishGetRssiScanResult(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishGetRssiScanResultRequest()
    }
    set {_uniqueStorage()._request = .dishGetRssiScanResult(newValue)}
  }

  var dishFactoryReset: SpaceX_API_Device_DishFactoryResetRequest {
    get {
      if case .dishFactoryReset(let v)? = _storage._request {return v}
      return SpaceX_API_Device_DishFactoryResetRequest()
    }
    set {_uniqueStorage()._request = .dishFactoryReset(newValue)}
  }

  var resetButton: SpaceX_API_Device_ResetButtonRequest {
    get {
      if case .resetButton(let v)? = _storage._request {return v}
      return SpaceX_API_Device_ResetButtonRequest()
    }
    set {_uniqueStorage()._request = .resetButton(newValue)}
  }

  var wifiGetClients: SpaceX_API_Device_WifiGetClientsRequest {
    get {
      if case .wifiGetClients(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiGetClientsRequest()
    }
    set {_uniqueStorage()._request = .wifiGetClients(newValue)}
  }

  var wifiGetPingMetrics: SpaceX_API_Device_WifiGetPingMetricsRequest {
    get {
      if case .wifiGetPingMetrics(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiGetPingMetricsRequest()
    }
    set {_uniqueStorage()._request = .wifiGetPingMetrics(newValue)}
  }

  var wifiSetConfig: SpaceX_API_Device_WifiSetConfigRequest {
    get {
      if case .wifiSetConfig(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSetConfigRequest()
    }
    set {_uniqueStorage()._request = .wifiSetConfig(newValue)}
  }

  var wifiGetConfig: SpaceX_API_Device_WifiGetConfigRequest {
    get {
      if case .wifiGetConfig(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiGetConfigRequest()
    }
    set {_uniqueStorage()._request = .wifiGetConfig(newValue)}
  }

  var wifiSetup: SpaceX_API_Device_WifiSetupRequest {
    get {
      if case .wifiSetup(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSetupRequest()
    }
    set {_uniqueStorage()._request = .wifiSetup(newValue)}
  }

  var wifiSetMeshDeviceTrust: SpaceX_API_Device_WifiSetMeshDeviceTrustRequest {
    get {
      if case .wifiSetMeshDeviceTrust(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSetMeshDeviceTrustRequest()
    }
    set {_uniqueStorage()._request = .wifiSetMeshDeviceTrust(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var wifiSetMeshConfig: SpaceX_API_Device_WifiSetMeshConfigRequest {
    get {
      if case .wifiSetMeshConfig(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSetMeshConfigRequest()
    }
    set {_uniqueStorage()._request = .wifiSetMeshConfig(newValue)}
  }

  var wifiGetClientHistory: SpaceX_API_Device_WifiGetClientHistoryRequest {
    get {
      if case .wifiGetClientHistory(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiGetClientHistoryRequest()
    }
    set {_uniqueStorage()._request = .wifiGetClientHistory(newValue)}
  }

  var wifiSetClientGivenName: SpaceX_API_Device_WifiSetClientGivenNameRequest {
    get {
      if case .wifiSetClientGivenName(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSetClientGivenNameRequest()
    }
    set {_uniqueStorage()._request = .wifiSetClientGivenName(newValue)}
  }

  var wifiSetAviationConformed: SpaceX_API_Device_WifiSetAviationConformedRequest {
    get {
      if case .wifiSetAviationConformed(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSetAviationConformedRequest()
    }
    set {_uniqueStorage()._request = .wifiSetAviationConformed(newValue)}
  }

  var wifiSelfTest: SpaceX_API_Device_WifiSelfTestRequest {
    get {
      if case .wifiSelfTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiSelfTestRequest()
    }
    set {_uniqueStorage()._request = .wifiSelfTest(newValue)}
  }

  var wifiRunSelfTest: SpaceX_API_Device_WifiRunSelfTestRequest {
    get {
      if case .wifiRunSelfTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiRunSelfTestRequest()
    }
    set {_uniqueStorage()._request = .wifiRunSelfTest(newValue)}
  }

  var wifiCalibrationMode: SpaceX_API_Device_WifiCalibrationModeRequest {
    get {
      if case .wifiCalibrationMode(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiCalibrationModeRequest()
    }
    set {_uniqueStorage()._request = .wifiCalibrationMode(newValue)}
  }

  var wifiGuestInfo: SpaceX_API_Device_WifiGuestInfoRequest {
    get {
      if case .wifiGuestInfo(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiGuestInfoRequest()
    }
    set {_uniqueStorage()._request = .wifiGuestInfo(newValue)}
  }

  var wifiRfTest: SpaceX_API_Device_WifiRfTestRequest {
    get {
      if case .wifiRfTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiRfTestRequest()
    }
    set {_uniqueStorage()._request = .wifiRfTest(newValue)}
  }

  var wifiGetFirewall: SpaceX_API_Device_WifiGetFirewallRequest {
    get {
      if case .wifiGetFirewall(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiGetFirewallRequest()
    }
    set {_uniqueStorage()._request = .wifiGetFirewall(newValue)}
  }

  var wifiTogglePoeNegotiation: SpaceX_API_Device_WifiTogglePoeNegotiationRequest {
    get {
      if case .wifiTogglePoeNegotiation(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiTogglePoeNegotiationRequest()
    }
    set {_uniqueStorage()._request = .wifiTogglePoeNegotiation(newValue)}
  }

  var wifiFactoryTestCommand: SpaceX_API_Device_WifiFactoryTestCommandRequest {
    get {
      if case .wifiFactoryTestCommand(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiFactoryTestCommandRequest()
    }
    set {_uniqueStorage()._request = .wifiFactoryTestCommand(newValue)}
  }

  var wifiStartLocalTelemProxy: SpaceX_API_Device_WifiStartLocalTelemProxyRequest {
    get {
      if case .wifiStartLocalTelemProxy(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiStartLocalTelemProxyRequest()
    }
    set {_uniqueStorage()._request = .wifiStartLocalTelemProxy(newValue)}
  }

  var wifiBackhaulStats: SpaceX_API_Device_WifiBackhaulStatsRequest {
    get {
      if case .wifiBackhaulStats(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiBackhaulStatsRequest()
    }
    set {_uniqueStorage()._request = .wifiBackhaulStats(newValue)}
  }

  var wifiToggleUmbilicalMode: SpaceX_API_Device_WifiToggleUmbilicalModeRequest {
    get {
      if case .wifiToggleUmbilicalMode(let v)? = _storage._request {return v}
      return SpaceX_API_Device_WifiToggleUmbilicalModeRequest()
    }
    set {_uniqueStorage()._request = .wifiToggleUmbilicalMode(newValue)}
  }

  var transceiverIfLoopbackTest: SpaceX_API_Device_TransceiverIFLoopbackTestRequest {
    get {
      if case .transceiverIfLoopbackTest(let v)? = _storage._request {return v}
      return SpaceX_API_Device_TransceiverIFLoopbackTestRequest()
    }
    set {_uniqueStorage()._request = .transceiverIfLoopbackTest(newValue)}
  }

  var transceiverGetStatus: SpaceX_API_Device_TransceiverGetStatusRequest {
    get {
      if case .transceiverGetStatus(let v)? = _storage._request {return v}
      return SpaceX_API_Device_TransceiverGetStatusRequest()
    }
    set {_uniqueStorage()._request = .transceiverGetStatus(newValue)}
  }

  var transceiverGetTelemetry: SpaceX_API_Device_TransceiverGetTelemetryRequest {
    get {
      if case .transceiverGetTelemetry(let v)? = _storage._request {return v}
      return SpaceX_API_Device_TransceiverGetTelemetryRequest()
    }
    set {_uniqueStorage()._request = .transceiverGetTelemetry(newValue)}
  }

  var startUnlock: SpaceX_API_Device_Services_Unlock_StartUnlockRequest {
    get {
      if case .startUnlock(let v)? = _storage._request {return v}
      return SpaceX_API_Device_Services_Unlock_StartUnlockRequest()
    }
    set {_uniqueStorage()._request = .startUnlock(newValue)}
  }

  var finishUnlock: SpaceX_API_Device_Services_Unlock_FinishUnlockRequest {
    get {
      if case .finishUnlock(let v)? = _storage._request {return v}
      return SpaceX_API_Device_Services_Unlock_FinishUnlockRequest()
    }
    set {_uniqueStorage()._request = .finishUnlock(newValue)}
  }

  var getDiagnostics: SpaceX_API_Device_GetDiagnosticsRequest {
    get {
      if case .getDiagnostics(let v)? = _storage._request {return v}
      return SpaceX_API_Device_GetDiagnosticsRequest()
    }
    set {_uniqueStorage()._request = .getDiagnostics(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case signedRequest(SpaceX_API_Device_SignedData)
    case getNextID(SpaceX_API_Device_GetNextIdRequest)
    case sensitiveRequest(SpaceX_API_Device_SignedData)
    case authenticate(SpaceX_API_Device_AuthenticateRequest)
    case enableDebugTelem(SpaceX_API_Device_EnableDebugTelemRequest)
    case factoryReset(SpaceX_API_Device_FactoryResetRequest)
    case getDeviceInfo(SpaceX_API_Device_GetDeviceInfoRequest)
    case getHistory(SpaceX_API_Device_GetHistoryRequest)
    case getLog(SpaceX_API_Device_GetLogRequest)
    case getNetworkInterfaces(SpaceX_API_Device_GetNetworkInterfacesRequest)
    case getPing(SpaceX_API_Device_GetPingRequest)
    case pingHost(SpaceX_API_Device_PingHostRequest)
    case getStatus(SpaceX_API_Device_GetStatusRequest)
    case reboot(SpaceX_API_Device_RebootRequest)
    case setSku(SpaceX_API_Device_SetSkuRequest)
    case setTrustedKeys(SpaceX_API_Device_SetTrustedKeysRequest)
    case speedTest(SpaceX_API_Device_SpeedTestRequest)
    case update(SpaceX_API_Device_UpdateRequest)
    case getLocation(SpaceX_API_Device_GetLocationRequest)
    case getHeapDump(SpaceX_API_Device_GetHeapDumpRequest)
    case restartControl(SpaceX_API_Device_RestartControlRequest)
    case fuse(SpaceX_API_Device_FuseRequest)
    case getPersistentStats(SpaceX_API_Device_GetPersistentStatsRequest)
    case getConnections(SpaceX_API_Device_GetConnectionsRequest)
    case startSpeedtest(SpaceX_API_Device_StartSpeedtestRequest)
    case getSpeedtestStatus(SpaceX_API_Device_GetSpeedtestStatusRequest)
    case reportClientSpeedtest(SpaceX_API_Device_ReportClientSpeedtestRequest)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case initiateRemoteSsh(SpaceX_API_Device_InitiateRemoteSshRequest)
    case selfTest(SpaceX_API_Device_SelfTestRequest)
    case setTestMode(SpaceX_API_Device_SetTestModeRequest)
    case softwareUpdate(SpaceX_API_Device_SoftwareUpdateRequest)
    case iqCapture(SpaceX_API_Device_IQCaptureRequest)
    case getRadioStats(SpaceX_API_Device_GetRadioStatsRequest)
    case time(SpaceX_API_Device_GetTimeRequest)
    case runIperfServer(SpaceX_API_Device_RunIperfServerRequest)
    case tcpConnectivityTest(SpaceX_API_Device_TcpConnectivityTestRequest)
    case udpConnectivityTest(SpaceX_API_Device_UdpConnectivityTestRequest)
    case dishStow(SpaceX_API_Device_DishStowRequest)
    case startDishSelfTest(SpaceX_API_Device_StartDishSelfTestRequest)
    case dishGetContext(SpaceX_API_Device_DishGetContextRequest)
    case dishGetObstructionMap(SpaceX_API_Device_DishGetObstructionMapRequest)
    case dishSetEmc(SpaceX_API_Device_DishSetEmcRequest)
    case dishGetEmc(SpaceX_API_Device_DishGetEmcRequest)
    case dishSetConfig(SpaceX_API_Device_DishSetConfigRequest)
    case dishGetConfig(SpaceX_API_Device_DishGetConfigRequest)
    case dishPowerSave(SpaceX_API_Device_DishPowerSaveRequest)
    case dishInhibitGps(SpaceX_API_Device_DishInhibitGpsRequest)
    case dishGetData(SpaceX_API_Device_DishGetDataRequest)
    case dishClearObstructionMap(SpaceX_API_Device_DishClearObstructionMapRequest)
    case dishSetMaxPowerTestMode(SpaceX_API_Device_DishSetMaxPowerTestModeRequest)
    case dishActivateRssiScan(SpaceX_API_Device_DishActivateRssiScanRequest)
    case dishGetRssiScanResult(SpaceX_API_Device_DishGetRssiScanResultRequest)
    case dishFactoryReset(SpaceX_API_Device_DishFactoryResetRequest)
    case resetButton(SpaceX_API_Device_ResetButtonRequest)
    case wifiGetClients(SpaceX_API_Device_WifiGetClientsRequest)
    case wifiGetPingMetrics(SpaceX_API_Device_WifiGetPingMetricsRequest)
    case wifiSetConfig(SpaceX_API_Device_WifiSetConfigRequest)
    case wifiGetConfig(SpaceX_API_Device_WifiGetConfigRequest)
    case wifiSetup(SpaceX_API_Device_WifiSetupRequest)
    case wifiSetMeshDeviceTrust(SpaceX_API_Device_WifiSetMeshDeviceTrustRequest)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case wifiSetMeshConfig(SpaceX_API_Device_WifiSetMeshConfigRequest)
    case wifiGetClientHistory(SpaceX_API_Device_WifiGetClientHistoryRequest)
    case wifiSetClientGivenName(SpaceX_API_Device_WifiSetClientGivenNameRequest)
    case wifiSetAviationConformed(SpaceX_API_Device_WifiSetAviationConformedRequest)
    case wifiSelfTest(SpaceX_API_Device_WifiSelfTestRequest)
    case wifiRunSelfTest(SpaceX_API_Device_WifiRunSelfTestRequest)
    case wifiCalibrationMode(SpaceX_API_Device_WifiCalibrationModeRequest)
    case wifiGuestInfo(SpaceX_API_Device_WifiGuestInfoRequest)
    case wifiRfTest(SpaceX_API_Device_WifiRfTestRequest)
    case wifiGetFirewall(SpaceX_API_Device_WifiGetFirewallRequest)
    case wifiTogglePoeNegotiation(SpaceX_API_Device_WifiTogglePoeNegotiationRequest)
    case wifiFactoryTestCommand(SpaceX_API_Device_WifiFactoryTestCommandRequest)
    case wifiStartLocalTelemProxy(SpaceX_API_Device_WifiStartLocalTelemProxyRequest)
    case wifiBackhaulStats(SpaceX_API_Device_WifiBackhaulStatsRequest)
    case wifiToggleUmbilicalMode(SpaceX_API_Device_WifiToggleUmbilicalModeRequest)
    case transceiverIfLoopbackTest(SpaceX_API_Device_TransceiverIFLoopbackTestRequest)
    case transceiverGetStatus(SpaceX_API_Device_TransceiverGetStatusRequest)
    case transceiverGetTelemetry(SpaceX_API_Device_TransceiverGetTelemetryRequest)
    case startUnlock(SpaceX_API_Device_Services_Unlock_StartUnlockRequest)
    case finishUnlock(SpaceX_API_Device_Services_Unlock_FinishUnlockRequest)
    case getDiagnostics(SpaceX_API_Device_GetDiagnosticsRequest)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_Response: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var status: SpaceX_API_Status_Status {
    get {return _storage._status ?? SpaceX_API_Status_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var apiVersion: UInt64 {
    get {return _storage._apiVersion}
    set {_uniqueStorage()._apiVersion = newValue}
  }

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  var getNextID: SpaceX_API_Device_GetNextIdResponse {
    get {
      if case .getNextID(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetNextIdResponse()
    }
    set {_uniqueStorage()._response = .getNextID(newValue)}
  }

  var enableDebugTelem: SpaceX_API_Device_EnableDebugTelemResponse {
    get {
      if case .enableDebugTelem(let v)? = _storage._response {return v}
      return SpaceX_API_Device_EnableDebugTelemResponse()
    }
    set {_uniqueStorage()._response = .enableDebugTelem(newValue)}
  }

  var factoryReset: SpaceX_API_Device_FactoryResetResponse {
    get {
      if case .factoryReset(let v)? = _storage._response {return v}
      return SpaceX_API_Device_FactoryResetResponse()
    }
    set {_uniqueStorage()._response = .factoryReset(newValue)}
  }

  var getDeviceInfo: SpaceX_API_Device_GetDeviceInfoResponse {
    get {
      if case .getDeviceInfo(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetDeviceInfoResponse()
    }
    set {_uniqueStorage()._response = .getDeviceInfo(newValue)}
  }

  var getLog: SpaceX_API_Device_GetLogResponse {
    get {
      if case .getLog(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetLogResponse()
    }
    set {_uniqueStorage()._response = .getLog(newValue)}
  }

  var getNetworkInterfaces: SpaceX_API_Device_GetNetworkInterfacesResponse {
    get {
      if case .getNetworkInterfaces(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetNetworkInterfacesResponse()
    }
    set {_uniqueStorage()._response = .getNetworkInterfaces(newValue)}
  }

  var getPing: SpaceX_API_Device_GetPingResponse {
    get {
      if case .getPing(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetPingResponse()
    }
    set {_uniqueStorage()._response = .getPing(newValue)}
  }

  var pingHost: SpaceX_API_Device_PingHostResponse {
    get {
      if case .pingHost(let v)? = _storage._response {return v}
      return SpaceX_API_Device_PingHostResponse()
    }
    set {_uniqueStorage()._response = .pingHost(newValue)}
  }

  var reboot: SpaceX_API_Device_RebootResponse {
    get {
      if case .reboot(let v)? = _storage._response {return v}
      return SpaceX_API_Device_RebootResponse()
    }
    set {_uniqueStorage()._response = .reboot(newValue)}
  }

  var speedTest: SpaceX_API_Device_SpeedTestResponse {
    get {
      if case .speedTest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_SpeedTestResponse()
    }
    set {_uniqueStorage()._response = .speedTest(newValue)}
  }

  var setSku: SpaceX_API_Device_SetSkuResponse {
    get {
      if case .setSku(let v)? = _storage._response {return v}
      return SpaceX_API_Device_SetSkuResponse()
    }
    set {_uniqueStorage()._response = .setSku(newValue)}
  }

  var setTrustedKeys: SpaceX_API_Device_SetTrustedKeysResponse {
    get {
      if case .setTrustedKeys(let v)? = _storage._response {return v}
      return SpaceX_API_Device_SetTrustedKeysResponse()
    }
    set {_uniqueStorage()._response = .setTrustedKeys(newValue)}
  }

  var update: SpaceX_API_Device_UpdateResponse {
    get {
      if case .update(let v)? = _storage._response {return v}
      return SpaceX_API_Device_UpdateResponse()
    }
    set {_uniqueStorage()._response = .update(newValue)}
  }

  var getLocation: SpaceX_API_Device_GetLocationResponse {
    get {
      if case .getLocation(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetLocationResponse()
    }
    set {_uniqueStorage()._response = .getLocation(newValue)}
  }

  var getHeapDump: SpaceX_API_Device_GetHeapDumpResponse {
    get {
      if case .getHeapDump(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetHeapDumpResponse()
    }
    set {_uniqueStorage()._response = .getHeapDump(newValue)}
  }

  var restartControl: SpaceX_API_Device_RestartControlResponse {
    get {
      if case .restartControl(let v)? = _storage._response {return v}
      return SpaceX_API_Device_RestartControlResponse()
    }
    set {_uniqueStorage()._response = .restartControl(newValue)}
  }

  var fuse: SpaceX_API_Device_FuseResponse {
    get {
      if case .fuse(let v)? = _storage._response {return v}
      return SpaceX_API_Device_FuseResponse()
    }
    set {_uniqueStorage()._response = .fuse(newValue)}
  }

  var getConnections: SpaceX_API_Device_GetConnectionsResponse {
    get {
      if case .getConnections(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetConnectionsResponse()
    }
    set {_uniqueStorage()._response = .getConnections(newValue)}
  }

  var startSpeedtest: SpaceX_API_Device_StartSpeedtestResponse {
    get {
      if case .startSpeedtest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_StartSpeedtestResponse()
    }
    set {_uniqueStorage()._response = .startSpeedtest(newValue)}
  }

  var getSpeedtestStatus: SpaceX_API_Device_GetSpeedtestStatusResponse {
    get {
      if case .getSpeedtestStatus(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetSpeedtestStatusResponse()
    }
    set {_uniqueStorage()._response = .getSpeedtestStatus(newValue)}
  }

  var reportClientSpeedtest: SpaceX_API_Device_ReportClientSpeedtestResponse {
    get {
      if case .reportClientSpeedtest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_ReportClientSpeedtestResponse()
    }
    set {_uniqueStorage()._response = .reportClientSpeedtest(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var initiateRemoteSsh: SpaceX_API_Device_InitiateRemoteSshResponse {
    get {
      if case .initiateRemoteSsh(let v)? = _storage._response {return v}
      return SpaceX_API_Device_InitiateRemoteSshResponse()
    }
    set {_uniqueStorage()._response = .initiateRemoteSsh(newValue)}
  }

  var selfTest: SpaceX_API_Device_SelfTestResponse {
    get {
      if case .selfTest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_SelfTestResponse()
    }
    set {_uniqueStorage()._response = .selfTest(newValue)}
  }

  var setTestMode: SpaceX_API_Device_SetTestModeResponse {
    get {
      if case .setTestMode(let v)? = _storage._response {return v}
      return SpaceX_API_Device_SetTestModeResponse()
    }
    set {_uniqueStorage()._response = .setTestMode(newValue)}
  }

  var softwareUpdate: SpaceX_API_Device_SoftwareUpdateResponse {
    get {
      if case .softwareUpdate(let v)? = _storage._response {return v}
      return SpaceX_API_Device_SoftwareUpdateResponse()
    }
    set {_uniqueStorage()._response = .softwareUpdate(newValue)}
  }

  var getRadioStats: SpaceX_API_Device_GetRadioStatsResponse {
    get {
      if case .getRadioStats(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetRadioStatsResponse()
    }
    set {_uniqueStorage()._response = .getRadioStats(newValue)}
  }

  var time: SpaceX_API_Device_GetTimeResponse {
    get {
      if case .time(let v)? = _storage._response {return v}
      return SpaceX_API_Device_GetTimeResponse()
    }
    set {_uniqueStorage()._response = .time(newValue)}
  }

  var runIperfServer: SpaceX_API_Device_RunIperfServerResponse {
    get {
      if case .runIperfServer(let v)? = _storage._response {return v}
      return SpaceX_API_Device_RunIperfServerResponse()
    }
    set {_uniqueStorage()._response = .runIperfServer(newValue)}
  }

  var dishAuthenticate: SpaceX_API_Device_DishAuthenticateResponse {
    get {
      if case .dishAuthenticate(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishAuthenticateResponse()
    }
    set {_uniqueStorage()._response = .dishAuthenticate(newValue)}
  }

  var dishGetContext: SpaceX_API_Device_DishGetContextResponse {
    get {
      if case .dishGetContext(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetContextResponse()
    }
    set {_uniqueStorage()._response = .dishGetContext(newValue)}
  }

  var dishGetHistory: SpaceX_API_Device_DishGetHistoryResponse {
    get {
      if case .dishGetHistory(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetHistoryResponse()
    }
    set {_uniqueStorage()._response = .dishGetHistory(newValue)}
  }

  var dishGetStatus: SpaceX_API_Device_DishGetStatusResponse {
    get {
      if case .dishGetStatus(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetStatusResponse()
    }
    set {_uniqueStorage()._response = .dishGetStatus(newValue)}
  }

  var dishGetObstructionMap: SpaceX_API_Device_DishGetObstructionMapResponse {
    get {
      if case .dishGetObstructionMap(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetObstructionMapResponse()
    }
    set {_uniqueStorage()._response = .dishGetObstructionMap(newValue)}
  }

  var dishStow: SpaceX_API_Device_DishStowResponse {
    get {
      if case .dishStow(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishStowResponse()
    }
    set {_uniqueStorage()._response = .dishStow(newValue)}
  }

  var startDishSelfTest: SpaceX_API_Device_StartDishSelfTestResponse {
    get {
      if case .startDishSelfTest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_StartDishSelfTestResponse()
    }
    set {_uniqueStorage()._response = .startDishSelfTest(newValue)}
  }

  var dishSetEmc: SpaceX_API_Device_DishSetEmcResponse {
    get {
      if case .dishSetEmc(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishSetEmcResponse()
    }
    set {_uniqueStorage()._response = .dishSetEmc(newValue)}
  }

  var dishGetEmc: SpaceX_API_Device_DishGetEmcResponse {
    get {
      if case .dishGetEmc(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetEmcResponse()
    }
    set {_uniqueStorage()._response = .dishGetEmc(newValue)}
  }

  var dishSetConfig: SpaceX_API_Device_DishSetConfigResponse {
    get {
      if case .dishSetConfig(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishSetConfigResponse()
    }
    set {_uniqueStorage()._response = .dishSetConfig(newValue)}
  }

  var dishGetConfig: SpaceX_API_Device_DishGetConfigResponse {
    get {
      if case .dishGetConfig(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetConfigResponse()
    }
    set {_uniqueStorage()._response = .dishGetConfig(newValue)}
  }

  var dishInhibitGps: SpaceX_API_Device_DishInhibitGpsResponse {
    get {
      if case .dishInhibitGps(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishInhibitGpsResponse()
    }
    set {_uniqueStorage()._response = .dishInhibitGps(newValue)}
  }

  var dishClearObstructionMap: SpaceX_API_Device_DishClearObstructionMapResponse {
    get {
      if case .dishClearObstructionMap(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishClearObstructionMapResponse()
    }
    set {_uniqueStorage()._response = .dishClearObstructionMap(newValue)}
  }

  var dishSetMaxPowerTestMode: SpaceX_API_Device_DishSetMaxPowerTestModeResponse {
    get {
      if case .dishSetMaxPowerTestMode(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishSetMaxPowerTestModeResponse()
    }
    set {_uniqueStorage()._response = .dishSetMaxPowerTestMode(newValue)}
  }

  var dishActivateRssiScan: SpaceX_API_Device_DishActivateRssiScanResponse {
    get {
      if case .dishActivateRssiScan(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishActivateRssiScanResponse()
    }
    set {_uniqueStorage()._response = .dishActivateRssiScan(newValue)}
  }

  var dishGetRssiScanResult: SpaceX_API_Device_DishGetRssiScanResultResponse {
    get {
      if case .dishGetRssiScanResult(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetRssiScanResultResponse()
    }
    set {_uniqueStorage()._response = .dishGetRssiScanResult(newValue)}
  }

  var dishFactoryReset: SpaceX_API_Device_DishFactoryResetResponse {
    get {
      if case .dishFactoryReset(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishFactoryResetResponse()
    }
    set {_uniqueStorage()._response = .dishFactoryReset(newValue)}
  }

  var resetButton: SpaceX_API_Device_ResetButtonResponse {
    get {
      if case .resetButton(let v)? = _storage._response {return v}
      return SpaceX_API_Device_ResetButtonResponse()
    }
    set {_uniqueStorage()._response = .resetButton(newValue)}
  }

  var wifiAuthenticate: SpaceX_API_Device_WifiAuthenticateResponse {
    get {
      if case .wifiAuthenticate(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiAuthenticateResponse()
    }
    set {_uniqueStorage()._response = .wifiAuthenticate(newValue)}
  }

  var wifiGetClients: SpaceX_API_Device_WifiGetClientsResponse {
    get {
      if case .wifiGetClients(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetClientsResponse()
    }
    set {_uniqueStorage()._response = .wifiGetClients(newValue)}
  }

  var wifiGetHistory: SpaceX_API_Device_WifiGetHistoryResponse {
    get {
      if case .wifiGetHistory(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetHistoryResponse()
    }
    set {_uniqueStorage()._response = .wifiGetHistory(newValue)}
  }

  var wifiGetPingMetrics: SpaceX_API_Device_WifiGetPingMetricsResponse {
    get {
      if case .wifiGetPingMetrics(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetPingMetricsResponse()
    }
    set {_uniqueStorage()._response = .wifiGetPingMetrics(newValue)}
  }

  var wifiGetStatus: SpaceX_API_Device_WifiGetStatusResponse {
    get {
      if case .wifiGetStatus(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetStatusResponse()
    }
    set {_uniqueStorage()._response = .wifiGetStatus(newValue)}
  }

  var wifiSetConfig: SpaceX_API_Device_WifiSetConfigResponse {
    get {
      if case .wifiSetConfig(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiSetConfigResponse()
    }
    set {_uniqueStorage()._response = .wifiSetConfig(newValue)}
  }

  var wifiGetConfig: SpaceX_API_Device_WifiGetConfigResponse {
    get {
      if case .wifiGetConfig(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetConfigResponse()
    }
    set {_uniqueStorage()._response = .wifiGetConfig(newValue)}
  }

  var wifiSetup: SpaceX_API_Device_WifiSetupResponse {
    get {
      if case .wifiSetup(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiSetupResponse()
    }
    set {_uniqueStorage()._response = .wifiSetup(newValue)}
  }

  var wifiGetPersistentStats: SpaceX_API_Device_WifiGetPersistentStatsResponse {
    get {
      if case .wifiGetPersistentStats(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetPersistentStatsResponse()
    }
    set {_uniqueStorage()._response = .wifiGetPersistentStats(newValue)}
  }

  var wifiSetMeshDeviceTrust: SpaceX_API_Device_WifiSetMeshDeviceTrustResponse {
    get {
      if case .wifiSetMeshDeviceTrust(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiSetMeshDeviceTrustResponse()
    }
    set {_uniqueStorage()._response = .wifiSetMeshDeviceTrust(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var wifiSetMeshConfig: SpaceX_API_Device_WifiSetMeshConfigResponse {
    get {
      if case .wifiSetMeshConfig(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiSetMeshConfigResponse()
    }
    set {_uniqueStorage()._response = .wifiSetMeshConfig(newValue)}
  }

  var wifiGetClientHistory: SpaceX_API_Device_WifiGetClientHistoryResponse {
    get {
      if case .wifiGetClientHistory(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetClientHistoryResponse()
    }
    set {_uniqueStorage()._response = .wifiGetClientHistory(newValue)}
  }

  var wifiSelfTest: SpaceX_API_Device_WifiSelfTestResponse {
    get {
      if case .wifiSelfTest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiSelfTestResponse()
    }
    set {_uniqueStorage()._response = .wifiSelfTest(newValue)}
  }

  var wifiGuestInfo: SpaceX_API_Device_WifiGuestInfoResponse {
    get {
      if case .wifiGuestInfo(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGuestInfoResponse()
    }
    set {_uniqueStorage()._response = .wifiGuestInfo(newValue)}
  }

  var wifiRfTest: SpaceX_API_Device_WifiRfTestResponse {
    get {
      if case .wifiRfTest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiRfTestResponse()
    }
    set {_uniqueStorage()._response = .wifiRfTest(newValue)}
  }

  var wifiGetFirewall: SpaceX_API_Device_WifiGetFirewallResponse {
    get {
      if case .wifiGetFirewall(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetFirewallResponse()
    }
    set {_uniqueStorage()._response = .wifiGetFirewall(newValue)}
  }

  var wifiFactoryTestCommand: SpaceX_API_Device_WifiFactoryTestCommandResponse {
    get {
      if case .wifiFactoryTestCommand(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiFactoryTestCommandResponse()
    }
    set {_uniqueStorage()._response = .wifiFactoryTestCommand(newValue)}
  }

  var wifiBackhaulStats: SpaceX_API_Device_WifiBackhaulStatsResponse {
    get {
      if case .wifiBackhaulStats(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiBackhaulStatsResponse()
    }
    set {_uniqueStorage()._response = .wifiBackhaulStats(newValue)}
  }

  var transceiverIfLoopbackTest: SpaceX_API_Device_TransceiverIFLoopbackTestResponse {
    get {
      if case .transceiverIfLoopbackTest(let v)? = _storage._response {return v}
      return SpaceX_API_Device_TransceiverIFLoopbackTestResponse()
    }
    set {_uniqueStorage()._response = .transceiverIfLoopbackTest(newValue)}
  }

  var transceiverGetStatus: SpaceX_API_Device_TransceiverGetStatusResponse {
    get {
      if case .transceiverGetStatus(let v)? = _storage._response {return v}
      return SpaceX_API_Device_TransceiverGetStatusResponse()
    }
    set {_uniqueStorage()._response = .transceiverGetStatus(newValue)}
  }

  var transceiverGetTelemetry: SpaceX_API_Device_TransceiverGetTelemetryResponse {
    get {
      if case .transceiverGetTelemetry(let v)? = _storage._response {return v}
      return SpaceX_API_Device_TransceiverGetTelemetryResponse()
    }
    set {_uniqueStorage()._response = .transceiverGetTelemetry(newValue)}
  }

  var startUnlock: SpaceX_API_Device_Services_Unlock_StartUnlockResponse {
    get {
      if case .startUnlock(let v)? = _storage._response {return v}
      return SpaceX_API_Device_Services_Unlock_StartUnlockResponse()
    }
    set {_uniqueStorage()._response = .startUnlock(newValue)}
  }

  var finishUnlock: SpaceX_API_Device_Services_Unlock_FinishUnlockResponse {
    get {
      if case .finishUnlock(let v)? = _storage._response {return v}
      return SpaceX_API_Device_Services_Unlock_FinishUnlockResponse()
    }
    set {_uniqueStorage()._response = .finishUnlock(newValue)}
  }

  var wifiGetDiagnostics: SpaceX_API_Device_WifiGetDiagnosticsResponse {
    get {
      if case .wifiGetDiagnostics(let v)? = _storage._response {return v}
      return SpaceX_API_Device_WifiGetDiagnosticsResponse()
    }
    set {_uniqueStorage()._response = .wifiGetDiagnostics(newValue)}
  }

  var dishGetDiagnostics: SpaceX_API_Device_DishGetDiagnosticsResponse {
    get {
      if case .dishGetDiagnostics(let v)? = _storage._response {return v}
      return SpaceX_API_Device_DishGetDiagnosticsResponse()
    }
    set {_uniqueStorage()._response = .dishGetDiagnostics(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case getNextID(SpaceX_API_Device_GetNextIdResponse)
    case enableDebugTelem(SpaceX_API_Device_EnableDebugTelemResponse)
    case factoryReset(SpaceX_API_Device_FactoryResetResponse)
    case getDeviceInfo(SpaceX_API_Device_GetDeviceInfoResponse)
    case getLog(SpaceX_API_Device_GetLogResponse)
    case getNetworkInterfaces(SpaceX_API_Device_GetNetworkInterfacesResponse)
    case getPing(SpaceX_API_Device_GetPingResponse)
    case pingHost(SpaceX_API_Device_PingHostResponse)
    case reboot(SpaceX_API_Device_RebootResponse)
    case speedTest(SpaceX_API_Device_SpeedTestResponse)
    case setSku(SpaceX_API_Device_SetSkuResponse)
    case setTrustedKeys(SpaceX_API_Device_SetTrustedKeysResponse)
    case update(SpaceX_API_Device_UpdateResponse)
    case getLocation(SpaceX_API_Device_GetLocationResponse)
    case getHeapDump(SpaceX_API_Device_GetHeapDumpResponse)
    case restartControl(SpaceX_API_Device_RestartControlResponse)
    case fuse(SpaceX_API_Device_FuseResponse)
    case getConnections(SpaceX_API_Device_GetConnectionsResponse)
    case startSpeedtest(SpaceX_API_Device_StartSpeedtestResponse)
    case getSpeedtestStatus(SpaceX_API_Device_GetSpeedtestStatusResponse)
    case reportClientSpeedtest(SpaceX_API_Device_ReportClientSpeedtestResponse)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case initiateRemoteSsh(SpaceX_API_Device_InitiateRemoteSshResponse)
    case selfTest(SpaceX_API_Device_SelfTestResponse)
    case setTestMode(SpaceX_API_Device_SetTestModeResponse)
    case softwareUpdate(SpaceX_API_Device_SoftwareUpdateResponse)
    case getRadioStats(SpaceX_API_Device_GetRadioStatsResponse)
    case time(SpaceX_API_Device_GetTimeResponse)
    case runIperfServer(SpaceX_API_Device_RunIperfServerResponse)
    case dishAuthenticate(SpaceX_API_Device_DishAuthenticateResponse)
    case dishGetContext(SpaceX_API_Device_DishGetContextResponse)
    case dishGetHistory(SpaceX_API_Device_DishGetHistoryResponse)
    case dishGetStatus(SpaceX_API_Device_DishGetStatusResponse)
    case dishGetObstructionMap(SpaceX_API_Device_DishGetObstructionMapResponse)
    case dishStow(SpaceX_API_Device_DishStowResponse)
    case startDishSelfTest(SpaceX_API_Device_StartDishSelfTestResponse)
    case dishSetEmc(SpaceX_API_Device_DishSetEmcResponse)
    case dishGetEmc(SpaceX_API_Device_DishGetEmcResponse)
    case dishSetConfig(SpaceX_API_Device_DishSetConfigResponse)
    case dishGetConfig(SpaceX_API_Device_DishGetConfigResponse)
    case dishInhibitGps(SpaceX_API_Device_DishInhibitGpsResponse)
    case dishClearObstructionMap(SpaceX_API_Device_DishClearObstructionMapResponse)
    case dishSetMaxPowerTestMode(SpaceX_API_Device_DishSetMaxPowerTestModeResponse)
    case dishActivateRssiScan(SpaceX_API_Device_DishActivateRssiScanResponse)
    case dishGetRssiScanResult(SpaceX_API_Device_DishGetRssiScanResultResponse)
    case dishFactoryReset(SpaceX_API_Device_DishFactoryResetResponse)
    case resetButton(SpaceX_API_Device_ResetButtonResponse)
    case wifiAuthenticate(SpaceX_API_Device_WifiAuthenticateResponse)
    case wifiGetClients(SpaceX_API_Device_WifiGetClientsResponse)
    case wifiGetHistory(SpaceX_API_Device_WifiGetHistoryResponse)
    case wifiGetPingMetrics(SpaceX_API_Device_WifiGetPingMetricsResponse)
    case wifiGetStatus(SpaceX_API_Device_WifiGetStatusResponse)
    case wifiSetConfig(SpaceX_API_Device_WifiSetConfigResponse)
    case wifiGetConfig(SpaceX_API_Device_WifiGetConfigResponse)
    case wifiSetup(SpaceX_API_Device_WifiSetupResponse)
    case wifiGetPersistentStats(SpaceX_API_Device_WifiGetPersistentStatsResponse)
    case wifiSetMeshDeviceTrust(SpaceX_API_Device_WifiSetMeshDeviceTrustResponse)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case wifiSetMeshConfig(SpaceX_API_Device_WifiSetMeshConfigResponse)
    case wifiGetClientHistory(SpaceX_API_Device_WifiGetClientHistoryResponse)
    case wifiSelfTest(SpaceX_API_Device_WifiSelfTestResponse)
    case wifiGuestInfo(SpaceX_API_Device_WifiGuestInfoResponse)
    case wifiRfTest(SpaceX_API_Device_WifiRfTestResponse)
    case wifiGetFirewall(SpaceX_API_Device_WifiGetFirewallResponse)
    case wifiFactoryTestCommand(SpaceX_API_Device_WifiFactoryTestCommandResponse)
    case wifiBackhaulStats(SpaceX_API_Device_WifiBackhaulStatsResponse)
    case transceiverIfLoopbackTest(SpaceX_API_Device_TransceiverIFLoopbackTestResponse)
    case transceiverGetStatus(SpaceX_API_Device_TransceiverGetStatusResponse)
    case transceiverGetTelemetry(SpaceX_API_Device_TransceiverGetTelemetryResponse)
    case startUnlock(SpaceX_API_Device_Services_Unlock_StartUnlockResponse)
    case finishUnlock(SpaceX_API_Device_Services_Unlock_FinishUnlockResponse)
    case wifiGetDiagnostics(SpaceX_API_Device_WifiGetDiagnosticsResponse)
    case dishGetDiagnostics(SpaceX_API_Device_DishGetDiagnosticsResponse)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_Event: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: SpaceX_API_Device_Event.OneOf_Event? = nil

  var wifiNewClientConnected: SpaceX_API_Device_WifiNewClientConnectedEvent {
    get {
      if case .wifiNewClientConnected(let v)? = event {return v}
      return SpaceX_API_Device_WifiNewClientConnectedEvent()
    }
    set {event = .wifiNewClientConnected(newValue)}
  }

  var wifiAccountBonding: SpaceX_API_Device_WifiAccountBondingEvent {
    get {
      if case .wifiAccountBonding(let v)? = event {return v}
      return SpaceX_API_Device_WifiAccountBondingEvent()
    }
    set {event = .wifiAccountBonding(newValue)}
  }

  var wifiNewPeer: SpaceX_API_Device_WifiNewPeerEvent {
    get {
      if case .wifiNewPeer(let v)? = event {return v}
      return SpaceX_API_Device_WifiNewPeerEvent()
    }
    set {event = .wifiNewPeer(newValue)}
  }

  var wifiCloudStatus: SpaceX_API_Device_WifiCloudStatusEvent {
    get {
      if case .wifiCloudStatus(let v)? = event {return v}
      return SpaceX_API_Device_WifiCloudStatusEvent()
    }
    set {event = .wifiCloudStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case wifiNewClientConnected(SpaceX_API_Device_WifiNewClientConnectedEvent)
    case wifiAccountBonding(SpaceX_API_Device_WifiAccountBondingEvent)
    case wifiNewPeer(SpaceX_API_Device_WifiNewPeerEvent)
    case wifiCloudStatus(SpaceX_API_Device_WifiCloudStatusEvent)

  }

  init() {}
}

struct SpaceX_API_Device_WifiCloudStatusEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var apiVersion: UInt32 = 0

  var directLinkToDish: Bool = false

  var hardwareVersion: String = String()

  var isBypassed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_EnableDebugTelemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durationM: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_EnableDebugTelemResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_FactoryResetRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_FactoryResetResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetTimeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetTimeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unixNano: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_FuseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preventReboot: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_FuseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetLogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetLogResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var current: SpaceX_API_Device_GetLogResponse.Logs {
    get {return _current ?? SpaceX_API_Device_GetLogResponse.Logs()}
    set {_current = newValue}
  }
  /// Returns true if `current` has been explicitly set.
  var hasCurrent: Bool {return self._current != nil}
  /// Clears the value of `current`. Subsequent reads from it will return its default value.
  mutating func clearCurrent() {self._current = nil}

  var saved: SpaceX_API_Device_GetLogResponse.Logs {
    get {return _saved ?? SpaceX_API_Device_GetLogResponse.Logs()}
    set {_saved = newValue}
  }
  /// Returns true if `saved` has been explicitly set.
  var hasSaved: Bool {return self._saved != nil}
  /// Clears the value of `saved`. Subsequent reads from it will return its default value.
  mutating func clearSaved() {self._saved = nil}

  /// NOTE: This field was marked as deprecated in the .proto file.
  var syslog: String = String()

  /// NOTE: This field was marked as deprecated in the .proto file.
  var offlineLog: String = String()

  /// NOTE: This field was marked as deprecated in the .proto file.
  var persistentLog: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Logs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var syslog: String = String()

    var dmesg: String = String()

    var kernelPanic: String = String()

    var mtkEthProcs: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _current: SpaceX_API_Device_GetLogResponse.Logs? = nil
  fileprivate var _saved: SpaceX_API_Device_GetLogResponse.Logs? = nil
}

struct SpaceX_API_Device_GetPingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetPingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var results: Dictionary<String,SpaceX_API_Device_PingResult> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_PingHostRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: String = String()

  var size: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_PingHostResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: SpaceX_API_Device_PingResult {
    get {return _result ?? SpaceX_API_Device_PingResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: SpaceX_API_Device_PingResult? = nil
}

struct SpaceX_API_Device_GetStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_RebootRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_RebootResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SpeedTestStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var latencyMs: Float = 0

  /// NOTE: This field was marked as deprecated in the .proto file.
  var startTime: UInt64 = 0

  var uploadStartTime: Int64 = 0

  var downloadStartTime: Int64 = 0

  var uploadMbps: Float = 0

  var downloadMbps: Float = 0

  var target: SpaceX_API_Device_SpeedTestStats.Target = .unknown

  var tcpStreams: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Target: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case fastcom // = 1
    case cloudflare // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .fastcom
      case 2: self = .cloudflare
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .fastcom: return 1
      case .cloudflare: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_SpeedTestStats.Target] = [
      .unknown,
      .fastcom,
      .cloudflare,
    ]

  }

  init() {}
}

struct SpaceX_API_Device_ClientPlatform: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: SpaceX_API_Device_ClientPlatform.Platform = .unknown

  var majorVersion: Float = 0

  var minorVersion: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Platform: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case ios // = 1
    case android // = 2
    case web // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ios
      case 2: self = .android
      case 3: self = .web
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ios: return 1
      case .android: return 2
      case .web: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_ClientPlatform.Platform] = [
      .unknown,
      .ios,
      .android,
      .web,
    ]

  }

  init() {}
}

struct SpaceX_API_Device_SpeedTestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var clientSpeedtest: SpaceX_API_Device_SpeedTestStats {
    get {return _clientSpeedtest ?? SpaceX_API_Device_SpeedTestStats()}
    set {_clientSpeedtest = newValue}
  }
  /// Returns true if `clientSpeedtest` has been explicitly set.
  var hasClientSpeedtest: Bool {return self._clientSpeedtest != nil}
  /// Clears the value of `clientSpeedtest`. Subsequent reads from it will return its default value.
  mutating func clearClientSpeedtest() {self._clientSpeedtest = nil}

  var clientRssi: Float = 0

  var clientPlatform: SpaceX_API_Device_ClientPlatform {
    get {return _clientPlatform ?? SpaceX_API_Device_ClientPlatform()}
    set {_clientPlatform = newValue}
  }
  /// Returns true if `clientPlatform` has been explicitly set.
  var hasClientPlatform: Bool {return self._clientPlatform != nil}
  /// Clears the value of `clientPlatform`. Subsequent reads from it will return its default value.
  mutating func clearClientPlatform() {self._clientPlatform = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _clientSpeedtest: SpaceX_API_Device_SpeedTestStats? = nil
  fileprivate var _clientPlatform: SpaceX_API_Device_ClientPlatform? = nil
}

struct SpaceX_API_Device_SpeedTestResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NOTE: This field was marked as deprecated in the .proto file.
  var downloadBps: Float {
    get {return _storage._downloadBps}
    set {_uniqueStorage()._downloadBps = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var uploadBps: Float {
    get {return _storage._uploadBps}
    set {_uniqueStorage()._uploadBps = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var latencyS: Float {
    get {return _storage._latencyS}
    set {_uniqueStorage()._latencyS = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var downloadMbps: Float {
    get {return _storage._downloadMbps}
    set {_uniqueStorage()._downloadMbps = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var uploadMbps: Float {
    get {return _storage._uploadMbps}
    set {_uniqueStorage()._uploadMbps = newValue}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  var latencyMs: Float {
    get {return _storage._latencyMs}
    set {_uniqueStorage()._latencyMs = newValue}
  }

  var routerSpeedtest: SpaceX_API_Device_SpeedTestStats {
    get {return _storage._routerSpeedtest ?? SpaceX_API_Device_SpeedTestStats()}
    set {_uniqueStorage()._routerSpeedtest = newValue}
  }
  /// Returns true if `routerSpeedtest` has been explicitly set.
  var hasRouterSpeedtest: Bool {return _storage._routerSpeedtest != nil}
  /// Clears the value of `routerSpeedtest`. Subsequent reads from it will return its default value.
  mutating func clearRouterSpeedtest() {_uniqueStorage()._routerSpeedtest = nil}

  var downloadMbps1TcpConn: Float {
    get {return _storage._downloadMbps1TcpConn}
    set {_uniqueStorage()._downloadMbps1TcpConn = newValue}
  }

  var uploadMbps1TcpConn: Float {
    get {return _storage._uploadMbps1TcpConn}
    set {_uniqueStorage()._uploadMbps1TcpConn = newValue}
  }

  var downloadMbps4TcpConn: Float {
    get {return _storage._downloadMbps4TcpConn}
    set {_uniqueStorage()._downloadMbps4TcpConn = newValue}
  }

  var uploadMbps4TcpConn: Float {
    get {return _storage._uploadMbps4TcpConn}
    set {_uniqueStorage()._uploadMbps4TcpConn = newValue}
  }

  var downloadMbps16TcpConn: Float {
    get {return _storage._downloadMbps16TcpConn}
    set {_uniqueStorage()._downloadMbps16TcpConn = newValue}
  }

  var uploadMbps16TcpConn: Float {
    get {return _storage._uploadMbps16TcpConn}
    set {_uniqueStorage()._uploadMbps16TcpConn = newValue}
  }

  var downloadMbps64TcpConn: Float {
    get {return _storage._downloadMbps64TcpConn}
    set {_uniqueStorage()._downloadMbps64TcpConn = newValue}
  }

  var uploadMbps64TcpConn: Float {
    get {return _storage._uploadMbps64TcpConn}
    set {_uniqueStorage()._uploadMbps64TcpConn = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_RunIperfServerRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durationS: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_RunIperfServerResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var port: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetConnectionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetConnectionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var services: Dictionary<String,SpaceX_API_Device_GetConnectionsResponse.ServiceConnection> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ServiceConnection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: String = String()

    var secondsSinceSuccess: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct SpaceX_API_Device_GetDeviceInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetDeviceInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceInfo: SpaceX_API_Device_DeviceInfo {
    get {return _deviceInfo ?? SpaceX_API_Device_DeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  mutating func clearDeviceInfo() {self._deviceInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceInfo: SpaceX_API_Device_DeviceInfo? = nil
}

struct SpaceX_API_Device_SetTrustedKeysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: [SpaceX_API_Device_PublicKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SetTrustedKeysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SetSkuRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sku: String = String()

  var countryCode: String = String()

  var applyCountryCode: Bool = false

  var pinCountryCode: Bool = false

  var customPowerTable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SetSkuResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_UpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_UpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_RestartControlRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_RestartControlResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetNetworkInterfacesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetNetworkInterfacesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkInterfaces: [SpaceX_API_Device_NetworkInterface] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetRadioStatsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetRadioStatsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var radioStats: [SpaceX_API_Device_RadioStats] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetHeapDumpRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetHeapDumpResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var heapDump: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetLocationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: SpaceX_API_Device_PositionSource = .auto

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetLocationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lla: SpaceX_API_Device_LLAPosition {
    get {return _lla ?? SpaceX_API_Device_LLAPosition()}
    set {_lla = newValue}
  }
  /// Returns true if `lla` has been explicitly set.
  var hasLla: Bool {return self._lla != nil}
  /// Clears the value of `lla`. Subsequent reads from it will return its default value.
  mutating func clearLla() {self._lla = nil}

  var sigmaM: Double = 0

  var source: SpaceX_API_Device_PositionSource = .auto

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lla: SpaceX_API_Device_LLAPosition? = nil
}

struct SpaceX_API_Device_DishSetEmcRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var theta: Double {
    get {return _storage._theta}
    set {_uniqueStorage()._theta = newValue}
  }

  var phi: Double {
    get {return _storage._phi}
    set {_uniqueStorage()._phi = newValue}
  }

  var rxChan: UInt32 {
    get {return _storage._rxChan}
    set {_uniqueStorage()._rxChan = newValue}
  }

  var txChan: UInt32 {
    get {return _storage._txChan}
    set {_uniqueStorage()._txChan = newValue}
  }

  var modulation: UInt32 {
    get {return _storage._modulation}
    set {_uniqueStorage()._modulation = newValue}
  }

  var desiredTiltAngle: Double {
    get {return _storage._desiredTiltAngle}
    set {_uniqueStorage()._desiredTiltAngle = newValue}
  }

  var chanOverride: Bool {
    get {return _storage._chanOverride}
    set {_uniqueStorage()._chanOverride = newValue}
  }

  var thetaEnabled: Bool {
    get {return _storage._thetaEnabled}
    set {_uniqueStorage()._thetaEnabled = newValue}
  }

  var phiEnabled: Bool {
    get {return _storage._phiEnabled}
    set {_uniqueStorage()._phiEnabled = newValue}
  }

  var idle: Bool {
    get {return _storage._idle}
    set {_uniqueStorage()._idle = newValue}
  }

  var fastSwitching: Bool {
    get {return _storage._fastSwitching}
    set {_uniqueStorage()._fastSwitching = newValue}
  }

  var skySearch: Bool {
    get {return _storage._skySearch}
    set {_uniqueStorage()._skySearch = newValue}
  }

  var forcePllUnlock: Bool {
    get {return _storage._forcePllUnlock}
    set {_uniqueStorage()._forcePllUnlock = newValue}
  }

  var forceEirpFailure: Bool {
    get {return _storage._forceEirpFailure}
    set {_uniqueStorage()._forceEirpFailure = newValue}
  }

  var snowActiveOverride: Bool {
    get {return _storage._snowActiveOverride}
    set {_uniqueStorage()._snowActiveOverride = newValue}
  }

  var manualTilting: Bool {
    get {return _storage._manualTilting}
    set {_uniqueStorage()._manualTilting = newValue}
  }

  var tiltToStowed: Bool {
    get {return _storage._tiltToStowed}
    set {_uniqueStorage()._tiltToStowed = newValue}
  }

  var reboot: Bool {
    get {return _storage._reboot}
    set {_uniqueStorage()._reboot = newValue}
  }

  var continuousMotorTest: Bool {
    get {return _storage._continuousMotorTest}
    set {_uniqueStorage()._continuousMotorTest = newValue}
  }

  var distanceOverrideMeters: Double {
    get {return _storage._distanceOverrideMeters}
    set {_uniqueStorage()._distanceOverrideMeters = newValue}
  }

  var amplitudeTaperOverride: UInt32 {
    get {return _storage._amplitudeTaperOverride}
    set {_uniqueStorage()._amplitudeTaperOverride = newValue}
  }

  var countryCodeOverride: UInt32 {
    get {return _storage._countryCodeOverride}
    set {_uniqueStorage()._countryCodeOverride = newValue}
  }

  var txDutyCycleOverride: Int32 {
    get {return _storage._txDutyCycleOverride}
    set {_uniqueStorage()._txDutyCycleOverride = newValue}
  }

  var rxDutyCycleOverride: Int32 {
    get {return _storage._rxDutyCycleOverride}
    set {_uniqueStorage()._rxDutyCycleOverride = newValue}
  }

  var eirpLegalLimitDbwOverride: Double {
    get {return _storage._eirpLegalLimitDbwOverride}
    set {_uniqueStorage()._eirpLegalLimitDbwOverride = newValue}
  }

  var eirpAdjustmentDb: Double {
    get {return _storage._eirpAdjustmentDb}
    set {_uniqueStorage()._eirpAdjustmentDb = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_DishSetEmcResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishSetMaxPowerTestModeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishSetMaxPowerTestModeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetEmcRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishGetEmcResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var timestamp: UInt64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var cplaneUpdates: UInt32 {
    get {return _storage._cplaneUpdates}
    set {_uniqueStorage()._cplaneUpdates = newValue}
  }

  var gpsLatitude: Double {
    get {return _storage._gpsLatitude}
    set {_uniqueStorage()._gpsLatitude = newValue}
  }

  var gpsLongitude: Double {
    get {return _storage._gpsLongitude}
    set {_uniqueStorage()._gpsLongitude = newValue}
  }

  var gpsPdop: Double {
    get {return _storage._gpsPdop}
    set {_uniqueStorage()._gpsPdop = newValue}
  }

  var rfMode: UInt32 {
    get {return _storage._rfMode}
    set {_uniqueStorage()._rfMode = newValue}
  }

  var phi: Double {
    get {return _storage._phi}
    set {_uniqueStorage()._phi = newValue}
  }

  var theta: Double {
    get {return _storage._theta}
    set {_uniqueStorage()._theta = newValue}
  }

  var rxChannel: UInt32 {
    get {return _storage._rxChannel}
    set {_uniqueStorage()._rxChannel = newValue}
  }

  var txChannel: UInt32 {
    get {return _storage._txChannel}
    set {_uniqueStorage()._txChannel = newValue}
  }

  var tDbfMax: Float {
    get {return _storage._tDbfMax}
    set {_uniqueStorage()._tDbfMax = newValue}
  }

  var tCenter: Double {
    get {return _storage._tCenter}
    set {_uniqueStorage()._tCenter = newValue}
  }

  var autoPowerSnowMeltEnabled: Bool {
    get {return _storage._autoPowerSnowMeltEnabled}
    set {_uniqueStorage()._autoPowerSnowMeltEnabled = newValue}
  }

  var voltage: Double {
    get {return _storage._voltage}
    set {_uniqueStorage()._voltage = newValue}
  }

  var rxBeamState: UInt32 {
    get {return _storage._rxBeamState}
    set {_uniqueStorage()._rxBeamState = newValue}
  }

  var txBeamState: UInt32 {
    get {return _storage._txBeamState}
    set {_uniqueStorage()._txBeamState = newValue}
  }

  var halfDuplexState: UInt32 {
    get {return _storage._halfDuplexState}
    set {_uniqueStorage()._halfDuplexState = newValue}
  }

  var manualTiltEnabled: Bool {
    get {return _storage._manualTiltEnabled}
    set {_uniqueStorage()._manualTiltEnabled = newValue}
  }

  var tiltAngle: Double {
    get {return _storage._tiltAngle}
    set {_uniqueStorage()._tiltAngle = newValue}
  }

  var pllTxLockDetected: UInt32 {
    get {return _storage._pllTxLockDetected}
    set {_uniqueStorage()._pllTxLockDetected = newValue}
  }

  var eirpExceededThreshold: Bool {
    get {return _storage._eirpExceededThreshold}
    set {_uniqueStorage()._eirpExceededThreshold = newValue}
  }

  var idleOverrideEnabled: Bool {
    get {return _storage._idleOverrideEnabled}
    set {_uniqueStorage()._idleOverrideEnabled = newValue}
  }

  var thetaOverrideEnabled: Bool {
    get {return _storage._thetaOverrideEnabled}
    set {_uniqueStorage()._thetaOverrideEnabled = newValue}
  }

  var thetaOverrideValue: Double {
    get {return _storage._thetaOverrideValue}
    set {_uniqueStorage()._thetaOverrideValue = newValue}
  }

  var phiOverrideEnabled: Bool {
    get {return _storage._phiOverrideEnabled}
    set {_uniqueStorage()._phiOverrideEnabled = newValue}
  }

  var phiOverrideValue: Double {
    get {return _storage._phiOverrideValue}
    set {_uniqueStorage()._phiOverrideValue = newValue}
  }

  var rxChanOverrideValue: UInt32 {
    get {return _storage._rxChanOverrideValue}
    set {_uniqueStorage()._rxChanOverrideValue = newValue}
  }

  var txChanOverrideValue: UInt32 {
    get {return _storage._txChanOverrideValue}
    set {_uniqueStorage()._txChanOverrideValue = newValue}
  }

  var skySearchOverrideEnabled: Bool {
    get {return _storage._skySearchOverrideEnabled}
    set {_uniqueStorage()._skySearchOverrideEnabled = newValue}
  }

  var fastSwitchingEnabled: Bool {
    get {return _storage._fastSwitchingEnabled}
    set {_uniqueStorage()._fastSwitchingEnabled = newValue}
  }

  var modulationOverrideValue: UInt32 {
    get {return _storage._modulationOverrideValue}
    set {_uniqueStorage()._modulationOverrideValue = newValue}
  }

  var forceEirpFailure: Bool {
    get {return _storage._forceEirpFailure}
    set {_uniqueStorage()._forceEirpFailure = newValue}
  }

  var forcePllUnlock: Bool {
    get {return _storage._forcePllUnlock}
    set {_uniqueStorage()._forcePllUnlock = newValue}
  }

  var utIneSuccess: UInt32 {
    get {return _storage._utIneSuccess}
    set {_uniqueStorage()._utIneSuccess = newValue}
  }

  var rfReady: Bool {
    get {return _storage._rfReady}
    set {_uniqueStorage()._rfReady = newValue}
  }

  var tiltToStowed: Bool {
    get {return _storage._tiltToStowed}
    set {_uniqueStorage()._tiltToStowed = newValue}
  }

  var reboot: Bool {
    get {return _storage._reboot}
    set {_uniqueStorage()._reboot = newValue}
  }

  var continuousMotorTest: Bool {
    get {return _storage._continuousMotorTest}
    set {_uniqueStorage()._continuousMotorTest = newValue}
  }

  var distanceOverrideMeters: Double {
    get {return _storage._distanceOverrideMeters}
    set {_uniqueStorage()._distanceOverrideMeters = newValue}
  }

  var amplitudeTaperOverride: UInt32 {
    get {return _storage._amplitudeTaperOverride}
    set {_uniqueStorage()._amplitudeTaperOverride = newValue}
  }

  var amplitudeTaperEnabled: Bool {
    get {return _storage._amplitudeTaperEnabled}
    set {_uniqueStorage()._amplitudeTaperEnabled = newValue}
  }

  var amplitudeTaperScale: Double {
    get {return _storage._amplitudeTaperScale}
    set {_uniqueStorage()._amplitudeTaperScale = newValue}
  }

  var countryCodeOverride: UInt32 {
    get {return _storage._countryCodeOverride}
    set {_uniqueStorage()._countryCodeOverride = newValue}
  }

  var maxPointingDistance: Double {
    get {return _storage._maxPointingDistance}
    set {_uniqueStorage()._maxPointingDistance = newValue}
  }

  var distanceScalingFactor: Double {
    get {return _storage._distanceScalingFactor}
    set {_uniqueStorage()._distanceScalingFactor = newValue}
  }

  var txDutyCycleOverride: Int32 {
    get {return _storage._txDutyCycleOverride}
    set {_uniqueStorage()._txDutyCycleOverride = newValue}
  }

  var rxDutyCycleOverride: Int32 {
    get {return _storage._rxDutyCycleOverride}
    set {_uniqueStorage()._rxDutyCycleOverride = newValue}
  }

  var txTimeMs: Float {
    get {return _storage._txTimeMs}
    set {_uniqueStorage()._txTimeMs = newValue}
  }

  var rxTimeMs: Float {
    get {return _storage._rxTimeMs}
    set {_uniqueStorage()._rxTimeMs = newValue}
  }

  var eirpLegalLimitDbw: Double {
    get {return _storage._eirpLegalLimitDbw}
    set {_uniqueStorage()._eirpLegalLimitDbw = newValue}
  }

  var eirpLegalLimitDbwOverride: Double {
    get {return _storage._eirpLegalLimitDbwOverride}
    set {_uniqueStorage()._eirpLegalLimitDbwOverride = newValue}
  }

  var eirpAdjustmentDb: Double {
    get {return _storage._eirpAdjustmentDb}
    set {_uniqueStorage()._eirpAdjustmentDb = newValue}
  }

  var eirpPredictedDbw: Double {
    get {return _storage._eirpPredictedDbw}
    set {_uniqueStorage()._eirpPredictedDbw = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_GetPersistentStatsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_StartSpeedtestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_StartSpeedtestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_SpeedtestStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var running: Bool = false

  var id: UInt32 = 0

  var up: SpaceX_API_Device_SpeedtestStatus.Direction {
    get {return _up ?? SpaceX_API_Device_SpeedtestStatus.Direction()}
    set {_up = newValue}
  }
  /// Returns true if `up` has been explicitly set.
  var hasUp: Bool {return self._up != nil}
  /// Clears the value of `up`. Subsequent reads from it will return its default value.
  mutating func clearUp() {self._up = nil}

  var down: SpaceX_API_Device_SpeedtestStatus.Direction {
    get {return _down ?? SpaceX_API_Device_SpeedtestStatus.Direction()}
    set {_down = newValue}
  }
  /// Returns true if `down` has been explicitly set.
  var hasDown: Bool {return self._down != nil}
  /// Clears the value of `down`. Subsequent reads from it will return its default value.
  mutating func clearDown() {self._down = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Direction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var throughputsMbps: [Float] = []

    var err: SpaceX_API_Device_SpeedtestError = .none

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _up: SpaceX_API_Device_SpeedtestStatus.Direction? = nil
  fileprivate var _down: SpaceX_API_Device_SpeedtestStatus.Direction? = nil
}

struct SpaceX_API_Device_GetSpeedtestStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetSpeedtestStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: SpaceX_API_Device_SpeedtestStatus {
    get {return _status ?? SpaceX_API_Device_SpeedtestStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: SpaceX_API_Device_SpeedtestStatus? = nil
}

struct SpaceX_API_Device_ReportClientSpeedtestRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var clientSpeedtest: SpaceX_API_Device_SpeedTestStats {
    get {return _storage._clientSpeedtest ?? SpaceX_API_Device_SpeedTestStats()}
    set {_uniqueStorage()._clientSpeedtest = newValue}
  }
  /// Returns true if `clientSpeedtest` has been explicitly set.
  var hasClientSpeedtest: Bool {return _storage._clientSpeedtest != nil}
  /// Clears the value of `clientSpeedtest`. Subsequent reads from it will return its default value.
  mutating func clearClientSpeedtest() {_uniqueStorage()._clientSpeedtest = nil}

  var wifiSpeedtest: SpaceX_API_Device_SpeedTestStats {
    get {return _storage._wifiSpeedtest ?? SpaceX_API_Device_SpeedTestStats()}
    set {_uniqueStorage()._wifiSpeedtest = newValue}
  }
  /// Returns true if `wifiSpeedtest` has been explicitly set.
  var hasWifiSpeedtest: Bool {return _storage._wifiSpeedtest != nil}
  /// Clears the value of `wifiSpeedtest`. Subsequent reads from it will return its default value.
  mutating func clearWifiSpeedtest() {_uniqueStorage()._wifiSpeedtest = nil}

  var clientRssi: Float {
    get {return _storage._clientRssi}
    set {_uniqueStorage()._clientRssi = newValue}
  }

  var clientPlatform: SpaceX_API_Device_ClientPlatform {
    get {return _storage._clientPlatform ?? SpaceX_API_Device_ClientPlatform()}
    set {_uniqueStorage()._clientPlatform = newValue}
  }
  /// Returns true if `clientPlatform` has been explicitly set.
  var hasClientPlatform: Bool {return _storage._clientPlatform != nil}
  /// Clears the value of `clientPlatform`. Subsequent reads from it will return its default value.
  mutating func clearClientPlatform() {_uniqueStorage()._clientPlatform = nil}

  var appVersion: String {
    get {return _storage._appVersion}
    set {_uniqueStorage()._appVersion = newValue}
  }

  var appBuild: UInt32 {
    get {return _storage._appBuild}
    set {_uniqueStorage()._appBuild = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_ReportClientSpeedtestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_DishPowerSaveRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerSaveStartMinutes: UInt32 = 0

  var powerSaveDurationMinutes: UInt32 = 0

  var enablePowerSave: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_IQCaptureRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_GetDiagnosticsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_WifiGetDiagnosticsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var hardwareVersion: String = String()

  var softwareVersion: String = String()

  var networks: [SpaceX_API_Device_WifiGetDiagnosticsResponse.Network] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Network: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var domain: String = String()

    var ipv4: String = String()

    var ipv6: [String] = []

    var clientsEthernet: UInt32 = 0

    var clients2Ghz: UInt32 = 0

    var clients5Ghz: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct SpaceX_API_Device_DishGetDiagnosticsResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var hardwareVersion: String {
    get {return _storage._hardwareVersion}
    set {_uniqueStorage()._hardwareVersion = newValue}
  }

  var softwareVersion: String {
    get {return _storage._softwareVersion}
    set {_uniqueStorage()._softwareVersion = newValue}
  }

  var utcOffsetS: Int32 {
    get {return _storage._utcOffsetS}
    set {_uniqueStorage()._utcOffsetS = newValue}
  }

  var hardwareSelfTest: SpaceX_API_Device_DishGetDiagnosticsResponse.TestResult {
    get {return _storage._hardwareSelfTest}
    set {_uniqueStorage()._hardwareSelfTest = newValue}
  }

  var alerts: SpaceX_API_Device_DishGetDiagnosticsResponse.Alerts {
    get {return _storage._alerts ?? SpaceX_API_Device_DishGetDiagnosticsResponse.Alerts()}
    set {_uniqueStorage()._alerts = newValue}
  }
  /// Returns true if `alerts` has been explicitly set.
  var hasAlerts: Bool {return _storage._alerts != nil}
  /// Clears the value of `alerts`. Subsequent reads from it will return its default value.
  mutating func clearAlerts() {_uniqueStorage()._alerts = nil}

  var disablementCode: SpaceX_API_Device_DishGetDiagnosticsResponse.DisablementCode {
    get {return _storage._disablementCode}
    set {_uniqueStorage()._disablementCode = newValue}
  }

  var location: SpaceX_API_Device_DishGetDiagnosticsResponse.Location {
    get {return _storage._location ?? SpaceX_API_Device_DishGetDiagnosticsResponse.Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TestResult: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case noResult // = 0
    case passed // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .noResult
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noResult
      case 1: self = .passed
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .noResult: return 0
      case .passed: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_DishGetDiagnosticsResponse.TestResult] = [
      .noResult,
      .passed,
      .failed,
    ]

  }

  enum DisablementCode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case okay // = 1
    case noActiveAccount // = 2
    case tooFarFromServiceAddress // = 3
    case inOcean // = 4
    case invalidCountry // = 5
    case blockedCountry // = 6
    case dataOverageSandboxPolicy // = 7
    case cellIsDisabled // = 8
    case unlicensedCountry // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .okay
      case 2: self = .noActiveAccount
      case 3: self = .tooFarFromServiceAddress
      case 4: self = .inOcean
      case 5: self = .invalidCountry
      case 6: self = .blockedCountry
      case 7: self = .dataOverageSandboxPolicy
      case 8: self = .cellIsDisabled
      case 9: self = .unlicensedCountry
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .okay: return 1
      case .noActiveAccount: return 2
      case .tooFarFromServiceAddress: return 3
      case .inOcean: return 4
      case .invalidCountry: return 5
      case .blockedCountry: return 6
      case .dataOverageSandboxPolicy: return 7
      case .cellIsDisabled: return 8
      case .unlicensedCountry: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_DishGetDiagnosticsResponse.DisablementCode] = [
      .unknown,
      .okay,
      .noActiveAccount,
      .tooFarFromServiceAddress,
      .inOcean,
      .invalidCountry,
      .blockedCountry,
      .dataOverageSandboxPolicy,
      .cellIsDisabled,
      .unlicensedCountry,
    ]

  }

  struct Alerts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dishIsHeating: Bool = false

    var dishThermalThrottle: Bool = false

    var dishThermalShutdown: Bool = false

    var powerSupplyThermalThrottle: Bool = false

    var motorsStuck: Bool = false

    var mastNotNearVertical: Bool = false

    var slowEthernetSpeeds: Bool = false

    var softwareInstallPending: Bool = false

    var movingTooFastForPolicy: Bool = false

    var obstructed: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Location: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var latitude: Double = 0

    var longitude: Double = 0

    var altitudeMeters: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SpaceX_API_Device_TcpConnectivityTestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: String = String()

  var port: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SpaceX_API_Device_UdpConnectivityTestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: String = String()

  var port: UInt32 = 0

  var probeData: SpaceX_API_Device_UdpConnectivityTestRequest.UDPProbeDataType = .empty

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum UDPProbeDataType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case empty // = 0
    case dnsStatusRequest // = 1
    case dtlsClientHello // = 2
    case dnsVersionBindReq // = 3
    case rpcCheck // = 4
    case dnsSd // = 5
    case snmpV1Public // = 6
    case snmpV3GetRequest // = 7
    case ntpMessage // = 8
    case xdmcp // = 9
    case kerberos // = 10
    case sipOptions // = 11
    case ldapSearchReq // = 12
    case memcachedStats // = 13
    case openvpn // = 14
    case cifsNsUc // = 15
    case tftpGet // = 16
    case dhcpInform // = 17
    case quic // = 18
    case ripv1 // = 19
    case nfsProcNull // = 20
    case coapRequest // = 21
    case UNRECOGNIZED(Int)

    init() {
      self = .empty
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .empty
      case 1: self = .dnsStatusRequest
      case 2: self = .dtlsClientHello
      case 3: self = .dnsVersionBindReq
      case 4: self = .rpcCheck
      case 5: self = .dnsSd
      case 6: self = .snmpV1Public
      case 7: self = .snmpV3GetRequest
      case 8: self = .ntpMessage
      case 9: self = .xdmcp
      case 10: self = .kerberos
      case 11: self = .sipOptions
      case 12: self = .ldapSearchReq
      case 13: self = .memcachedStats
      case 14: self = .openvpn
      case 15: self = .cifsNsUc
      case 16: self = .tftpGet
      case 17: self = .dhcpInform
      case 18: self = .quic
      case 19: self = .ripv1
      case 20: self = .nfsProcNull
      case 21: self = .coapRequest
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .empty: return 0
      case .dnsStatusRequest: return 1
      case .dtlsClientHello: return 2
      case .dnsVersionBindReq: return 3
      case .rpcCheck: return 4
      case .dnsSd: return 5
      case .snmpV1Public: return 6
      case .snmpV3GetRequest: return 7
      case .ntpMessage: return 8
      case .xdmcp: return 9
      case .kerberos: return 10
      case .sipOptions: return 11
      case .ldapSearchReq: return 12
      case .memcachedStats: return 13
      case .openvpn: return 14
      case .cifsNsUc: return 15
      case .tftpGet: return 16
      case .dhcpInform: return 17
      case .quic: return 18
      case .ripv1: return 19
      case .nfsProcNull: return 20
      case .coapRequest: return 21
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [SpaceX_API_Device_UdpConnectivityTestRequest.UDPProbeDataType] = [
      .empty,
      .dnsStatusRequest,
      .dtlsClientHello,
      .dnsVersionBindReq,
      .rpcCheck,
      .dnsSd,
      .snmpV1Public,
      .snmpV3GetRequest,
      .ntpMessage,
      .xdmcp,
      .kerberos,
      .sipOptions,
      .ldapSearchReq,
      .memcachedStats,
      .openvpn,
      .cifsNsUc,
      .tftpGet,
      .dhcpInform,
      .quic,
      .ripv1,
      .nfsProcNull,
      .coapRequest,
    ]

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SpaceX.API.Device"

extension SpaceX_API_Device_PositionSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO"),
    1: .same(proto: "NONE"),
    2: .same(proto: "UT_INFO"),
    3: .same(proto: "EXTERNAL"),
    4: .same(proto: "GPS"),
    5: .same(proto: "STARLINK"),
    6: .same(proto: "GNC_GPS"),
    7: .same(proto: "GNC_PNT"),
    8: .same(proto: "GNC_FUSED"),
    9: .same(proto: "GNC_RAW"),
  ]
}

extension SpaceX_API_Device_SpeedtestError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPEEDTEST_ERROR_NONE"),
    1: .same(proto: "SPEEDTEST_ERROR_UNKNOWN"),
    2: .same(proto: "SPEEDTEST_ERROR_TOKEN"),
    3: .same(proto: "SPEEDTEST_ERROR_API"),
    4: .same(proto: "SPEEDTEST_ERROR_NO_RESULT"),
    5: .same(proto: "SPEEDTEST_ERROR_OFFLINE"),
  ]
}

extension SpaceX_API_Device_ToDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .standard(proto: "health_check"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SpaceX_API_Device_Request?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .request(v)
        }
      }()
      case 2: try {
        var v: SpaceX_API_Device_HealthCheck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .healthCheck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .healthCheck(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .request?: try {
      guard case .request(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .healthCheck?: try {
      guard case .healthCheck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ToDevice, rhs: SpaceX_API_Device_ToDevice) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_FromDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
    2: .same(proto: "event"),
    3: .standard(proto: "health_check"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SpaceX_API_Device_Response?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .response(v)
        }
      }()
      case 2: try {
        var v: SpaceX_API_Device_Event?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .event(v)
        }
      }()
      case 3: try {
        var v: SpaceX_API_Device_HealthCheck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .healthCheck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .healthCheck(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .response?: try {
      guard case .response(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .event?: try {
      guard case .event(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .healthCheck?: try {
      guard case .healthCheck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_FromDevice, rhs: SpaceX_API_Device_FromDevice) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SensitiveCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensitiveCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "target_id"),
    3: .standard(proto: "get_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try {
        var v: SpaceX_API_Device_GetLocationRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getLocation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try { if case .getLocation(let v)? = self.request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SensitiveCommand, rhs: SpaceX_API_Device_SensitiveCommand) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_HealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_HealthCheck, rhs: SpaceX_API_Device_HealthCheck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    14: .standard(proto: "epoch_id"),
    13: .standard(proto: "target_id"),
    15: .standard(proto: "signed_request"),
    1006: .standard(proto: "get_next_id"),
    1078: .standard(proto: "sensitive_request"),
    1005: .same(proto: "authenticate"),
    1034: .standard(proto: "enable_debug_telem"),
    1011: .standard(proto: "factory_reset"),
    1008: .standard(proto: "get_device_info"),
    1007: .standard(proto: "get_history"),
    1012: .standard(proto: "get_log"),
    1015: .standard(proto: "get_network_interfaces"),
    1009: .standard(proto: "get_ping"),
    1016: .standard(proto: "ping_host"),
    1004: .standard(proto: "get_status"),
    1001: .same(proto: "reboot"),
    1013: .standard(proto: "set_sku"),
    1010: .standard(proto: "set_trusted_keys"),
    1003: .standard(proto: "speed_test"),
    1014: .same(proto: "update"),
    1017: .standard(proto: "get_location"),
    1019: .standard(proto: "get_heap_dump"),
    1020: .standard(proto: "restart_control"),
    1021: .same(proto: "fuse"),
    1022: .standard(proto: "get_persistent_stats"),
    1023: .standard(proto: "get_connections"),
    1027: .standard(proto: "start_speedtest"),
    1028: .standard(proto: "get_speedtest_status"),
    1029: .standard(proto: "report_client_speedtest"),
    1030: .standard(proto: "initiate_remote_ssh"),
    1031: .standard(proto: "self_test"),
    1032: .standard(proto: "set_test_mode"),
    1033: .standard(proto: "software_update"),
    1035: .standard(proto: "iq_capture"),
    1036: .standard(proto: "get_radio_stats"),
    1037: .same(proto: "time"),
    1038: .standard(proto: "run_iperf_server"),
    1039: .standard(proto: "tcp_connectivity_test"),
    1040: .standard(proto: "udp_connectivity_test"),
    2002: .standard(proto: "dish_stow"),
    2012: .standard(proto: "start_dish_self_test"),
    2003: .standard(proto: "dish_get_context"),
    2008: .standard(proto: "dish_get_obstruction_map"),
    2007: .standard(proto: "dish_set_emc"),
    2009: .standard(proto: "dish_get_emc"),
    2010: .standard(proto: "dish_set_config"),
    2011: .standard(proto: "dish_get_config"),
    2013: .standard(proto: "dish_power_save"),
    2014: .standard(proto: "dish_inhibit_gps"),
    2015: .standard(proto: "dish_get_data"),
    2017: .standard(proto: "dish_clear_obstruction_map"),
    2018: .standard(proto: "dish_set_max_power_test_mode"),
    2019: .standard(proto: "dish_activate_rssi_scan"),
    2020: .standard(proto: "dish_get_rssi_scan_result"),
    2021: .standard(proto: "dish_factory_reset"),
    2022: .standard(proto: "reset_button"),
    3002: .standard(proto: "wifi_get_clients"),
    3007: .standard(proto: "wifi_get_ping_metrics"),
    3001: .standard(proto: "wifi_set_config"),
    3009: .standard(proto: "wifi_get_config"),
    3003: .standard(proto: "wifi_setup"),
    3012: .standard(proto: "wifi_set_mesh_device_trust"),
    3013: .standard(proto: "wifi_set_mesh_config"),
    3015: .standard(proto: "wifi_get_client_history"),
    3017: .standard(proto: "wifi_set_client_given_name"),
    3016: .standard(proto: "wifi_set_aviation_conformed"),
    3018: .standard(proto: "wifi_self_test"),
    3028: .standard(proto: "wifi_run_self_test"),
    3019: .standard(proto: "wifi_calibration_mode"),
    3020: .standard(proto: "wifi_guest_info"),
    3021: .standard(proto: "wifi_rf_test"),
    3024: .standard(proto: "wifi_get_firewall"),
    3025: .standard(proto: "wifi_toggle_poe_negotiation"),
    3026: .standard(proto: "wifi_factory_test_command"),
    3027: .standard(proto: "wifi_start_local_telem_proxy"),
    3029: .standard(proto: "wifi_backhaul_stats"),
    3030: .standard(proto: "wifi_toggle_umbilical_mode"),
    4001: .standard(proto: "transceiver_if_loopback_test"),
    4003: .standard(proto: "transceiver_get_status"),
    4004: .standard(proto: "transceiver_get_telemetry"),
    5000: .standard(proto: "start_unlock"),
    5001: .standard(proto: "finish_unlock"),
    6000: .standard(proto: "get_diagnostics"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _epochID: UInt64 = 0
    var _targetID: String = String()
    var _request: SpaceX_API_Device_Request.OneOf_Request?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _epochID = source._epochID
      _targetID = source._targetID
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._targetID) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._epochID) }()
        case 15: try {
          var v: SpaceX_API_Device_SignedData?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .signedRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .signedRequest(v)
          }
        }()
        case 1001: try {
          var v: SpaceX_API_Device_RebootRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .reboot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .reboot(v)
          }
        }()
        case 1003: try {
          var v: SpaceX_API_Device_SpeedTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .speedTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .speedTest(v)
          }
        }()
        case 1004: try {
          var v: SpaceX_API_Device_GetStatusRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getStatus(v)
          }
        }()
        case 1005: try {
          var v: SpaceX_API_Device_AuthenticateRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .authenticate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .authenticate(v)
          }
        }()
        case 1006: try {
          var v: SpaceX_API_Device_GetNextIdRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getNextID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getNextID(v)
          }
        }()
        case 1007: try {
          var v: SpaceX_API_Device_GetHistoryRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getHistory(v)
          }
        }()
        case 1008: try {
          var v: SpaceX_API_Device_GetDeviceInfoRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getDeviceInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getDeviceInfo(v)
          }
        }()
        case 1009: try {
          var v: SpaceX_API_Device_GetPingRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getPing(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getPing(v)
          }
        }()
        case 1010: try {
          var v: SpaceX_API_Device_SetTrustedKeysRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .setTrustedKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .setTrustedKeys(v)
          }
        }()
        case 1011: try {
          var v: SpaceX_API_Device_FactoryResetRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .factoryReset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .factoryReset(v)
          }
        }()
        case 1012: try {
          var v: SpaceX_API_Device_GetLogRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getLog(v)
          }
        }()
        case 1013: try {
          var v: SpaceX_API_Device_SetSkuRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .setSku(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .setSku(v)
          }
        }()
        case 1014: try {
          var v: SpaceX_API_Device_UpdateRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .update(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .update(v)
          }
        }()
        case 1015: try {
          var v: SpaceX_API_Device_GetNetworkInterfacesRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getNetworkInterfaces(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getNetworkInterfaces(v)
          }
        }()
        case 1016: try {
          var v: SpaceX_API_Device_PingHostRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .pingHost(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .pingHost(v)
          }
        }()
        case 1017: try {
          var v: SpaceX_API_Device_GetLocationRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getLocation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getLocation(v)
          }
        }()
        case 1019: try {
          var v: SpaceX_API_Device_GetHeapDumpRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getHeapDump(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getHeapDump(v)
          }
        }()
        case 1020: try {
          var v: SpaceX_API_Device_RestartControlRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .restartControl(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .restartControl(v)
          }
        }()
        case 1021: try {
          var v: SpaceX_API_Device_FuseRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .fuse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .fuse(v)
          }
        }()
        case 1022: try {
          var v: SpaceX_API_Device_GetPersistentStatsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getPersistentStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getPersistentStats(v)
          }
        }()
        case 1023: try {
          var v: SpaceX_API_Device_GetConnectionsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getConnections(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getConnections(v)
          }
        }()
        case 1027: try {
          var v: SpaceX_API_Device_StartSpeedtestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .startSpeedtest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .startSpeedtest(v)
          }
        }()
        case 1028: try {
          var v: SpaceX_API_Device_GetSpeedtestStatusRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getSpeedtestStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getSpeedtestStatus(v)
          }
        }()
        case 1029: try {
          var v: SpaceX_API_Device_ReportClientSpeedtestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .reportClientSpeedtest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .reportClientSpeedtest(v)
          }
        }()
        case 1030: try {
          var v: SpaceX_API_Device_InitiateRemoteSshRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .initiateRemoteSsh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .initiateRemoteSsh(v)
          }
        }()
        case 1031: try {
          var v: SpaceX_API_Device_SelfTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .selfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .selfTest(v)
          }
        }()
        case 1032: try {
          var v: SpaceX_API_Device_SetTestModeRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .setTestMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .setTestMode(v)
          }
        }()
        case 1033: try {
          var v: SpaceX_API_Device_SoftwareUpdateRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .softwareUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .softwareUpdate(v)
          }
        }()
        case 1034: try {
          var v: SpaceX_API_Device_EnableDebugTelemRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .enableDebugTelem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .enableDebugTelem(v)
          }
        }()
        case 1035: try {
          var v: SpaceX_API_Device_IQCaptureRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .iqCapture(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .iqCapture(v)
          }
        }()
        case 1036: try {
          var v: SpaceX_API_Device_GetRadioStatsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getRadioStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getRadioStats(v)
          }
        }()
        case 1037: try {
          var v: SpaceX_API_Device_GetTimeRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .time(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .time(v)
          }
        }()
        case 1038: try {
          var v: SpaceX_API_Device_RunIperfServerRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .runIperfServer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .runIperfServer(v)
          }
        }()
        case 1039: try {
          var v: SpaceX_API_Device_TcpConnectivityTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .tcpConnectivityTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .tcpConnectivityTest(v)
          }
        }()
        case 1040: try {
          var v: SpaceX_API_Device_UdpConnectivityTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .udpConnectivityTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .udpConnectivityTest(v)
          }
        }()
        case 1078: try {
          var v: SpaceX_API_Device_SignedData?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .sensitiveRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .sensitiveRequest(v)
          }
        }()
        case 2002: try {
          var v: SpaceX_API_Device_DishStowRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishStow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishStow(v)
          }
        }()
        case 2003: try {
          var v: SpaceX_API_Device_DishGetContextRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishGetContext(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishGetContext(v)
          }
        }()
        case 2007: try {
          var v: SpaceX_API_Device_DishSetEmcRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishSetEmc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishSetEmc(v)
          }
        }()
        case 2008: try {
          var v: SpaceX_API_Device_DishGetObstructionMapRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishGetObstructionMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishGetObstructionMap(v)
          }
        }()
        case 2009: try {
          var v: SpaceX_API_Device_DishGetEmcRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishGetEmc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishGetEmc(v)
          }
        }()
        case 2010: try {
          var v: SpaceX_API_Device_DishSetConfigRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishSetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishSetConfig(v)
          }
        }()
        case 2011: try {
          var v: SpaceX_API_Device_DishGetConfigRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishGetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishGetConfig(v)
          }
        }()
        case 2012: try {
          var v: SpaceX_API_Device_StartDishSelfTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .startDishSelfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .startDishSelfTest(v)
          }
        }()
        case 2013: try {
          var v: SpaceX_API_Device_DishPowerSaveRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishPowerSave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishPowerSave(v)
          }
        }()
        case 2014: try {
          var v: SpaceX_API_Device_DishInhibitGpsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishInhibitGps(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishInhibitGps(v)
          }
        }()
        case 2015: try {
          var v: SpaceX_API_Device_DishGetDataRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishGetData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishGetData(v)
          }
        }()
        case 2017: try {
          var v: SpaceX_API_Device_DishClearObstructionMapRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishClearObstructionMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishClearObstructionMap(v)
          }
        }()
        case 2018: try {
          var v: SpaceX_API_Device_DishSetMaxPowerTestModeRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishSetMaxPowerTestMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishSetMaxPowerTestMode(v)
          }
        }()
        case 2019: try {
          var v: SpaceX_API_Device_DishActivateRssiScanRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishActivateRssiScan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishActivateRssiScan(v)
          }
        }()
        case 2020: try {
          var v: SpaceX_API_Device_DishGetRssiScanResultRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishGetRssiScanResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishGetRssiScanResult(v)
          }
        }()
        case 2021: try {
          var v: SpaceX_API_Device_DishFactoryResetRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .dishFactoryReset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .dishFactoryReset(v)
          }
        }()
        case 2022: try {
          var v: SpaceX_API_Device_ResetButtonRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .resetButton(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .resetButton(v)
          }
        }()
        case 3001: try {
          var v: SpaceX_API_Device_WifiSetConfigRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSetConfig(v)
          }
        }()
        case 3002: try {
          var v: SpaceX_API_Device_WifiGetClientsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiGetClients(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiGetClients(v)
          }
        }()
        case 3003: try {
          var v: SpaceX_API_Device_WifiSetupRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSetup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSetup(v)
          }
        }()
        case 3007: try {
          var v: SpaceX_API_Device_WifiGetPingMetricsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiGetPingMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiGetPingMetrics(v)
          }
        }()
        case 3009: try {
          var v: SpaceX_API_Device_WifiGetConfigRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiGetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiGetConfig(v)
          }
        }()
        case 3012: try {
          var v: SpaceX_API_Device_WifiSetMeshDeviceTrustRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSetMeshDeviceTrust(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSetMeshDeviceTrust(v)
          }
        }()
        case 3013: try {
          var v: SpaceX_API_Device_WifiSetMeshConfigRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSetMeshConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSetMeshConfig(v)
          }
        }()
        case 3015: try {
          var v: SpaceX_API_Device_WifiGetClientHistoryRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiGetClientHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiGetClientHistory(v)
          }
        }()
        case 3016: try {
          var v: SpaceX_API_Device_WifiSetAviationConformedRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSetAviationConformed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSetAviationConformed(v)
          }
        }()
        case 3017: try {
          var v: SpaceX_API_Device_WifiSetClientGivenNameRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSetClientGivenName(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSetClientGivenName(v)
          }
        }()
        case 3018: try {
          var v: SpaceX_API_Device_WifiSelfTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiSelfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiSelfTest(v)
          }
        }()
        case 3019: try {
          var v: SpaceX_API_Device_WifiCalibrationModeRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiCalibrationMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiCalibrationMode(v)
          }
        }()
        case 3020: try {
          var v: SpaceX_API_Device_WifiGuestInfoRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiGuestInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiGuestInfo(v)
          }
        }()
        case 3021: try {
          var v: SpaceX_API_Device_WifiRfTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiRfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiRfTest(v)
          }
        }()
        case 3024: try {
          var v: SpaceX_API_Device_WifiGetFirewallRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiGetFirewall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiGetFirewall(v)
          }
        }()
        case 3025: try {
          var v: SpaceX_API_Device_WifiTogglePoeNegotiationRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiTogglePoeNegotiation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiTogglePoeNegotiation(v)
          }
        }()
        case 3026: try {
          var v: SpaceX_API_Device_WifiFactoryTestCommandRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiFactoryTestCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiFactoryTestCommand(v)
          }
        }()
        case 3027: try {
          var v: SpaceX_API_Device_WifiStartLocalTelemProxyRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiStartLocalTelemProxy(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiStartLocalTelemProxy(v)
          }
        }()
        case 3028: try {
          var v: SpaceX_API_Device_WifiRunSelfTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiRunSelfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiRunSelfTest(v)
          }
        }()
        case 3029: try {
          var v: SpaceX_API_Device_WifiBackhaulStatsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiBackhaulStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiBackhaulStats(v)
          }
        }()
        case 3030: try {
          var v: SpaceX_API_Device_WifiToggleUmbilicalModeRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .wifiToggleUmbilicalMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .wifiToggleUmbilicalMode(v)
          }
        }()
        case 4001: try {
          var v: SpaceX_API_Device_TransceiverIFLoopbackTestRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .transceiverIfLoopbackTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .transceiverIfLoopbackTest(v)
          }
        }()
        case 4003: try {
          var v: SpaceX_API_Device_TransceiverGetStatusRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .transceiverGetStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .transceiverGetStatus(v)
          }
        }()
        case 4004: try {
          var v: SpaceX_API_Device_TransceiverGetTelemetryRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .transceiverGetTelemetry(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .transceiverGetTelemetry(v)
          }
        }()
        case 5000: try {
          var v: SpaceX_API_Device_Services_Unlock_StartUnlockRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .startUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .startUnlock(v)
          }
        }()
        case 5001: try {
          var v: SpaceX_API_Device_Services_Unlock_FinishUnlockRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .finishUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .finishUnlock(v)
          }
        }()
        case 6000: try {
          var v: SpaceX_API_Device_GetDiagnosticsRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .getDiagnostics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .getDiagnostics(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._targetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetID, fieldNumber: 13)
      }
      if _storage._epochID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epochID, fieldNumber: 14)
      }
      switch _storage._request {
      case .signedRequest?: try {
        guard case .signedRequest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .reboot?: try {
        guard case .reboot(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }()
      case .speedTest?: try {
        guard case .speedTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1003)
      }()
      case .getStatus?: try {
        guard case .getStatus(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1004)
      }()
      case .authenticate?: try {
        guard case .authenticate(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1005)
      }()
      case .getNextID?: try {
        guard case .getNextID(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1006)
      }()
      case .getHistory?: try {
        guard case .getHistory(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1007)
      }()
      case .getDeviceInfo?: try {
        guard case .getDeviceInfo(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1008)
      }()
      case .getPing?: try {
        guard case .getPing(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1009)
      }()
      case .setTrustedKeys?: try {
        guard case .setTrustedKeys(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1010)
      }()
      case .factoryReset?: try {
        guard case .factoryReset(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1011)
      }()
      case .getLog?: try {
        guard case .getLog(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1012)
      }()
      case .setSku?: try {
        guard case .setSku(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1013)
      }()
      case .update?: try {
        guard case .update(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1014)
      }()
      case .getNetworkInterfaces?: try {
        guard case .getNetworkInterfaces(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1015)
      }()
      case .pingHost?: try {
        guard case .pingHost(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1016)
      }()
      case .getLocation?: try {
        guard case .getLocation(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1017)
      }()
      case .getHeapDump?: try {
        guard case .getHeapDump(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1019)
      }()
      case .restartControl?: try {
        guard case .restartControl(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1020)
      }()
      case .fuse?: try {
        guard case .fuse(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1021)
      }()
      case .getPersistentStats?: try {
        guard case .getPersistentStats(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1022)
      }()
      case .getConnections?: try {
        guard case .getConnections(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1023)
      }()
      case .startSpeedtest?: try {
        guard case .startSpeedtest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1027)
      }()
      case .getSpeedtestStatus?: try {
        guard case .getSpeedtestStatus(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1028)
      }()
      case .reportClientSpeedtest?: try {
        guard case .reportClientSpeedtest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1029)
      }()
      case .initiateRemoteSsh?: try {
        guard case .initiateRemoteSsh(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1030)
      }()
      case .selfTest?: try {
        guard case .selfTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1031)
      }()
      case .setTestMode?: try {
        guard case .setTestMode(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1032)
      }()
      case .softwareUpdate?: try {
        guard case .softwareUpdate(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1033)
      }()
      case .enableDebugTelem?: try {
        guard case .enableDebugTelem(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1034)
      }()
      case .iqCapture?: try {
        guard case .iqCapture(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1035)
      }()
      case .getRadioStats?: try {
        guard case .getRadioStats(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1036)
      }()
      case .time?: try {
        guard case .time(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1037)
      }()
      case .runIperfServer?: try {
        guard case .runIperfServer(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1038)
      }()
      case .tcpConnectivityTest?: try {
        guard case .tcpConnectivityTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1039)
      }()
      case .udpConnectivityTest?: try {
        guard case .udpConnectivityTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1040)
      }()
      case .sensitiveRequest?: try {
        guard case .sensitiveRequest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1078)
      }()
      case .dishStow?: try {
        guard case .dishStow(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2002)
      }()
      case .dishGetContext?: try {
        guard case .dishGetContext(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2003)
      }()
      case .dishSetEmc?: try {
        guard case .dishSetEmc(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2007)
      }()
      case .dishGetObstructionMap?: try {
        guard case .dishGetObstructionMap(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2008)
      }()
      case .dishGetEmc?: try {
        guard case .dishGetEmc(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2009)
      }()
      case .dishSetConfig?: try {
        guard case .dishSetConfig(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2010)
      }()
      case .dishGetConfig?: try {
        guard case .dishGetConfig(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2011)
      }()
      case .startDishSelfTest?: try {
        guard case .startDishSelfTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2012)
      }()
      case .dishPowerSave?: try {
        guard case .dishPowerSave(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2013)
      }()
      case .dishInhibitGps?: try {
        guard case .dishInhibitGps(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2014)
      }()
      case .dishGetData?: try {
        guard case .dishGetData(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2015)
      }()
      case .dishClearObstructionMap?: try {
        guard case .dishClearObstructionMap(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2017)
      }()
      case .dishSetMaxPowerTestMode?: try {
        guard case .dishSetMaxPowerTestMode(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2018)
      }()
      case .dishActivateRssiScan?: try {
        guard case .dishActivateRssiScan(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2019)
      }()
      case .dishGetRssiScanResult?: try {
        guard case .dishGetRssiScanResult(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2020)
      }()
      case .dishFactoryReset?: try {
        guard case .dishFactoryReset(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2021)
      }()
      case .resetButton?: try {
        guard case .resetButton(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2022)
      }()
      case .wifiSetConfig?: try {
        guard case .wifiSetConfig(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3001)
      }()
      case .wifiGetClients?: try {
        guard case .wifiGetClients(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3002)
      }()
      case .wifiSetup?: try {
        guard case .wifiSetup(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3003)
      }()
      case .wifiGetPingMetrics?: try {
        guard case .wifiGetPingMetrics(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3007)
      }()
      case .wifiGetConfig?: try {
        guard case .wifiGetConfig(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3009)
      }()
      case .wifiSetMeshDeviceTrust?: try {
        guard case .wifiSetMeshDeviceTrust(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3012)
      }()
      case .wifiSetMeshConfig?: try {
        guard case .wifiSetMeshConfig(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3013)
      }()
      case .wifiGetClientHistory?: try {
        guard case .wifiGetClientHistory(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3015)
      }()
      case .wifiSetAviationConformed?: try {
        guard case .wifiSetAviationConformed(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3016)
      }()
      case .wifiSetClientGivenName?: try {
        guard case .wifiSetClientGivenName(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3017)
      }()
      case .wifiSelfTest?: try {
        guard case .wifiSelfTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3018)
      }()
      case .wifiCalibrationMode?: try {
        guard case .wifiCalibrationMode(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3019)
      }()
      case .wifiGuestInfo?: try {
        guard case .wifiGuestInfo(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3020)
      }()
      case .wifiRfTest?: try {
        guard case .wifiRfTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3021)
      }()
      case .wifiGetFirewall?: try {
        guard case .wifiGetFirewall(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3024)
      }()
      case .wifiTogglePoeNegotiation?: try {
        guard case .wifiTogglePoeNegotiation(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3025)
      }()
      case .wifiFactoryTestCommand?: try {
        guard case .wifiFactoryTestCommand(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3026)
      }()
      case .wifiStartLocalTelemProxy?: try {
        guard case .wifiStartLocalTelemProxy(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3027)
      }()
      case .wifiRunSelfTest?: try {
        guard case .wifiRunSelfTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3028)
      }()
      case .wifiBackhaulStats?: try {
        guard case .wifiBackhaulStats(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3029)
      }()
      case .wifiToggleUmbilicalMode?: try {
        guard case .wifiToggleUmbilicalMode(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3030)
      }()
      case .transceiverIfLoopbackTest?: try {
        guard case .transceiverIfLoopbackTest(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4001)
      }()
      case .transceiverGetStatus?: try {
        guard case .transceiverGetStatus(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4003)
      }()
      case .transceiverGetTelemetry?: try {
        guard case .transceiverGetTelemetry(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4004)
      }()
      case .startUnlock?: try {
        guard case .startUnlock(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5000)
      }()
      case .finishUnlock?: try {
        guard case .finishUnlock(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5001)
      }()
      case .getDiagnostics?: try {
        guard case .getDiagnostics(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6000)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_Request, rhs: SpaceX_API_Device_Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._epochID != rhs_storage._epochID {return false}
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "status"),
    3: .standard(proto: "api_version"),
    1006: .standard(proto: "get_next_id"),
    1034: .standard(proto: "enable_debug_telem"),
    1011: .standard(proto: "factory_reset"),
    1004: .standard(proto: "get_device_info"),
    1012: .standard(proto: "get_log"),
    1015: .standard(proto: "get_network_interfaces"),
    1009: .standard(proto: "get_ping"),
    1016: .standard(proto: "ping_host"),
    1001: .same(proto: "reboot"),
    1003: .standard(proto: "speed_test"),
    1013: .standard(proto: "set_sku"),
    1010: .standard(proto: "set_trusted_keys"),
    1014: .same(proto: "update"),
    1017: .standard(proto: "get_location"),
    1019: .standard(proto: "get_heap_dump"),
    1020: .standard(proto: "restart_control"),
    1021: .same(proto: "fuse"),
    1023: .standard(proto: "get_connections"),
    1027: .standard(proto: "start_speedtest"),
    1028: .standard(proto: "get_speedtest_status"),
    1029: .standard(proto: "report_client_speedtest"),
    1030: .standard(proto: "initiate_remote_ssh"),
    1031: .standard(proto: "self_test"),
    1032: .standard(proto: "set_test_mode"),
    1033: .standard(proto: "software_update"),
    1035: .standard(proto: "get_radio_stats"),
    1037: .same(proto: "time"),
    1038: .standard(proto: "run_iperf_server"),
    2005: .standard(proto: "dish_authenticate"),
    2003: .standard(proto: "dish_get_context"),
    2006: .standard(proto: "dish_get_history"),
    2004: .standard(proto: "dish_get_status"),
    2008: .standard(proto: "dish_get_obstruction_map"),
    2002: .standard(proto: "dish_stow"),
    2012: .standard(proto: "start_dish_self_test"),
    2007: .standard(proto: "dish_set_emc"),
    2009: .standard(proto: "dish_get_emc"),
    2010: .standard(proto: "dish_set_config"),
    2011: .standard(proto: "dish_get_config"),
    2013: .standard(proto: "dish_inhibit_gps"),
    2015: .standard(proto: "dish_clear_obstruction_map"),
    2018: .standard(proto: "dish_set_max_power_test_mode"),
    2019: .standard(proto: "dish_activate_rssi_scan"),
    2020: .standard(proto: "dish_get_rssi_scan_result"),
    2021: .standard(proto: "dish_factory_reset"),
    2022: .standard(proto: "reset_button"),
    3005: .standard(proto: "wifi_authenticate"),
    3002: .standard(proto: "wifi_get_clients"),
    3006: .standard(proto: "wifi_get_history"),
    3007: .standard(proto: "wifi_get_ping_metrics"),
    3004: .standard(proto: "wifi_get_status"),
    3001: .standard(proto: "wifi_set_config"),
    3009: .standard(proto: "wifi_get_config"),
    3003: .standard(proto: "wifi_setup"),
    3022: .standard(proto: "wifi_get_persistent_stats"),
    3012: .standard(proto: "wifi_set_mesh_device_trust"),
    3013: .standard(proto: "wifi_set_mesh_config"),
    3015: .standard(proto: "wifi_get_client_history"),
    3016: .standard(proto: "wifi_self_test"),
    3020: .standard(proto: "wifi_guest_info"),
    3021: .standard(proto: "wifi_rf_test"),
    3024: .standard(proto: "wifi_get_firewall"),
    3025: .standard(proto: "wifi_factory_test_command"),
    3026: .standard(proto: "wifi_backhaul_stats"),
    4001: .standard(proto: "transceiver_if_loopback_test"),
    4003: .standard(proto: "transceiver_get_status"),
    4004: .standard(proto: "transceiver_get_telemetry"),
    5000: .standard(proto: "start_unlock"),
    5001: .standard(proto: "finish_unlock"),
    6000: .standard(proto: "wifi_get_diagnostics"),
    6001: .standard(proto: "dish_get_diagnostics"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _status: SpaceX_API_Status_Status? = nil
    var _apiVersion: UInt64 = 0
    var _response: SpaceX_API_Device_Response.OneOf_Response?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _status = source._status
      _apiVersion = source._apiVersion
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._apiVersion) }()
        case 1001: try {
          var v: SpaceX_API_Device_RebootResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .reboot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .reboot(v)
          }
        }()
        case 1003: try {
          var v: SpaceX_API_Device_SpeedTestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .speedTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .speedTest(v)
          }
        }()
        case 1004: try {
          var v: SpaceX_API_Device_GetDeviceInfoResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getDeviceInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getDeviceInfo(v)
          }
        }()
        case 1006: try {
          var v: SpaceX_API_Device_GetNextIdResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getNextID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getNextID(v)
          }
        }()
        case 1009: try {
          var v: SpaceX_API_Device_GetPingResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getPing(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getPing(v)
          }
        }()
        case 1010: try {
          var v: SpaceX_API_Device_SetTrustedKeysResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .setTrustedKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .setTrustedKeys(v)
          }
        }()
        case 1011: try {
          var v: SpaceX_API_Device_FactoryResetResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .factoryReset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .factoryReset(v)
          }
        }()
        case 1012: try {
          var v: SpaceX_API_Device_GetLogResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getLog(v)
          }
        }()
        case 1013: try {
          var v: SpaceX_API_Device_SetSkuResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .setSku(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .setSku(v)
          }
        }()
        case 1014: try {
          var v: SpaceX_API_Device_UpdateResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .update(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .update(v)
          }
        }()
        case 1015: try {
          var v: SpaceX_API_Device_GetNetworkInterfacesResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getNetworkInterfaces(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getNetworkInterfaces(v)
          }
        }()
        case 1016: try {
          var v: SpaceX_API_Device_PingHostResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .pingHost(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .pingHost(v)
          }
        }()
        case 1017: try {
          var v: SpaceX_API_Device_GetLocationResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getLocation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getLocation(v)
          }
        }()
        case 1019: try {
          var v: SpaceX_API_Device_GetHeapDumpResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getHeapDump(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getHeapDump(v)
          }
        }()
        case 1020: try {
          var v: SpaceX_API_Device_RestartControlResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .restartControl(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .restartControl(v)
          }
        }()
        case 1021: try {
          var v: SpaceX_API_Device_FuseResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .fuse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .fuse(v)
          }
        }()
        case 1023: try {
          var v: SpaceX_API_Device_GetConnectionsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getConnections(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getConnections(v)
          }
        }()
        case 1027: try {
          var v: SpaceX_API_Device_StartSpeedtestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .startSpeedtest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .startSpeedtest(v)
          }
        }()
        case 1028: try {
          var v: SpaceX_API_Device_GetSpeedtestStatusResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getSpeedtestStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getSpeedtestStatus(v)
          }
        }()
        case 1029: try {
          var v: SpaceX_API_Device_ReportClientSpeedtestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .reportClientSpeedtest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .reportClientSpeedtest(v)
          }
        }()
        case 1030: try {
          var v: SpaceX_API_Device_InitiateRemoteSshResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .initiateRemoteSsh(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .initiateRemoteSsh(v)
          }
        }()
        case 1031: try {
          var v: SpaceX_API_Device_SelfTestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .selfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .selfTest(v)
          }
        }()
        case 1032: try {
          var v: SpaceX_API_Device_SetTestModeResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .setTestMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .setTestMode(v)
          }
        }()
        case 1033: try {
          var v: SpaceX_API_Device_SoftwareUpdateResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .softwareUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .softwareUpdate(v)
          }
        }()
        case 1034: try {
          var v: SpaceX_API_Device_EnableDebugTelemResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .enableDebugTelem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .enableDebugTelem(v)
          }
        }()
        case 1035: try {
          var v: SpaceX_API_Device_GetRadioStatsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .getRadioStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .getRadioStats(v)
          }
        }()
        case 1037: try {
          var v: SpaceX_API_Device_GetTimeResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .time(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .time(v)
          }
        }()
        case 1038: try {
          var v: SpaceX_API_Device_RunIperfServerResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .runIperfServer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .runIperfServer(v)
          }
        }()
        case 2002: try {
          var v: SpaceX_API_Device_DishStowResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishStow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishStow(v)
          }
        }()
        case 2003: try {
          var v: SpaceX_API_Device_DishGetContextResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetContext(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetContext(v)
          }
        }()
        case 2004: try {
          var v: SpaceX_API_Device_DishGetStatusResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetStatus(v)
          }
        }()
        case 2005: try {
          var v: SpaceX_API_Device_DishAuthenticateResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishAuthenticate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishAuthenticate(v)
          }
        }()
        case 2006: try {
          var v: SpaceX_API_Device_DishGetHistoryResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetHistory(v)
          }
        }()
        case 2007: try {
          var v: SpaceX_API_Device_DishSetEmcResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishSetEmc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishSetEmc(v)
          }
        }()
        case 2008: try {
          var v: SpaceX_API_Device_DishGetObstructionMapResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetObstructionMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetObstructionMap(v)
          }
        }()
        case 2009: try {
          var v: SpaceX_API_Device_DishGetEmcResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetEmc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetEmc(v)
          }
        }()
        case 2010: try {
          var v: SpaceX_API_Device_DishSetConfigResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishSetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishSetConfig(v)
          }
        }()
        case 2011: try {
          var v: SpaceX_API_Device_DishGetConfigResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetConfig(v)
          }
        }()
        case 2012: try {
          var v: SpaceX_API_Device_StartDishSelfTestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .startDishSelfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .startDishSelfTest(v)
          }
        }()
        case 2013: try {
          var v: SpaceX_API_Device_DishInhibitGpsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishInhibitGps(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishInhibitGps(v)
          }
        }()
        case 2015: try {
          var v: SpaceX_API_Device_DishClearObstructionMapResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishClearObstructionMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishClearObstructionMap(v)
          }
        }()
        case 2018: try {
          var v: SpaceX_API_Device_DishSetMaxPowerTestModeResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishSetMaxPowerTestMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishSetMaxPowerTestMode(v)
          }
        }()
        case 2019: try {
          var v: SpaceX_API_Device_DishActivateRssiScanResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishActivateRssiScan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishActivateRssiScan(v)
          }
        }()
        case 2020: try {
          var v: SpaceX_API_Device_DishGetRssiScanResultResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetRssiScanResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetRssiScanResult(v)
          }
        }()
        case 2021: try {
          var v: SpaceX_API_Device_DishFactoryResetResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishFactoryReset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishFactoryReset(v)
          }
        }()
        case 2022: try {
          var v: SpaceX_API_Device_ResetButtonResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .resetButton(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .resetButton(v)
          }
        }()
        case 3001: try {
          var v: SpaceX_API_Device_WifiSetConfigResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiSetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiSetConfig(v)
          }
        }()
        case 3002: try {
          var v: SpaceX_API_Device_WifiGetClientsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetClients(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetClients(v)
          }
        }()
        case 3003: try {
          var v: SpaceX_API_Device_WifiSetupResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiSetup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiSetup(v)
          }
        }()
        case 3004: try {
          var v: SpaceX_API_Device_WifiGetStatusResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetStatus(v)
          }
        }()
        case 3005: try {
          var v: SpaceX_API_Device_WifiAuthenticateResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiAuthenticate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiAuthenticate(v)
          }
        }()
        case 3006: try {
          var v: SpaceX_API_Device_WifiGetHistoryResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetHistory(v)
          }
        }()
        case 3007: try {
          var v: SpaceX_API_Device_WifiGetPingMetricsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetPingMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetPingMetrics(v)
          }
        }()
        case 3009: try {
          var v: SpaceX_API_Device_WifiGetConfigResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetConfig(v)
          }
        }()
        case 3012: try {
          var v: SpaceX_API_Device_WifiSetMeshDeviceTrustResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiSetMeshDeviceTrust(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiSetMeshDeviceTrust(v)
          }
        }()
        case 3013: try {
          var v: SpaceX_API_Device_WifiSetMeshConfigResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiSetMeshConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiSetMeshConfig(v)
          }
        }()
        case 3015: try {
          var v: SpaceX_API_Device_WifiGetClientHistoryResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetClientHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetClientHistory(v)
          }
        }()
        case 3016: try {
          var v: SpaceX_API_Device_WifiSelfTestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiSelfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiSelfTest(v)
          }
        }()
        case 3020: try {
          var v: SpaceX_API_Device_WifiGuestInfoResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGuestInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGuestInfo(v)
          }
        }()
        case 3021: try {
          var v: SpaceX_API_Device_WifiRfTestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiRfTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiRfTest(v)
          }
        }()
        case 3022: try {
          var v: SpaceX_API_Device_WifiGetPersistentStatsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetPersistentStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetPersistentStats(v)
          }
        }()
        case 3024: try {
          var v: SpaceX_API_Device_WifiGetFirewallResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetFirewall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetFirewall(v)
          }
        }()
        case 3025: try {
          var v: SpaceX_API_Device_WifiFactoryTestCommandResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiFactoryTestCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiFactoryTestCommand(v)
          }
        }()
        case 3026: try {
          var v: SpaceX_API_Device_WifiBackhaulStatsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiBackhaulStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiBackhaulStats(v)
          }
        }()
        case 4001: try {
          var v: SpaceX_API_Device_TransceiverIFLoopbackTestResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .transceiverIfLoopbackTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .transceiverIfLoopbackTest(v)
          }
        }()
        case 4003: try {
          var v: SpaceX_API_Device_TransceiverGetStatusResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .transceiverGetStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .transceiverGetStatus(v)
          }
        }()
        case 4004: try {
          var v: SpaceX_API_Device_TransceiverGetTelemetryResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .transceiverGetTelemetry(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .transceiverGetTelemetry(v)
          }
        }()
        case 5000: try {
          var v: SpaceX_API_Device_Services_Unlock_StartUnlockResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .startUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .startUnlock(v)
          }
        }()
        case 5001: try {
          var v: SpaceX_API_Device_Services_Unlock_FinishUnlockResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .finishUnlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .finishUnlock(v)
          }
        }()
        case 6000: try {
          var v: SpaceX_API_Device_WifiGetDiagnosticsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .wifiGetDiagnostics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .wifiGetDiagnostics(v)
          }
        }()
        case 6001: try {
          var v: SpaceX_API_Device_DishGetDiagnosticsResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .dishGetDiagnostics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .dishGetDiagnostics(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._apiVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._apiVersion, fieldNumber: 3)
      }
      switch _storage._response {
      case .reboot?: try {
        guard case .reboot(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
      }()
      case .speedTest?: try {
        guard case .speedTest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1003)
      }()
      case .getDeviceInfo?: try {
        guard case .getDeviceInfo(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1004)
      }()
      case .getNextID?: try {
        guard case .getNextID(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1006)
      }()
      case .getPing?: try {
        guard case .getPing(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1009)
      }()
      case .setTrustedKeys?: try {
        guard case .setTrustedKeys(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1010)
      }()
      case .factoryReset?: try {
        guard case .factoryReset(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1011)
      }()
      case .getLog?: try {
        guard case .getLog(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1012)
      }()
      case .setSku?: try {
        guard case .setSku(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1013)
      }()
      case .update?: try {
        guard case .update(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1014)
      }()
      case .getNetworkInterfaces?: try {
        guard case .getNetworkInterfaces(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1015)
      }()
      case .pingHost?: try {
        guard case .pingHost(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1016)
      }()
      case .getLocation?: try {
        guard case .getLocation(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1017)
      }()
      case .getHeapDump?: try {
        guard case .getHeapDump(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1019)
      }()
      case .restartControl?: try {
        guard case .restartControl(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1020)
      }()
      case .fuse?: try {
        guard case .fuse(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1021)
      }()
      case .getConnections?: try {
        guard case .getConnections(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1023)
      }()
      case .startSpeedtest?: try {
        guard case .startSpeedtest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1027)
      }()
      case .getSpeedtestStatus?: try {
        guard case .getSpeedtestStatus(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1028)
      }()
      case .reportClientSpeedtest?: try {
        guard case .reportClientSpeedtest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1029)
      }()
      case .initiateRemoteSsh?: try {
        guard case .initiateRemoteSsh(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1030)
      }()
      case .selfTest?: try {
        guard case .selfTest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1031)
      }()
      case .setTestMode?: try {
        guard case .setTestMode(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1032)
      }()
      case .softwareUpdate?: try {
        guard case .softwareUpdate(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1033)
      }()
      case .enableDebugTelem?: try {
        guard case .enableDebugTelem(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1034)
      }()
      case .getRadioStats?: try {
        guard case .getRadioStats(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1035)
      }()
      case .time?: try {
        guard case .time(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1037)
      }()
      case .runIperfServer?: try {
        guard case .runIperfServer(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1038)
      }()
      case .dishStow?: try {
        guard case .dishStow(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2002)
      }()
      case .dishGetContext?: try {
        guard case .dishGetContext(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2003)
      }()
      case .dishGetStatus?: try {
        guard case .dishGetStatus(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2004)
      }()
      case .dishAuthenticate?: try {
        guard case .dishAuthenticate(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2005)
      }()
      case .dishGetHistory?: try {
        guard case .dishGetHistory(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2006)
      }()
      case .dishSetEmc?: try {
        guard case .dishSetEmc(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2007)
      }()
      case .dishGetObstructionMap?: try {
        guard case .dishGetObstructionMap(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2008)
      }()
      case .dishGetEmc?: try {
        guard case .dishGetEmc(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2009)
      }()
      case .dishSetConfig?: try {
        guard case .dishSetConfig(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2010)
      }()
      case .dishGetConfig?: try {
        guard case .dishGetConfig(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2011)
      }()
      case .startDishSelfTest?: try {
        guard case .startDishSelfTest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2012)
      }()
      case .dishInhibitGps?: try {
        guard case .dishInhibitGps(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2013)
      }()
      case .dishClearObstructionMap?: try {
        guard case .dishClearObstructionMap(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2015)
      }()
      case .dishSetMaxPowerTestMode?: try {
        guard case .dishSetMaxPowerTestMode(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2018)
      }()
      case .dishActivateRssiScan?: try {
        guard case .dishActivateRssiScan(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2019)
      }()
      case .dishGetRssiScanResult?: try {
        guard case .dishGetRssiScanResult(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2020)
      }()
      case .dishFactoryReset?: try {
        guard case .dishFactoryReset(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2021)
      }()
      case .resetButton?: try {
        guard case .resetButton(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2022)
      }()
      case .wifiSetConfig?: try {
        guard case .wifiSetConfig(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3001)
      }()
      case .wifiGetClients?: try {
        guard case .wifiGetClients(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3002)
      }()
      case .wifiSetup?: try {
        guard case .wifiSetup(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3003)
      }()
      case .wifiGetStatus?: try {
        guard case .wifiGetStatus(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3004)
      }()
      case .wifiAuthenticate?: try {
        guard case .wifiAuthenticate(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3005)
      }()
      case .wifiGetHistory?: try {
        guard case .wifiGetHistory(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3006)
      }()
      case .wifiGetPingMetrics?: try {
        guard case .wifiGetPingMetrics(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3007)
      }()
      case .wifiGetConfig?: try {
        guard case .wifiGetConfig(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3009)
      }()
      case .wifiSetMeshDeviceTrust?: try {
        guard case .wifiSetMeshDeviceTrust(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3012)
      }()
      case .wifiSetMeshConfig?: try {
        guard case .wifiSetMeshConfig(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3013)
      }()
      case .wifiGetClientHistory?: try {
        guard case .wifiGetClientHistory(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3015)
      }()
      case .wifiSelfTest?: try {
        guard case .wifiSelfTest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3016)
      }()
      case .wifiGuestInfo?: try {
        guard case .wifiGuestInfo(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3020)
      }()
      case .wifiRfTest?: try {
        guard case .wifiRfTest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3021)
      }()
      case .wifiGetPersistentStats?: try {
        guard case .wifiGetPersistentStats(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3022)
      }()
      case .wifiGetFirewall?: try {
        guard case .wifiGetFirewall(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3024)
      }()
      case .wifiFactoryTestCommand?: try {
        guard case .wifiFactoryTestCommand(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3025)
      }()
      case .wifiBackhaulStats?: try {
        guard case .wifiBackhaulStats(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3026)
      }()
      case .transceiverIfLoopbackTest?: try {
        guard case .transceiverIfLoopbackTest(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4001)
      }()
      case .transceiverGetStatus?: try {
        guard case .transceiverGetStatus(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4003)
      }()
      case .transceiverGetTelemetry?: try {
        guard case .transceiverGetTelemetry(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4004)
      }()
      case .startUnlock?: try {
        guard case .startUnlock(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5000)
      }()
      case .finishUnlock?: try {
        guard case .finishUnlock(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5001)
      }()
      case .wifiGetDiagnostics?: try {
        guard case .wifiGetDiagnostics(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6000)
      }()
      case .dishGetDiagnostics?: try {
        guard case .dishGetDiagnostics(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6001)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_Response, rhs: SpaceX_API_Device_Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._apiVersion != rhs_storage._apiVersion {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3001: .standard(proto: "wifi_new_client_connected"),
    3002: .standard(proto: "wifi_account_bonding"),
    3003: .standard(proto: "wifi_new_peer"),
    3004: .standard(proto: "wifi_cloud_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3001: try {
        var v: SpaceX_API_Device_WifiNewClientConnectedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .wifiNewClientConnected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .wifiNewClientConnected(v)
        }
      }()
      case 3002: try {
        var v: SpaceX_API_Device_WifiAccountBondingEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .wifiAccountBonding(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .wifiAccountBonding(v)
        }
      }()
      case 3003: try {
        var v: SpaceX_API_Device_WifiNewPeerEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .wifiNewPeer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .wifiNewPeer(v)
        }
      }()
      case 3004: try {
        var v: SpaceX_API_Device_WifiCloudStatusEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .wifiCloudStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .wifiCloudStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .wifiNewClientConnected?: try {
      guard case .wifiNewClientConnected(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3001)
    }()
    case .wifiAccountBonding?: try {
      guard case .wifiAccountBonding(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3002)
    }()
    case .wifiNewPeer?: try {
      guard case .wifiNewPeer(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3003)
    }()
    case .wifiCloudStatus?: try {
      guard case .wifiCloudStatus(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3004)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_Event, rhs: SpaceX_API_Device_Event) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_WifiCloudStatusEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiCloudStatusEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "api_version"),
    1: .standard(proto: "direct_link_to_dish"),
    2: .standard(proto: "hardware_version"),
    3: .standard(proto: "is_bypassed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.directLinkToDish) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hardwareVersion) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isBypassed) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.directLinkToDish != false {
      try visitor.visitSingularBoolField(value: self.directLinkToDish, fieldNumber: 1)
    }
    if !self.hardwareVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.hardwareVersion, fieldNumber: 2)
    }
    if self.isBypassed != false {
      try visitor.visitSingularBoolField(value: self.isBypassed, fieldNumber: 3)
    }
    if self.apiVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_WifiCloudStatusEvent, rhs: SpaceX_API_Device_WifiCloudStatusEvent) -> Bool {
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.directLinkToDish != rhs.directLinkToDish {return false}
    if lhs.hardwareVersion != rhs.hardwareVersion {return false}
    if lhs.isBypassed != rhs.isBypassed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_EnableDebugTelemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnableDebugTelemRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_m"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.durationM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationM != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationM, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_EnableDebugTelemRequest, rhs: SpaceX_API_Device_EnableDebugTelemRequest) -> Bool {
    if lhs.durationM != rhs.durationM {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_EnableDebugTelemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnableDebugTelemResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_EnableDebugTelemResponse, rhs: SpaceX_API_Device_EnableDebugTelemResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_FactoryResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FactoryResetRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_FactoryResetRequest, rhs: SpaceX_API_Device_FactoryResetRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_FactoryResetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FactoryResetResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_FactoryResetResponse, rhs: SpaceX_API_Device_FactoryResetResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTimeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetTimeRequest, rhs: SpaceX_API_Device_GetTimeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unix_nano"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.unixNano) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unixNano != 0 {
      try visitor.visitSingularInt64Field(value: self.unixNano, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetTimeResponse, rhs: SpaceX_API_Device_GetTimeResponse) -> Bool {
    if lhs.unixNano != rhs.unixNano {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_FuseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FuseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prevent_reboot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.preventReboot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.preventReboot != false {
      try visitor.visitSingularBoolField(value: self.preventReboot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_FuseRequest, rhs: SpaceX_API_Device_FuseRequest) -> Bool {
    if lhs.preventReboot != rhs.preventReboot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_FuseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FuseResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_FuseResponse, rhs: SpaceX_API_Device_FuseResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHistoryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetHistoryRequest, rhs: SpaceX_API_Device_GetHistoryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetLogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetLogRequest, rhs: SpaceX_API_Device_GetLogRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "current"),
    5: .same(proto: "saved"),
    1: .same(proto: "syslog"),
    2: .standard(proto: "offline_log"),
    3: .standard(proto: "persistent_log"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.syslog) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.offlineLog) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.persistentLog) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._current) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._saved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.syslog.isEmpty {
      try visitor.visitSingularStringField(value: self.syslog, fieldNumber: 1)
    }
    if !self.offlineLog.isEmpty {
      try visitor.visitSingularStringField(value: self.offlineLog, fieldNumber: 2)
    }
    if !self.persistentLog.isEmpty {
      try visitor.visitSingularStringField(value: self.persistentLog, fieldNumber: 3)
    }
    try { if let v = self._current {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._saved {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetLogResponse, rhs: SpaceX_API_Device_GetLogResponse) -> Bool {
    if lhs._current != rhs._current {return false}
    if lhs._saved != rhs._saved {return false}
    if lhs.syslog != rhs.syslog {return false}
    if lhs.offlineLog != rhs.offlineLog {return false}
    if lhs.persistentLog != rhs.persistentLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetLogResponse.Logs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_GetLogResponse.protoMessageName + ".Logs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "syslog"),
    2: .same(proto: "dmesg"),
    3: .standard(proto: "kernel_panic"),
    4: .standard(proto: "mtk_eth_procs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.syslog) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dmesg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.kernelPanic) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mtkEthProcs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.syslog.isEmpty {
      try visitor.visitSingularStringField(value: self.syslog, fieldNumber: 1)
    }
    if !self.dmesg.isEmpty {
      try visitor.visitSingularStringField(value: self.dmesg, fieldNumber: 2)
    }
    if !self.kernelPanic.isEmpty {
      try visitor.visitSingularStringField(value: self.kernelPanic, fieldNumber: 3)
    }
    if !self.mtkEthProcs.isEmpty {
      try visitor.visitSingularStringField(value: self.mtkEthProcs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetLogResponse.Logs, rhs: SpaceX_API_Device_GetLogResponse.Logs) -> Bool {
    if lhs.syslog != rhs.syslog {return false}
    if lhs.dmesg != rhs.dmesg {return false}
    if lhs.kernelPanic != rhs.kernelPanic {return false}
    if lhs.mtkEthProcs != rhs.mtkEthProcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetPingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetPingRequest, rhs: SpaceX_API_Device_GetPingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetPingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SpaceX_API_Device_PingResult>.self, value: &self.results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SpaceX_API_Device_PingResult>.self, value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetPingResponse, rhs: SpaceX_API_Device_GetPingResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_PingHostRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingHostRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "address"),
    4: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_PingHostRequest, rhs: SpaceX_API_Device_PingHostRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_PingHostResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingHostResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_PingHostResponse, rhs: SpaceX_API_Device_PingHostResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetStatusRequest, rhs: SpaceX_API_Device_GetStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RebootRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RebootRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RebootRequest, rhs: SpaceX_API_Device_RebootRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RebootResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RebootResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RebootResponse, rhs: SpaceX_API_Device_RebootResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SpeedTestStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedTestStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "latency_ms"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "upload_start_time"),
    6: .standard(proto: "download_start_time"),
    1: .standard(proto: "upload_mbps"),
    2: .standard(proto: "download_mbps"),
    7: .same(proto: "target"),
    8: .standard(proto: "tcp_streams"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.uploadMbps) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.downloadMbps) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.latencyMs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.startTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.uploadStartTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.downloadStartTime) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.target) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.tcpStreams) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uploadMbps.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.uploadMbps, fieldNumber: 1)
    }
    if self.downloadMbps.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.downloadMbps, fieldNumber: 2)
    }
    if self.latencyMs.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.latencyMs, fieldNumber: 3)
    }
    if self.startTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startTime, fieldNumber: 4)
    }
    if self.uploadStartTime != 0 {
      try visitor.visitSingularInt64Field(value: self.uploadStartTime, fieldNumber: 5)
    }
    if self.downloadStartTime != 0 {
      try visitor.visitSingularInt64Field(value: self.downloadStartTime, fieldNumber: 6)
    }
    if self.target != .unknown {
      try visitor.visitSingularEnumField(value: self.target, fieldNumber: 7)
    }
    if self.tcpStreams != 0 {
      try visitor.visitSingularUInt32Field(value: self.tcpStreams, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SpeedTestStats, rhs: SpaceX_API_Device_SpeedTestStats) -> Bool {
    if lhs.latencyMs != rhs.latencyMs {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.uploadStartTime != rhs.uploadStartTime {return false}
    if lhs.downloadStartTime != rhs.downloadStartTime {return false}
    if lhs.uploadMbps != rhs.uploadMbps {return false}
    if lhs.downloadMbps != rhs.downloadMbps {return false}
    if lhs.target != rhs.target {return false}
    if lhs.tcpStreams != rhs.tcpStreams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SpeedTestStats.Target: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "FASTCOM"),
    2: .same(proto: "CLOUDFLARE"),
  ]
}

extension SpaceX_API_Device_ClientPlatform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientPlatform"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .standard(proto: "major_version"),
    3: .standard(proto: "minor_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.majorVersion) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.minorVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .unknown {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if self.majorVersion.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.majorVersion, fieldNumber: 2)
    }
    if self.minorVersion.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.minorVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ClientPlatform, rhs: SpaceX_API_Device_ClientPlatform) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minorVersion != rhs.minorVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ClientPlatform.Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "IOS"),
    2: .same(proto: "ANDROID"),
    3: .same(proto: "WEB"),
  ]
}

extension SpaceX_API_Device_SpeedTestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedTestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "id"),
    1: .standard(proto: "client_speedtest"),
    2: .standard(proto: "client_rssi"),
    3: .standard(proto: "client_platform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clientSpeedtest) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.clientRssi) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientPlatform) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientSpeedtest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.clientRssi.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.clientRssi, fieldNumber: 2)
    }
    try { if let v = self._clientPlatform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SpeedTestRequest, rhs: SpaceX_API_Device_SpeedTestRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._clientSpeedtest != rhs._clientSpeedtest {return false}
    if lhs.clientRssi != rhs.clientRssi {return false}
    if lhs._clientPlatform != rhs._clientPlatform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SpeedTestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedTestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_bps"),
    2: .standard(proto: "upload_bps"),
    3: .standard(proto: "latency_s"),
    4: .standard(proto: "download_mbps"),
    5: .standard(proto: "upload_mbps"),
    6: .standard(proto: "latency_ms"),
    15: .standard(proto: "router_speedtest"),
    7: .standard(proto: "download_mbps_1_tcp_conn"),
    8: .standard(proto: "upload_mbps_1_tcp_conn"),
    9: .standard(proto: "download_mbps_4_tcp_conn"),
    10: .standard(proto: "upload_mbps_4_tcp_conn"),
    11: .standard(proto: "download_mbps_16_tcp_conn"),
    12: .standard(proto: "upload_mbps_16_tcp_conn"),
    13: .standard(proto: "download_mbps_64_tcp_conn"),
    14: .standard(proto: "upload_mbps_64_tcp_conn"),
  ]

  fileprivate class _StorageClass {
    var _downloadBps: Float = 0
    var _uploadBps: Float = 0
    var _latencyS: Float = 0
    var _downloadMbps: Float = 0
    var _uploadMbps: Float = 0
    var _latencyMs: Float = 0
    var _routerSpeedtest: SpaceX_API_Device_SpeedTestStats? = nil
    var _downloadMbps1TcpConn: Float = 0
    var _uploadMbps1TcpConn: Float = 0
    var _downloadMbps4TcpConn: Float = 0
    var _uploadMbps4TcpConn: Float = 0
    var _downloadMbps16TcpConn: Float = 0
    var _uploadMbps16TcpConn: Float = 0
    var _downloadMbps64TcpConn: Float = 0
    var _uploadMbps64TcpConn: Float = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _downloadBps = source._downloadBps
      _uploadBps = source._uploadBps
      _latencyS = source._latencyS
      _downloadMbps = source._downloadMbps
      _uploadMbps = source._uploadMbps
      _latencyMs = source._latencyMs
      _routerSpeedtest = source._routerSpeedtest
      _downloadMbps1TcpConn = source._downloadMbps1TcpConn
      _uploadMbps1TcpConn = source._uploadMbps1TcpConn
      _downloadMbps4TcpConn = source._downloadMbps4TcpConn
      _uploadMbps4TcpConn = source._uploadMbps4TcpConn
      _downloadMbps16TcpConn = source._downloadMbps16TcpConn
      _uploadMbps16TcpConn = source._uploadMbps16TcpConn
      _downloadMbps64TcpConn = source._downloadMbps64TcpConn
      _uploadMbps64TcpConn = source._uploadMbps64TcpConn
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._downloadBps) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._uploadBps) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._latencyS) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._downloadMbps) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._uploadMbps) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._latencyMs) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._downloadMbps1TcpConn) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._uploadMbps1TcpConn) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._downloadMbps4TcpConn) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._uploadMbps4TcpConn) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._downloadMbps16TcpConn) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._uploadMbps16TcpConn) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._downloadMbps64TcpConn) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._uploadMbps64TcpConn) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._routerSpeedtest) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._downloadBps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downloadBps, fieldNumber: 1)
      }
      if _storage._uploadBps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uploadBps, fieldNumber: 2)
      }
      if _storage._latencyS.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._latencyS, fieldNumber: 3)
      }
      if _storage._downloadMbps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downloadMbps, fieldNumber: 4)
      }
      if _storage._uploadMbps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uploadMbps, fieldNumber: 5)
      }
      if _storage._latencyMs.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._latencyMs, fieldNumber: 6)
      }
      if _storage._downloadMbps1TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downloadMbps1TcpConn, fieldNumber: 7)
      }
      if _storage._uploadMbps1TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uploadMbps1TcpConn, fieldNumber: 8)
      }
      if _storage._downloadMbps4TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downloadMbps4TcpConn, fieldNumber: 9)
      }
      if _storage._uploadMbps4TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uploadMbps4TcpConn, fieldNumber: 10)
      }
      if _storage._downloadMbps16TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downloadMbps16TcpConn, fieldNumber: 11)
      }
      if _storage._uploadMbps16TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uploadMbps16TcpConn, fieldNumber: 12)
      }
      if _storage._downloadMbps64TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._downloadMbps64TcpConn, fieldNumber: 13)
      }
      if _storage._uploadMbps64TcpConn.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._uploadMbps64TcpConn, fieldNumber: 14)
      }
      try { if let v = _storage._routerSpeedtest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SpeedTestResponse, rhs: SpaceX_API_Device_SpeedTestResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._downloadBps != rhs_storage._downloadBps {return false}
        if _storage._uploadBps != rhs_storage._uploadBps {return false}
        if _storage._latencyS != rhs_storage._latencyS {return false}
        if _storage._downloadMbps != rhs_storage._downloadMbps {return false}
        if _storage._uploadMbps != rhs_storage._uploadMbps {return false}
        if _storage._latencyMs != rhs_storage._latencyMs {return false}
        if _storage._routerSpeedtest != rhs_storage._routerSpeedtest {return false}
        if _storage._downloadMbps1TcpConn != rhs_storage._downloadMbps1TcpConn {return false}
        if _storage._uploadMbps1TcpConn != rhs_storage._uploadMbps1TcpConn {return false}
        if _storage._downloadMbps4TcpConn != rhs_storage._downloadMbps4TcpConn {return false}
        if _storage._uploadMbps4TcpConn != rhs_storage._uploadMbps4TcpConn {return false}
        if _storage._downloadMbps16TcpConn != rhs_storage._downloadMbps16TcpConn {return false}
        if _storage._uploadMbps16TcpConn != rhs_storage._uploadMbps16TcpConn {return false}
        if _storage._downloadMbps64TcpConn != rhs_storage._downloadMbps64TcpConn {return false}
        if _storage._uploadMbps64TcpConn != rhs_storage._uploadMbps64TcpConn {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RunIperfServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunIperfServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_s"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.durationS) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationS != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationS, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RunIperfServerRequest, rhs: SpaceX_API_Device_RunIperfServerRequest) -> Bool {
    if lhs.durationS != rhs.durationS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RunIperfServerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunIperfServerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RunIperfServerResponse, rhs: SpaceX_API_Device_RunIperfServerResponse) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetConnectionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetConnectionsRequest, rhs: SpaceX_API_Device_GetConnectionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetConnectionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SpaceX_API_Device_GetConnectionsResponse.ServiceConnection>.self, value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SpaceX_API_Device_GetConnectionsResponse.ServiceConnection>.self, value: self.services, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetConnectionsResponse, rhs: SpaceX_API_Device_GetConnectionsResponse) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetConnectionsResponse.ServiceConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_GetConnectionsResponse.protoMessageName + ".ServiceConnection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "seconds_since_success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.secondsSinceSuccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.secondsSinceSuccess != 0 {
      try visitor.visitSingularInt32Field(value: self.secondsSinceSuccess, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetConnectionsResponse.ServiceConnection, rhs: SpaceX_API_Device_GetConnectionsResponse.ServiceConnection) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.secondsSinceSuccess != rhs.secondsSinceSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetDeviceInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetDeviceInfoRequest, rhs: SpaceX_API_Device_GetDeviceInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetDeviceInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetDeviceInfoResponse, rhs: SpaceX_API_Device_GetDeviceInfoResponse) -> Bool {
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SetTrustedKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTrustedKeysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SetTrustedKeysRequest, rhs: SpaceX_API_Device_SetTrustedKeysRequest) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SetTrustedKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTrustedKeysResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SetTrustedKeysResponse, rhs: SpaceX_API_Device_SetTrustedKeysResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SetSkuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSkuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sku"),
    2: .standard(proto: "country_code"),
    4: .standard(proto: "apply_country_code"),
    5: .standard(proto: "pin_country_code"),
    6: .standard(proto: "custom_power_table"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sku) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.applyCountryCode) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.pinCountryCode) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.customPowerTable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sku.isEmpty {
      try visitor.visitSingularStringField(value: self.sku, fieldNumber: 1)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 2)
    }
    if self.applyCountryCode != false {
      try visitor.visitSingularBoolField(value: self.applyCountryCode, fieldNumber: 4)
    }
    if self.pinCountryCode != false {
      try visitor.visitSingularBoolField(value: self.pinCountryCode, fieldNumber: 5)
    }
    if self.customPowerTable != false {
      try visitor.visitSingularBoolField(value: self.customPowerTable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SetSkuRequest, rhs: SpaceX_API_Device_SetSkuRequest) -> Bool {
    if lhs.sku != rhs.sku {return false}
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.applyCountryCode != rhs.applyCountryCode {return false}
    if lhs.pinCountryCode != rhs.pinCountryCode {return false}
    if lhs.customPowerTable != rhs.customPowerTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SetSkuResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSkuResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SetSkuResponse, rhs: SpaceX_API_Device_SetSkuResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_UpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_UpdateRequest, rhs: SpaceX_API_Device_UpdateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_UpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_UpdateResponse, rhs: SpaceX_API_Device_UpdateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RestartControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestartControlRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RestartControlRequest, rhs: SpaceX_API_Device_RestartControlRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_RestartControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestartControlResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_RestartControlResponse, rhs: SpaceX_API_Device_RestartControlResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetNetworkInterfacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNetworkInterfacesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetNetworkInterfacesRequest, rhs: SpaceX_API_Device_GetNetworkInterfacesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetNetworkInterfacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNetworkInterfacesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1006: .standard(proto: "network_interfaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1006: try { try decoder.decodeRepeatedMessageField(value: &self.networkInterfaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networkInterfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networkInterfaces, fieldNumber: 1006)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetNetworkInterfacesResponse, rhs: SpaceX_API_Device_GetNetworkInterfacesResponse) -> Bool {
    if lhs.networkInterfaces != rhs.networkInterfaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetRadioStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRadioStatsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetRadioStatsRequest, rhs: SpaceX_API_Device_GetRadioStatsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetRadioStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRadioStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "radio_stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.radioStats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.radioStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.radioStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetRadioStatsResponse, rhs: SpaceX_API_Device_GetRadioStatsResponse) -> Bool {
    if lhs.radioStats != rhs.radioStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetHeapDumpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeapDumpRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetHeapDumpRequest, rhs: SpaceX_API_Device_GetHeapDumpRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetHeapDumpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeapDumpResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "heap_dump"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.heapDump) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.heapDump.isEmpty {
      try visitor.visitSingularStringField(value: self.heapDump, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetHeapDumpResponse, rhs: SpaceX_API_Device_GetHeapDumpResponse) -> Bool {
    if lhs.heapDump != rhs.heapDump {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .auto {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetLocationRequest, rhs: SpaceX_API_Device_GetLocationRequest) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetLocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lla"),
    4: .standard(proto: "sigma_m"),
    3: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lla) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.sigmaM) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lla {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.source != .auto {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 3)
    }
    if self.sigmaM.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.sigmaM, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetLocationResponse, rhs: SpaceX_API_Device_GetLocationResponse) -> Bool {
    if lhs._lla != rhs._lla {return false}
    if lhs.sigmaM != rhs.sigmaM {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishSetEmcRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishSetEmcRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "theta"),
    2: .same(proto: "phi"),
    3: .standard(proto: "rx_chan"),
    4: .standard(proto: "tx_chan"),
    5: .same(proto: "modulation"),
    7: .standard(proto: "desired_tilt_angle"),
    8: .standard(proto: "chan_override"),
    9: .standard(proto: "theta_enabled"),
    10: .standard(proto: "phi_enabled"),
    11: .same(proto: "idle"),
    12: .standard(proto: "fast_switching"),
    13: .standard(proto: "sky_search"),
    14: .standard(proto: "force_pll_unlock"),
    15: .standard(proto: "force_eirp_failure"),
    16: .standard(proto: "snow_active_override"),
    18: .standard(proto: "manual_tilting"),
    19: .standard(proto: "tilt_to_stowed"),
    20: .same(proto: "reboot"),
    21: .standard(proto: "continuous_motor_test"),
    22: .standard(proto: "distance_override_meters"),
    23: .standard(proto: "amplitude_taper_override"),
    24: .standard(proto: "country_code_override"),
    25: .standard(proto: "tx_duty_cycle_override"),
    26: .standard(proto: "rx_duty_cycle_override"),
    27: .standard(proto: "eirp_legal_limit_dbw_override"),
    28: .standard(proto: "eirp_adjustment_db"),
  ]

  fileprivate class _StorageClass {
    var _theta: Double = 0
    var _phi: Double = 0
    var _rxChan: UInt32 = 0
    var _txChan: UInt32 = 0
    var _modulation: UInt32 = 0
    var _desiredTiltAngle: Double = 0
    var _chanOverride: Bool = false
    var _thetaEnabled: Bool = false
    var _phiEnabled: Bool = false
    var _idle: Bool = false
    var _fastSwitching: Bool = false
    var _skySearch: Bool = false
    var _forcePllUnlock: Bool = false
    var _forceEirpFailure: Bool = false
    var _snowActiveOverride: Bool = false
    var _manualTilting: Bool = false
    var _tiltToStowed: Bool = false
    var _reboot: Bool = false
    var _continuousMotorTest: Bool = false
    var _distanceOverrideMeters: Double = 0
    var _amplitudeTaperOverride: UInt32 = 0
    var _countryCodeOverride: UInt32 = 0
    var _txDutyCycleOverride: Int32 = 0
    var _rxDutyCycleOverride: Int32 = 0
    var _eirpLegalLimitDbwOverride: Double = 0
    var _eirpAdjustmentDb: Double = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _theta = source._theta
      _phi = source._phi
      _rxChan = source._rxChan
      _txChan = source._txChan
      _modulation = source._modulation
      _desiredTiltAngle = source._desiredTiltAngle
      _chanOverride = source._chanOverride
      _thetaEnabled = source._thetaEnabled
      _phiEnabled = source._phiEnabled
      _idle = source._idle
      _fastSwitching = source._fastSwitching
      _skySearch = source._skySearch
      _forcePllUnlock = source._forcePllUnlock
      _forceEirpFailure = source._forceEirpFailure
      _snowActiveOverride = source._snowActiveOverride
      _manualTilting = source._manualTilting
      _tiltToStowed = source._tiltToStowed
      _reboot = source._reboot
      _continuousMotorTest = source._continuousMotorTest
      _distanceOverrideMeters = source._distanceOverrideMeters
      _amplitudeTaperOverride = source._amplitudeTaperOverride
      _countryCodeOverride = source._countryCodeOverride
      _txDutyCycleOverride = source._txDutyCycleOverride
      _rxDutyCycleOverride = source._rxDutyCycleOverride
      _eirpLegalLimitDbwOverride = source._eirpLegalLimitDbwOverride
      _eirpAdjustmentDb = source._eirpAdjustmentDb
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularDoubleField(value: &_storage._theta) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._phi) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._rxChan) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._txChan) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._modulation) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._desiredTiltAngle) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._chanOverride) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._thetaEnabled) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._phiEnabled) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._idle) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._fastSwitching) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._skySearch) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._forcePllUnlock) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._forceEirpFailure) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._snowActiveOverride) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._manualTilting) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._tiltToStowed) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._reboot) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._continuousMotorTest) }()
        case 22: try { try decoder.decodeSingularDoubleField(value: &_storage._distanceOverrideMeters) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._amplitudeTaperOverride) }()
        case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._countryCodeOverride) }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._txDutyCycleOverride) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._rxDutyCycleOverride) }()
        case 27: try { try decoder.decodeSingularDoubleField(value: &_storage._eirpLegalLimitDbwOverride) }()
        case 28: try { try decoder.decodeSingularDoubleField(value: &_storage._eirpAdjustmentDb) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._theta.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._theta, fieldNumber: 1)
      }
      if _storage._phi.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._phi, fieldNumber: 2)
      }
      if _storage._rxChan != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rxChan, fieldNumber: 3)
      }
      if _storage._txChan != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._txChan, fieldNumber: 4)
      }
      if _storage._modulation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._modulation, fieldNumber: 5)
      }
      if _storage._desiredTiltAngle.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._desiredTiltAngle, fieldNumber: 7)
      }
      if _storage._chanOverride != false {
        try visitor.visitSingularBoolField(value: _storage._chanOverride, fieldNumber: 8)
      }
      if _storage._thetaEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._thetaEnabled, fieldNumber: 9)
      }
      if _storage._phiEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._phiEnabled, fieldNumber: 10)
      }
      if _storage._idle != false {
        try visitor.visitSingularBoolField(value: _storage._idle, fieldNumber: 11)
      }
      if _storage._fastSwitching != false {
        try visitor.visitSingularBoolField(value: _storage._fastSwitching, fieldNumber: 12)
      }
      if _storage._skySearch != false {
        try visitor.visitSingularBoolField(value: _storage._skySearch, fieldNumber: 13)
      }
      if _storage._forcePllUnlock != false {
        try visitor.visitSingularBoolField(value: _storage._forcePllUnlock, fieldNumber: 14)
      }
      if _storage._forceEirpFailure != false {
        try visitor.visitSingularBoolField(value: _storage._forceEirpFailure, fieldNumber: 15)
      }
      if _storage._snowActiveOverride != false {
        try visitor.visitSingularBoolField(value: _storage._snowActiveOverride, fieldNumber: 16)
      }
      if _storage._manualTilting != false {
        try visitor.visitSingularBoolField(value: _storage._manualTilting, fieldNumber: 18)
      }
      if _storage._tiltToStowed != false {
        try visitor.visitSingularBoolField(value: _storage._tiltToStowed, fieldNumber: 19)
      }
      if _storage._reboot != false {
        try visitor.visitSingularBoolField(value: _storage._reboot, fieldNumber: 20)
      }
      if _storage._continuousMotorTest != false {
        try visitor.visitSingularBoolField(value: _storage._continuousMotorTest, fieldNumber: 21)
      }
      if _storage._distanceOverrideMeters.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._distanceOverrideMeters, fieldNumber: 22)
      }
      if _storage._amplitudeTaperOverride != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._amplitudeTaperOverride, fieldNumber: 23)
      }
      if _storage._countryCodeOverride != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._countryCodeOverride, fieldNumber: 24)
      }
      if _storage._txDutyCycleOverride != 0 {
        try visitor.visitSingularInt32Field(value: _storage._txDutyCycleOverride, fieldNumber: 25)
      }
      if _storage._rxDutyCycleOverride != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rxDutyCycleOverride, fieldNumber: 26)
      }
      if _storage._eirpLegalLimitDbwOverride.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._eirpLegalLimitDbwOverride, fieldNumber: 27)
      }
      if _storage._eirpAdjustmentDb.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._eirpAdjustmentDb, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishSetEmcRequest, rhs: SpaceX_API_Device_DishSetEmcRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._theta != rhs_storage._theta {return false}
        if _storage._phi != rhs_storage._phi {return false}
        if _storage._rxChan != rhs_storage._rxChan {return false}
        if _storage._txChan != rhs_storage._txChan {return false}
        if _storage._modulation != rhs_storage._modulation {return false}
        if _storage._desiredTiltAngle != rhs_storage._desiredTiltAngle {return false}
        if _storage._chanOverride != rhs_storage._chanOverride {return false}
        if _storage._thetaEnabled != rhs_storage._thetaEnabled {return false}
        if _storage._phiEnabled != rhs_storage._phiEnabled {return false}
        if _storage._idle != rhs_storage._idle {return false}
        if _storage._fastSwitching != rhs_storage._fastSwitching {return false}
        if _storage._skySearch != rhs_storage._skySearch {return false}
        if _storage._forcePllUnlock != rhs_storage._forcePllUnlock {return false}
        if _storage._forceEirpFailure != rhs_storage._forceEirpFailure {return false}
        if _storage._snowActiveOverride != rhs_storage._snowActiveOverride {return false}
        if _storage._manualTilting != rhs_storage._manualTilting {return false}
        if _storage._tiltToStowed != rhs_storage._tiltToStowed {return false}
        if _storage._reboot != rhs_storage._reboot {return false}
        if _storage._continuousMotorTest != rhs_storage._continuousMotorTest {return false}
        if _storage._distanceOverrideMeters != rhs_storage._distanceOverrideMeters {return false}
        if _storage._amplitudeTaperOverride != rhs_storage._amplitudeTaperOverride {return false}
        if _storage._countryCodeOverride != rhs_storage._countryCodeOverride {return false}
        if _storage._txDutyCycleOverride != rhs_storage._txDutyCycleOverride {return false}
        if _storage._rxDutyCycleOverride != rhs_storage._rxDutyCycleOverride {return false}
        if _storage._eirpLegalLimitDbwOverride != rhs_storage._eirpLegalLimitDbwOverride {return false}
        if _storage._eirpAdjustmentDb != rhs_storage._eirpAdjustmentDb {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishSetEmcResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishSetEmcResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishSetEmcResponse, rhs: SpaceX_API_Device_DishSetEmcResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishSetMaxPowerTestModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishSetMaxPowerTestModeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishSetMaxPowerTestModeRequest, rhs: SpaceX_API_Device_DishSetMaxPowerTestModeRequest) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishSetMaxPowerTestModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishSetMaxPowerTestModeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishSetMaxPowerTestModeResponse, rhs: SpaceX_API_Device_DishSetMaxPowerTestModeResponse) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetEmcRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetEmcRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetEmcRequest, rhs: SpaceX_API_Device_DishGetEmcRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetEmcResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetEmcResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uuid"),
    3: .same(proto: "timestamp"),
    11: .standard(proto: "cplane_updates"),
    16: .standard(proto: "gps_latitude"),
    17: .standard(proto: "gps_longitude"),
    18: .standard(proto: "gps_pdop"),
    19: .standard(proto: "rf_mode"),
    20: .same(proto: "phi"),
    21: .same(proto: "theta"),
    22: .standard(proto: "rx_channel"),
    23: .standard(proto: "tx_channel"),
    24: .standard(proto: "t_dbf_max"),
    25: .standard(proto: "t_center"),
    30: .standard(proto: "auto_power_snow_melt_enabled"),
    32: .same(proto: "voltage"),
    33: .standard(proto: "rx_beam_state"),
    34: .standard(proto: "tx_beam_state"),
    35: .standard(proto: "half_duplex_state"),
    36: .standard(proto: "manual_tilt_enabled"),
    37: .standard(proto: "tilt_angle"),
    38: .standard(proto: "pll_tx_lock_detected"),
    39: .standard(proto: "eirp_exceeded_threshold"),
    41: .standard(proto: "idle_override_enabled"),
    42: .standard(proto: "theta_override_enabled"),
    43: .standard(proto: "theta_override_value"),
    44: .standard(proto: "phi_override_enabled"),
    45: .standard(proto: "phi_override_value"),
    46: .standard(proto: "rx_chan_override_value"),
    47: .standard(proto: "tx_chan_override_value"),
    48: .standard(proto: "sky_search_override_enabled"),
    49: .standard(proto: "fast_switching_enabled"),
    50: .standard(proto: "modulation_override_value"),
    51: .standard(proto: "force_eirp_failure"),
    52: .standard(proto: "force_pll_unlock"),
    53: .standard(proto: "ut_ine_success"),
    54: .standard(proto: "rf_ready"),
    55: .standard(proto: "tilt_to_stowed"),
    56: .same(proto: "reboot"),
    57: .standard(proto: "continuous_motor_test"),
    58: .standard(proto: "distance_override_meters"),
    59: .standard(proto: "amplitude_taper_override"),
    60: .standard(proto: "amplitude_taper_enabled"),
    61: .standard(proto: "amplitude_taper_scale"),
    62: .standard(proto: "country_code_override"),
    63: .standard(proto: "max_pointing_distance"),
    64: .standard(proto: "distance_scaling_factor"),
    65: .standard(proto: "tx_duty_cycle_override"),
    66: .standard(proto: "rx_duty_cycle_override"),
    67: .standard(proto: "tx_time_ms"),
    68: .standard(proto: "rx_time_ms"),
    69: .standard(proto: "eirp_legal_limit_dbw"),
    70: .standard(proto: "eirp_legal_limit_dbw_override"),
    71: .standard(proto: "eirp_adjustment_db"),
    72: .standard(proto: "eirp_predicted_dbw"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _timestamp: UInt64 = 0
    var _cplaneUpdates: UInt32 = 0
    var _gpsLatitude: Double = 0
    var _gpsLongitude: Double = 0
    var _gpsPdop: Double = 0
    var _rfMode: UInt32 = 0
    var _phi: Double = 0
    var _theta: Double = 0
    var _rxChannel: UInt32 = 0
    var _txChannel: UInt32 = 0
    var _tDbfMax: Float = 0
    var _tCenter: Double = 0
    var _autoPowerSnowMeltEnabled: Bool = false
    var _voltage: Double = 0
    var _rxBeamState: UInt32 = 0
    var _txBeamState: UInt32 = 0
    var _halfDuplexState: UInt32 = 0
    var _manualTiltEnabled: Bool = false
    var _tiltAngle: Double = 0
    var _pllTxLockDetected: UInt32 = 0
    var _eirpExceededThreshold: Bool = false
    var _idleOverrideEnabled: Bool = false
    var _thetaOverrideEnabled: Bool = false
    var _thetaOverrideValue: Double = 0
    var _phiOverrideEnabled: Bool = false
    var _phiOverrideValue: Double = 0
    var _rxChanOverrideValue: UInt32 = 0
    var _txChanOverrideValue: UInt32 = 0
    var _skySearchOverrideEnabled: Bool = false
    var _fastSwitchingEnabled: Bool = false
    var _modulationOverrideValue: UInt32 = 0
    var _forceEirpFailure: Bool = false
    var _forcePllUnlock: Bool = false
    var _utIneSuccess: UInt32 = 0
    var _rfReady: Bool = false
    var _tiltToStowed: Bool = false
    var _reboot: Bool = false
    var _continuousMotorTest: Bool = false
    var _distanceOverrideMeters: Double = 0
    var _amplitudeTaperOverride: UInt32 = 0
    var _amplitudeTaperEnabled: Bool = false
    var _amplitudeTaperScale: Double = 0
    var _countryCodeOverride: UInt32 = 0
    var _maxPointingDistance: Double = 0
    var _distanceScalingFactor: Double = 0
    var _txDutyCycleOverride: Int32 = 0
    var _rxDutyCycleOverride: Int32 = 0
    var _txTimeMs: Float = 0
    var _rxTimeMs: Float = 0
    var _eirpLegalLimitDbw: Double = 0
    var _eirpLegalLimitDbwOverride: Double = 0
    var _eirpAdjustmentDb: Double = 0
    var _eirpPredictedDbw: Double = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _timestamp = source._timestamp
      _cplaneUpdates = source._cplaneUpdates
      _gpsLatitude = source._gpsLatitude
      _gpsLongitude = source._gpsLongitude
      _gpsPdop = source._gpsPdop
      _rfMode = source._rfMode
      _phi = source._phi
      _theta = source._theta
      _rxChannel = source._rxChannel
      _txChannel = source._txChannel
      _tDbfMax = source._tDbfMax
      _tCenter = source._tCenter
      _autoPowerSnowMeltEnabled = source._autoPowerSnowMeltEnabled
      _voltage = source._voltage
      _rxBeamState = source._rxBeamState
      _txBeamState = source._txBeamState
      _halfDuplexState = source._halfDuplexState
      _manualTiltEnabled = source._manualTiltEnabled
      _tiltAngle = source._tiltAngle
      _pllTxLockDetected = source._pllTxLockDetected
      _eirpExceededThreshold = source._eirpExceededThreshold
      _idleOverrideEnabled = source._idleOverrideEnabled
      _thetaOverrideEnabled = source._thetaOverrideEnabled
      _thetaOverrideValue = source._thetaOverrideValue
      _phiOverrideEnabled = source._phiOverrideEnabled
      _phiOverrideValue = source._phiOverrideValue
      _rxChanOverrideValue = source._rxChanOverrideValue
      _txChanOverrideValue = source._txChanOverrideValue
      _skySearchOverrideEnabled = source._skySearchOverrideEnabled
      _fastSwitchingEnabled = source._fastSwitchingEnabled
      _modulationOverrideValue = source._modulationOverrideValue
      _forceEirpFailure = source._forceEirpFailure
      _forcePllUnlock = source._forcePllUnlock
      _utIneSuccess = source._utIneSuccess
      _rfReady = source._rfReady
      _tiltToStowed = source._tiltToStowed
      _reboot = source._reboot
      _continuousMotorTest = source._continuousMotorTest
      _distanceOverrideMeters = source._distanceOverrideMeters
      _amplitudeTaperOverride = source._amplitudeTaperOverride
      _amplitudeTaperEnabled = source._amplitudeTaperEnabled
      _amplitudeTaperScale = source._amplitudeTaperScale
      _countryCodeOverride = source._countryCodeOverride
      _maxPointingDistance = source._maxPointingDistance
      _distanceScalingFactor = source._distanceScalingFactor
      _txDutyCycleOverride = source._txDutyCycleOverride
      _rxDutyCycleOverride = source._rxDutyCycleOverride
      _txTimeMs = source._txTimeMs
      _rxTimeMs = source._rxTimeMs
      _eirpLegalLimitDbw = source._eirpLegalLimitDbw
      _eirpLegalLimitDbwOverride = source._eirpLegalLimitDbwOverride
      _eirpAdjustmentDb = source._eirpAdjustmentDb
      _eirpPredictedDbw = source._eirpPredictedDbw
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._cplaneUpdates) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._gpsLatitude) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._gpsLongitude) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._gpsPdop) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._rfMode) }()
        case 20: try { try decoder.decodeSingularDoubleField(value: &_storage._phi) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._theta) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._rxChannel) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._txChannel) }()
        case 24: try { try decoder.decodeSingularFloatField(value: &_storage._tDbfMax) }()
        case 25: try { try decoder.decodeSingularDoubleField(value: &_storage._tCenter) }()
        case 30: try { try decoder.decodeSingularBoolField(value: &_storage._autoPowerSnowMeltEnabled) }()
        case 32: try { try decoder.decodeSingularDoubleField(value: &_storage._voltage) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._rxBeamState) }()
        case 34: try { try decoder.decodeSingularUInt32Field(value: &_storage._txBeamState) }()
        case 35: try { try decoder.decodeSingularUInt32Field(value: &_storage._halfDuplexState) }()
        case 36: try { try decoder.decodeSingularBoolField(value: &_storage._manualTiltEnabled) }()
        case 37: try { try decoder.decodeSingularDoubleField(value: &_storage._tiltAngle) }()
        case 38: try { try decoder.decodeSingularUInt32Field(value: &_storage._pllTxLockDetected) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._eirpExceededThreshold) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._idleOverrideEnabled) }()
        case 42: try { try decoder.decodeSingularBoolField(value: &_storage._thetaOverrideEnabled) }()
        case 43: try { try decoder.decodeSingularDoubleField(value: &_storage._thetaOverrideValue) }()
        case 44: try { try decoder.decodeSingularBoolField(value: &_storage._phiOverrideEnabled) }()
        case 45: try { try decoder.decodeSingularDoubleField(value: &_storage._phiOverrideValue) }()
        case 46: try { try decoder.decodeSingularUInt32Field(value: &_storage._rxChanOverrideValue) }()
        case 47: try { try decoder.decodeSingularUInt32Field(value: &_storage._txChanOverrideValue) }()
        case 48: try { try decoder.decodeSingularBoolField(value: &_storage._skySearchOverrideEnabled) }()
        case 49: try { try decoder.decodeSingularBoolField(value: &_storage._fastSwitchingEnabled) }()
        case 50: try { try decoder.decodeSingularUInt32Field(value: &_storage._modulationOverrideValue) }()
        case 51: try { try decoder.decodeSingularBoolField(value: &_storage._forceEirpFailure) }()
        case 52: try { try decoder.decodeSingularBoolField(value: &_storage._forcePllUnlock) }()
        case 53: try { try decoder.decodeSingularUInt32Field(value: &_storage._utIneSuccess) }()
        case 54: try { try decoder.decodeSingularBoolField(value: &_storage._rfReady) }()
        case 55: try { try decoder.decodeSingularBoolField(value: &_storage._tiltToStowed) }()
        case 56: try { try decoder.decodeSingularBoolField(value: &_storage._reboot) }()
        case 57: try { try decoder.decodeSingularBoolField(value: &_storage._continuousMotorTest) }()
        case 58: try { try decoder.decodeSingularDoubleField(value: &_storage._distanceOverrideMeters) }()
        case 59: try { try decoder.decodeSingularUInt32Field(value: &_storage._amplitudeTaperOverride) }()
        case 60: try { try decoder.decodeSingularBoolField(value: &_storage._amplitudeTaperEnabled) }()
        case 61: try { try decoder.decodeSingularDoubleField(value: &_storage._amplitudeTaperScale) }()
        case 62: try { try decoder.decodeSingularUInt32Field(value: &_storage._countryCodeOverride) }()
        case 63: try { try decoder.decodeSingularDoubleField(value: &_storage._maxPointingDistance) }()
        case 64: try { try decoder.decodeSingularDoubleField(value: &_storage._distanceScalingFactor) }()
        case 65: try { try decoder.decodeSingularInt32Field(value: &_storage._txDutyCycleOverride) }()
        case 66: try { try decoder.decodeSingularInt32Field(value: &_storage._rxDutyCycleOverride) }()
        case 67: try { try decoder.decodeSingularFloatField(value: &_storage._txTimeMs) }()
        case 68: try { try decoder.decodeSingularFloatField(value: &_storage._rxTimeMs) }()
        case 69: try { try decoder.decodeSingularDoubleField(value: &_storage._eirpLegalLimitDbw) }()
        case 70: try { try decoder.decodeSingularDoubleField(value: &_storage._eirpLegalLimitDbwOverride) }()
        case 71: try { try decoder.decodeSingularDoubleField(value: &_storage._eirpAdjustmentDb) }()
        case 72: try { try decoder.decodeSingularDoubleField(value: &_storage._eirpPredictedDbw) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 2)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestamp, fieldNumber: 3)
      }
      if _storage._cplaneUpdates != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._cplaneUpdates, fieldNumber: 11)
      }
      if _storage._gpsLatitude.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._gpsLatitude, fieldNumber: 16)
      }
      if _storage._gpsLongitude.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._gpsLongitude, fieldNumber: 17)
      }
      if _storage._gpsPdop.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._gpsPdop, fieldNumber: 18)
      }
      if _storage._rfMode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rfMode, fieldNumber: 19)
      }
      if _storage._phi.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._phi, fieldNumber: 20)
      }
      if _storage._theta.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._theta, fieldNumber: 21)
      }
      if _storage._rxChannel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rxChannel, fieldNumber: 22)
      }
      if _storage._txChannel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._txChannel, fieldNumber: 23)
      }
      if _storage._tDbfMax.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._tDbfMax, fieldNumber: 24)
      }
      if _storage._tCenter.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._tCenter, fieldNumber: 25)
      }
      if _storage._autoPowerSnowMeltEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._autoPowerSnowMeltEnabled, fieldNumber: 30)
      }
      if _storage._voltage.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._voltage, fieldNumber: 32)
      }
      if _storage._rxBeamState != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rxBeamState, fieldNumber: 33)
      }
      if _storage._txBeamState != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._txBeamState, fieldNumber: 34)
      }
      if _storage._halfDuplexState != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._halfDuplexState, fieldNumber: 35)
      }
      if _storage._manualTiltEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._manualTiltEnabled, fieldNumber: 36)
      }
      if _storage._tiltAngle.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._tiltAngle, fieldNumber: 37)
      }
      if _storage._pllTxLockDetected != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pllTxLockDetected, fieldNumber: 38)
      }
      if _storage._eirpExceededThreshold != false {
        try visitor.visitSingularBoolField(value: _storage._eirpExceededThreshold, fieldNumber: 39)
      }
      if _storage._idleOverrideEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._idleOverrideEnabled, fieldNumber: 41)
      }
      if _storage._thetaOverrideEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._thetaOverrideEnabled, fieldNumber: 42)
      }
      if _storage._thetaOverrideValue.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._thetaOverrideValue, fieldNumber: 43)
      }
      if _storage._phiOverrideEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._phiOverrideEnabled, fieldNumber: 44)
      }
      if _storage._phiOverrideValue.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._phiOverrideValue, fieldNumber: 45)
      }
      if _storage._rxChanOverrideValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rxChanOverrideValue, fieldNumber: 46)
      }
      if _storage._txChanOverrideValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._txChanOverrideValue, fieldNumber: 47)
      }
      if _storage._skySearchOverrideEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._skySearchOverrideEnabled, fieldNumber: 48)
      }
      if _storage._fastSwitchingEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._fastSwitchingEnabled, fieldNumber: 49)
      }
      if _storage._modulationOverrideValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._modulationOverrideValue, fieldNumber: 50)
      }
      if _storage._forceEirpFailure != false {
        try visitor.visitSingularBoolField(value: _storage._forceEirpFailure, fieldNumber: 51)
      }
      if _storage._forcePllUnlock != false {
        try visitor.visitSingularBoolField(value: _storage._forcePllUnlock, fieldNumber: 52)
      }
      if _storage._utIneSuccess != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._utIneSuccess, fieldNumber: 53)
      }
      if _storage._rfReady != false {
        try visitor.visitSingularBoolField(value: _storage._rfReady, fieldNumber: 54)
      }
      if _storage._tiltToStowed != false {
        try visitor.visitSingularBoolField(value: _storage._tiltToStowed, fieldNumber: 55)
      }
      if _storage._reboot != false {
        try visitor.visitSingularBoolField(value: _storage._reboot, fieldNumber: 56)
      }
      if _storage._continuousMotorTest != false {
        try visitor.visitSingularBoolField(value: _storage._continuousMotorTest, fieldNumber: 57)
      }
      if _storage._distanceOverrideMeters.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._distanceOverrideMeters, fieldNumber: 58)
      }
      if _storage._amplitudeTaperOverride != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._amplitudeTaperOverride, fieldNumber: 59)
      }
      if _storage._amplitudeTaperEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._amplitudeTaperEnabled, fieldNumber: 60)
      }
      if _storage._amplitudeTaperScale.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._amplitudeTaperScale, fieldNumber: 61)
      }
      if _storage._countryCodeOverride != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._countryCodeOverride, fieldNumber: 62)
      }
      if _storage._maxPointingDistance.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._maxPointingDistance, fieldNumber: 63)
      }
      if _storage._distanceScalingFactor.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._distanceScalingFactor, fieldNumber: 64)
      }
      if _storage._txDutyCycleOverride != 0 {
        try visitor.visitSingularInt32Field(value: _storage._txDutyCycleOverride, fieldNumber: 65)
      }
      if _storage._rxDutyCycleOverride != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rxDutyCycleOverride, fieldNumber: 66)
      }
      if _storage._txTimeMs.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._txTimeMs, fieldNumber: 67)
      }
      if _storage._rxTimeMs.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._rxTimeMs, fieldNumber: 68)
      }
      if _storage._eirpLegalLimitDbw.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._eirpLegalLimitDbw, fieldNumber: 69)
      }
      if _storage._eirpLegalLimitDbwOverride.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._eirpLegalLimitDbwOverride, fieldNumber: 70)
      }
      if _storage._eirpAdjustmentDb.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._eirpAdjustmentDb, fieldNumber: 71)
      }
      if _storage._eirpPredictedDbw.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._eirpPredictedDbw, fieldNumber: 72)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetEmcResponse, rhs: SpaceX_API_Device_DishGetEmcResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._cplaneUpdates != rhs_storage._cplaneUpdates {return false}
        if _storage._gpsLatitude != rhs_storage._gpsLatitude {return false}
        if _storage._gpsLongitude != rhs_storage._gpsLongitude {return false}
        if _storage._gpsPdop != rhs_storage._gpsPdop {return false}
        if _storage._rfMode != rhs_storage._rfMode {return false}
        if _storage._phi != rhs_storage._phi {return false}
        if _storage._theta != rhs_storage._theta {return false}
        if _storage._rxChannel != rhs_storage._rxChannel {return false}
        if _storage._txChannel != rhs_storage._txChannel {return false}
        if _storage._tDbfMax != rhs_storage._tDbfMax {return false}
        if _storage._tCenter != rhs_storage._tCenter {return false}
        if _storage._autoPowerSnowMeltEnabled != rhs_storage._autoPowerSnowMeltEnabled {return false}
        if _storage._voltage != rhs_storage._voltage {return false}
        if _storage._rxBeamState != rhs_storage._rxBeamState {return false}
        if _storage._txBeamState != rhs_storage._txBeamState {return false}
        if _storage._halfDuplexState != rhs_storage._halfDuplexState {return false}
        if _storage._manualTiltEnabled != rhs_storage._manualTiltEnabled {return false}
        if _storage._tiltAngle != rhs_storage._tiltAngle {return false}
        if _storage._pllTxLockDetected != rhs_storage._pllTxLockDetected {return false}
        if _storage._eirpExceededThreshold != rhs_storage._eirpExceededThreshold {return false}
        if _storage._idleOverrideEnabled != rhs_storage._idleOverrideEnabled {return false}
        if _storage._thetaOverrideEnabled != rhs_storage._thetaOverrideEnabled {return false}
        if _storage._thetaOverrideValue != rhs_storage._thetaOverrideValue {return false}
        if _storage._phiOverrideEnabled != rhs_storage._phiOverrideEnabled {return false}
        if _storage._phiOverrideValue != rhs_storage._phiOverrideValue {return false}
        if _storage._rxChanOverrideValue != rhs_storage._rxChanOverrideValue {return false}
        if _storage._txChanOverrideValue != rhs_storage._txChanOverrideValue {return false}
        if _storage._skySearchOverrideEnabled != rhs_storage._skySearchOverrideEnabled {return false}
        if _storage._fastSwitchingEnabled != rhs_storage._fastSwitchingEnabled {return false}
        if _storage._modulationOverrideValue != rhs_storage._modulationOverrideValue {return false}
        if _storage._forceEirpFailure != rhs_storage._forceEirpFailure {return false}
        if _storage._forcePllUnlock != rhs_storage._forcePllUnlock {return false}
        if _storage._utIneSuccess != rhs_storage._utIneSuccess {return false}
        if _storage._rfReady != rhs_storage._rfReady {return false}
        if _storage._tiltToStowed != rhs_storage._tiltToStowed {return false}
        if _storage._reboot != rhs_storage._reboot {return false}
        if _storage._continuousMotorTest != rhs_storage._continuousMotorTest {return false}
        if _storage._distanceOverrideMeters != rhs_storage._distanceOverrideMeters {return false}
        if _storage._amplitudeTaperOverride != rhs_storage._amplitudeTaperOverride {return false}
        if _storage._amplitudeTaperEnabled != rhs_storage._amplitudeTaperEnabled {return false}
        if _storage._amplitudeTaperScale != rhs_storage._amplitudeTaperScale {return false}
        if _storage._countryCodeOverride != rhs_storage._countryCodeOverride {return false}
        if _storage._maxPointingDistance != rhs_storage._maxPointingDistance {return false}
        if _storage._distanceScalingFactor != rhs_storage._distanceScalingFactor {return false}
        if _storage._txDutyCycleOverride != rhs_storage._txDutyCycleOverride {return false}
        if _storage._rxDutyCycleOverride != rhs_storage._rxDutyCycleOverride {return false}
        if _storage._txTimeMs != rhs_storage._txTimeMs {return false}
        if _storage._rxTimeMs != rhs_storage._rxTimeMs {return false}
        if _storage._eirpLegalLimitDbw != rhs_storage._eirpLegalLimitDbw {return false}
        if _storage._eirpLegalLimitDbwOverride != rhs_storage._eirpLegalLimitDbwOverride {return false}
        if _storage._eirpAdjustmentDb != rhs_storage._eirpAdjustmentDb {return false}
        if _storage._eirpPredictedDbw != rhs_storage._eirpPredictedDbw {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetPersistentStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPersistentStatsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetPersistentStatsRequest, rhs: SpaceX_API_Device_GetPersistentStatsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_StartSpeedtestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartSpeedtestRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_StartSpeedtestRequest, rhs: SpaceX_API_Device_StartSpeedtestRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_StartSpeedtestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartSpeedtestResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_StartSpeedtestResponse, rhs: SpaceX_API_Device_StartSpeedtestResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SpeedtestStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpeedtestStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "running"),
    2: .same(proto: "id"),
    1000: .same(proto: "up"),
    1001: .same(proto: "down"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.running) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 1000: try { try decoder.decodeSingularMessageField(value: &self._up) }()
      case 1001: try { try decoder.decodeSingularMessageField(value: &self._down) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.running != false {
      try visitor.visitSingularBoolField(value: self.running, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    try { if let v = self._up {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    } }()
    try { if let v = self._down {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1001)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SpeedtestStatus, rhs: SpaceX_API_Device_SpeedtestStatus) -> Bool {
    if lhs.running != rhs.running {return false}
    if lhs.id != rhs.id {return false}
    if lhs._up != rhs._up {return false}
    if lhs._down != rhs._down {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_SpeedtestStatus.Direction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_SpeedtestStatus.protoMessageName + ".Direction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "throughputs_mbps"),
    2: .same(proto: "err"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.throughputsMbps) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.throughputsMbps.isEmpty {
      try visitor.visitPackedFloatField(value: self.throughputsMbps, fieldNumber: 1)
    }
    if self.err != .none {
      try visitor.visitSingularEnumField(value: self.err, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_SpeedtestStatus.Direction, rhs: SpaceX_API_Device_SpeedtestStatus.Direction) -> Bool {
    if lhs.throughputsMbps != rhs.throughputsMbps {return false}
    if lhs.err != rhs.err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetSpeedtestStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSpeedtestStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetSpeedtestStatusRequest, rhs: SpaceX_API_Device_GetSpeedtestStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetSpeedtestStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSpeedtestStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetSpeedtestStatusResponse, rhs: SpaceX_API_Device_GetSpeedtestStatusResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ReportClientSpeedtestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportClientSpeedtestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "client_speedtest"),
    5: .standard(proto: "wifi_speedtest"),
    3: .standard(proto: "client_rssi"),
    4: .standard(proto: "client_platform"),
    6: .standard(proto: "app_version"),
    7: .standard(proto: "app_build"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _clientSpeedtest: SpaceX_API_Device_SpeedTestStats? = nil
    var _wifiSpeedtest: SpaceX_API_Device_SpeedTestStats? = nil
    var _clientRssi: Float = 0
    var _clientPlatform: SpaceX_API_Device_ClientPlatform? = nil
    var _appVersion: String = String()
    var _appBuild: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _clientSpeedtest = source._clientSpeedtest
      _wifiSpeedtest = source._wifiSpeedtest
      _clientRssi = source._clientRssi
      _clientPlatform = source._clientPlatform
      _appVersion = source._appVersion
      _appBuild = source._appBuild
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._clientSpeedtest) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._clientRssi) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientPlatform) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._wifiSpeedtest) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._appVersion) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._appBuild) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._clientSpeedtest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._clientRssi.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._clientRssi, fieldNumber: 3)
      }
      try { if let v = _storage._clientPlatform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._wifiSpeedtest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._appVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appVersion, fieldNumber: 6)
      }
      if _storage._appBuild != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._appBuild, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ReportClientSpeedtestRequest, rhs: SpaceX_API_Device_ReportClientSpeedtestRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._clientSpeedtest != rhs_storage._clientSpeedtest {return false}
        if _storage._wifiSpeedtest != rhs_storage._wifiSpeedtest {return false}
        if _storage._clientRssi != rhs_storage._clientRssi {return false}
        if _storage._clientPlatform != rhs_storage._clientPlatform {return false}
        if _storage._appVersion != rhs_storage._appVersion {return false}
        if _storage._appBuild != rhs_storage._appBuild {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_ReportClientSpeedtestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportClientSpeedtestResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_ReportClientSpeedtestResponse, rhs: SpaceX_API_Device_ReportClientSpeedtestResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishPowerSaveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishPowerSaveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_save_start_minutes"),
    2: .standard(proto: "power_save_duration_minutes"),
    3: .standard(proto: "enable_power_save"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.powerSaveStartMinutes) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.powerSaveDurationMinutes) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enablePowerSave) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerSaveStartMinutes != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerSaveStartMinutes, fieldNumber: 1)
    }
    if self.powerSaveDurationMinutes != 0 {
      try visitor.visitSingularUInt32Field(value: self.powerSaveDurationMinutes, fieldNumber: 2)
    }
    if self.enablePowerSave != false {
      try visitor.visitSingularBoolField(value: self.enablePowerSave, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishPowerSaveRequest, rhs: SpaceX_API_Device_DishPowerSaveRequest) -> Bool {
    if lhs.powerSaveStartMinutes != rhs.powerSaveStartMinutes {return false}
    if lhs.powerSaveDurationMinutes != rhs.powerSaveDurationMinutes {return false}
    if lhs.enablePowerSave != rhs.enablePowerSave {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_IQCaptureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IQCaptureRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_IQCaptureRequest, rhs: SpaceX_API_Device_IQCaptureRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_GetDiagnosticsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDiagnosticsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_GetDiagnosticsRequest, rhs: SpaceX_API_Device_GetDiagnosticsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_WifiGetDiagnosticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WifiGetDiagnosticsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "hardware_version"),
    3: .standard(proto: "software_version"),
    4: .same(proto: "networks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hardwareVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.softwareVersion) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.networks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.hardwareVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.hardwareVersion, fieldNumber: 2)
    }
    if !self.softwareVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.softwareVersion, fieldNumber: 3)
    }
    if !self.networks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_WifiGetDiagnosticsResponse, rhs: SpaceX_API_Device_WifiGetDiagnosticsResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.hardwareVersion != rhs.hardwareVersion {return false}
    if lhs.softwareVersion != rhs.softwareVersion {return false}
    if lhs.networks != rhs.networks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_WifiGetDiagnosticsResponse.Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_WifiGetDiagnosticsResponse.protoMessageName + ".Network"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "ipv4"),
    3: .same(proto: "ipv6"),
    10: .standard(proto: "clients_ethernet"),
    11: .standard(proto: "clients_2ghz"),
    12: .standard(proto: "clients_5ghz"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ipv4) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ipv6) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.clientsEthernet) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.clients2Ghz) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.clients5Ghz) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.ipv4.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4, fieldNumber: 2)
    }
    if !self.ipv6.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipv6, fieldNumber: 3)
    }
    if self.clientsEthernet != 0 {
      try visitor.visitSingularUInt32Field(value: self.clientsEthernet, fieldNumber: 10)
    }
    if self.clients2Ghz != 0 {
      try visitor.visitSingularUInt32Field(value: self.clients2Ghz, fieldNumber: 11)
    }
    if self.clients5Ghz != 0 {
      try visitor.visitSingularUInt32Field(value: self.clients5Ghz, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_WifiGetDiagnosticsResponse.Network, rhs: SpaceX_API_Device_WifiGetDiagnosticsResponse.Network) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.ipv4 != rhs.ipv4 {return false}
    if lhs.ipv6 != rhs.ipv6 {return false}
    if lhs.clientsEthernet != rhs.clientsEthernet {return false}
    if lhs.clients2Ghz != rhs.clients2Ghz {return false}
    if lhs.clients5Ghz != rhs.clients5Ghz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetDiagnosticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishGetDiagnosticsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "hardware_version"),
    3: .standard(proto: "software_version"),
    4: .standard(proto: "utc_offset_s"),
    7: .standard(proto: "hardware_self_test"),
    5: .same(proto: "alerts"),
    6: .standard(proto: "disablement_code"),
    8: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _hardwareVersion: String = String()
    var _softwareVersion: String = String()
    var _utcOffsetS: Int32 = 0
    var _hardwareSelfTest: SpaceX_API_Device_DishGetDiagnosticsResponse.TestResult = .noResult
    var _alerts: SpaceX_API_Device_DishGetDiagnosticsResponse.Alerts? = nil
    var _disablementCode: SpaceX_API_Device_DishGetDiagnosticsResponse.DisablementCode = .unknown
    var _location: SpaceX_API_Device_DishGetDiagnosticsResponse.Location? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _hardwareVersion = source._hardwareVersion
      _softwareVersion = source._softwareVersion
      _utcOffsetS = source._utcOffsetS
      _hardwareSelfTest = source._hardwareSelfTest
      _alerts = source._alerts
      _disablementCode = source._disablementCode
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._hardwareVersion) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._softwareVersion) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._utcOffsetS) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._alerts) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._disablementCode) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._hardwareSelfTest) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._hardwareVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hardwareVersion, fieldNumber: 2)
      }
      if !_storage._softwareVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._softwareVersion, fieldNumber: 3)
      }
      if _storage._utcOffsetS != 0 {
        try visitor.visitSingularInt32Field(value: _storage._utcOffsetS, fieldNumber: 4)
      }
      try { if let v = _storage._alerts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._disablementCode != .unknown {
        try visitor.visitSingularEnumField(value: _storage._disablementCode, fieldNumber: 6)
      }
      if _storage._hardwareSelfTest != .noResult {
        try visitor.visitSingularEnumField(value: _storage._hardwareSelfTest, fieldNumber: 7)
      }
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetDiagnosticsResponse, rhs: SpaceX_API_Device_DishGetDiagnosticsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._hardwareVersion != rhs_storage._hardwareVersion {return false}
        if _storage._softwareVersion != rhs_storage._softwareVersion {return false}
        if _storage._utcOffsetS != rhs_storage._utcOffsetS {return false}
        if _storage._hardwareSelfTest != rhs_storage._hardwareSelfTest {return false}
        if _storage._alerts != rhs_storage._alerts {return false}
        if _storage._disablementCode != rhs_storage._disablementCode {return false}
        if _storage._location != rhs_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetDiagnosticsResponse.TestResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_RESULT"),
    1: .same(proto: "PASSED"),
    2: .same(proto: "FAILED"),
  ]
}

extension SpaceX_API_Device_DishGetDiagnosticsResponse.DisablementCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OKAY"),
    2: .same(proto: "NO_ACTIVE_ACCOUNT"),
    3: .same(proto: "TOO_FAR_FROM_SERVICE_ADDRESS"),
    4: .same(proto: "IN_OCEAN"),
    5: .same(proto: "INVALID_COUNTRY"),
    6: .same(proto: "BLOCKED_COUNTRY"),
    7: .same(proto: "DATA_OVERAGE_SANDBOX_POLICY"),
    8: .same(proto: "CELL_IS_DISABLED"),
    9: .same(proto: "UNLICENSED_COUNTRY"),
  ]
}

extension SpaceX_API_Device_DishGetDiagnosticsResponse.Alerts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_DishGetDiagnosticsResponse.protoMessageName + ".Alerts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dish_is_heating"),
    2: .standard(proto: "dish_thermal_throttle"),
    3: .standard(proto: "dish_thermal_shutdown"),
    4: .standard(proto: "power_supply_thermal_throttle"),
    5: .standard(proto: "motors_stuck"),
    6: .standard(proto: "mast_not_near_vertical"),
    7: .standard(proto: "slow_ethernet_speeds"),
    8: .standard(proto: "software_install_pending"),
    9: .standard(proto: "moving_too_fast_for_policy"),
    10: .same(proto: "obstructed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.dishIsHeating) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.dishThermalThrottle) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.dishThermalShutdown) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.powerSupplyThermalThrottle) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.motorsStuck) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.mastNotNearVertical) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.slowEthernetSpeeds) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.softwareInstallPending) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.movingTooFastForPolicy) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.obstructed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dishIsHeating != false {
      try visitor.visitSingularBoolField(value: self.dishIsHeating, fieldNumber: 1)
    }
    if self.dishThermalThrottle != false {
      try visitor.visitSingularBoolField(value: self.dishThermalThrottle, fieldNumber: 2)
    }
    if self.dishThermalShutdown != false {
      try visitor.visitSingularBoolField(value: self.dishThermalShutdown, fieldNumber: 3)
    }
    if self.powerSupplyThermalThrottle != false {
      try visitor.visitSingularBoolField(value: self.powerSupplyThermalThrottle, fieldNumber: 4)
    }
    if self.motorsStuck != false {
      try visitor.visitSingularBoolField(value: self.motorsStuck, fieldNumber: 5)
    }
    if self.mastNotNearVertical != false {
      try visitor.visitSingularBoolField(value: self.mastNotNearVertical, fieldNumber: 6)
    }
    if self.slowEthernetSpeeds != false {
      try visitor.visitSingularBoolField(value: self.slowEthernetSpeeds, fieldNumber: 7)
    }
    if self.softwareInstallPending != false {
      try visitor.visitSingularBoolField(value: self.softwareInstallPending, fieldNumber: 8)
    }
    if self.movingTooFastForPolicy != false {
      try visitor.visitSingularBoolField(value: self.movingTooFastForPolicy, fieldNumber: 9)
    }
    if self.obstructed != false {
      try visitor.visitSingularBoolField(value: self.obstructed, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetDiagnosticsResponse.Alerts, rhs: SpaceX_API_Device_DishGetDiagnosticsResponse.Alerts) -> Bool {
    if lhs.dishIsHeating != rhs.dishIsHeating {return false}
    if lhs.dishThermalThrottle != rhs.dishThermalThrottle {return false}
    if lhs.dishThermalShutdown != rhs.dishThermalShutdown {return false}
    if lhs.powerSupplyThermalThrottle != rhs.powerSupplyThermalThrottle {return false}
    if lhs.motorsStuck != rhs.motorsStuck {return false}
    if lhs.mastNotNearVertical != rhs.mastNotNearVertical {return false}
    if lhs.slowEthernetSpeeds != rhs.slowEthernetSpeeds {return false}
    if lhs.softwareInstallPending != rhs.softwareInstallPending {return false}
    if lhs.movingTooFastForPolicy != rhs.movingTooFastForPolicy {return false}
    if lhs.obstructed != rhs.obstructed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_DishGetDiagnosticsResponse.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SpaceX_API_Device_DishGetDiagnosticsResponse.protoMessageName + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "latitude"),
    3: .same(proto: "longitude"),
    4: .standard(proto: "altitude_meters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.altitudeMeters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.latitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.longitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 3)
    }
    if self.altitudeMeters.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.altitudeMeters, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_DishGetDiagnosticsResponse.Location, rhs: SpaceX_API_Device_DishGetDiagnosticsResponse.Location) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.altitudeMeters != rhs.altitudeMeters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_TcpConnectivityTestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TcpConnectivityTestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_TcpConnectivityTestRequest, rhs: SpaceX_API_Device_TcpConnectivityTestRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_UdpConnectivityTestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UdpConnectivityTestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "port"),
    3: .standard(proto: "probe_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.probeData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if self.probeData != .empty {
      try visitor.visitSingularEnumField(value: self.probeData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceX_API_Device_UdpConnectivityTestRequest, rhs: SpaceX_API_Device_UdpConnectivityTestRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.port != rhs.port {return false}
    if lhs.probeData != rhs.probeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceX_API_Device_UdpConnectivityTestRequest.UDPProbeDataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "DNS_STATUS_REQUEST"),
    2: .same(proto: "DTLS_CLIENT_HELLO"),
    3: .same(proto: "DNS_VERSION_BIND_REQ"),
    4: .same(proto: "RPC_CHECK"),
    5: .same(proto: "DNS_SD"),
    6: .same(proto: "SNMP_V1_PUBLIC"),
    7: .same(proto: "SNMP_V3_GET_REQUEST"),
    8: .same(proto: "NTP_MESSAGE"),
    9: .same(proto: "XDMCP"),
    10: .same(proto: "KERBEROS"),
    11: .same(proto: "SIP_OPTIONS"),
    12: .same(proto: "LDAP_SEARCH_REQ"),
    13: .same(proto: "MEMCACHED_STATS"),
    14: .same(proto: "OPENVPN"),
    15: .same(proto: "CIFS_NS_UC"),
    16: .same(proto: "TFTP_GET"),
    17: .same(proto: "DHCP_INFORM"),
    18: .same(proto: "QUIC"),
    19: .same(proto: "RIPV1"),
    20: .same(proto: "NFS_PROC_NULL"),
    21: .same(proto: "COAP_REQUEST"),
  ]
}
